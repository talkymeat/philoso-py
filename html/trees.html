<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>trees API documentation</title>
<meta name="description" content="I am at last re-implementing my PhD code in Python, and also in a
less shit way than before, and with some enhancements. The plan is
to:
* â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>trees</code></h1>
</header>
<section id="section-intro">
<p>I am at last re-implementing my PhD code in Python, and also in a
less shit way than before, and with some enhancements. The plan is
to:
* implement regular DOP &amp; its derivatives
* implement NN-like tuning between substitution and children,
designed to learn the most effective DOP probability model
* implement DDOP-style incremental running
* implement other DDOP variants
* combine DDOP with NeuroDOP for bootstrappable node-labelling
* Motor DDOP</p>
<p>Right now, I'm just working on getting a suitable set of classes
for making labelled trees</p>
<p>Created on Thu Nov 30 16:59:45 2017</p>
<p>@author: Dave Cochran</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3
# -*- coding: utf-8 -*-
&#34;&#34;&#34;
I am at last re-implementing my PhD code in Python, and also in a
less shit way than before, and with some enhancements. The plan is
to:
    * implement regular DOP &amp; its derivatives
    * implement NN-like tuning between substitution and children,
        designed to learn the most effective DOP probability model
    * implement DDOP-style incremental running
    * implement other DDOP variants
    * combine DDOP with NeuroDOP for bootstrappable node-labelling
    * Motor DDOP

Right now, I&#39;m just working on getting a suitable set of classes
for making labelled trees

Created on Thu Nov 30 16:59:45 2017

@author: Dave Cochran
&#34;&#34;&#34;

import re
from copy import copy
from abc import ABC, abstractmethod
from dataclasses import dataclass
import json
from typing import List, Dict, Type, Union, Tuple
from typing_extensions import Protocol, runtime_checkable


class Operators:
    &#34;&#34;&#34;Class to contain operators to which perform computations
    on the values of the child nodes of trees, such that the value
    of a nonterminal is `parent_operator(*[children_values])` and
    the value of a terminal is its content.

    In a DOP implementation for NLP, this means that the terminal
    contents will be (typically) words, and only one operator will
    be used, the concatenation operator CONCAT, and the value of
    any complete parse tree will be the sentence it parses, and the
    value of any node will be the constituent underneath it.

    In genetic programming, multiple operators will be used, for
    arithmetic and boolean operations - possibly more besides.
    &#34;&#34;&#34;

    def ID(*args):
        &#34;&#34;&#34;Returns a tuple of the node&#39;s children. The basic-ass default
        operator. Mistakes ability to remember funny lines from telly for being
        funny. Listens to local radio. Has one significant ambition in life,
        which is to win the lottery.
        &#34;&#34;&#34;
        return args

    def CONCAT(*args):
        &#34;&#34;&#34;Concatenates the string representations of child node with a space
        as a separator. Useful for Data Oriented Parsing, as it returns the
        original sentence that the tree parses. `ID`&#39;s hipster cousin who moved
        to the Netherlands. Sighs loudly at tipexed-on bike lanes when back in
        the UK. Doesn&#39;t go to coffeeshops cause they&#39;re for tourists. Would love
        to have a good excuse to justify the cost of a bakfiets.
        &#34;&#34;&#34;
        return &#34; &#34;.join(args)


class Tree(ABC):
    &#34;&#34;&#34;Abstract Base Class defining behaviour for all tree nodes.

    All trees are labelled, but some have children (lists of tree nodes below
    them in the tree structure), and others have leaves - concrete content like
    words in syntactic parse trees or constants and variables in Genetic
    Programming systems: so the abstract base class contains a constructor that
    sets the label, but which the subclasses can extend to add leaves or
    children.

    Attributes:
        _label (Label): Node label determining which subtrees can be substituted
            where. Set and got by the `label` @property
        parent (NonTerminal or None): The node dirctly above the present in the
            tree. Each child has a reference to its parent, and each parent has
            references to all its children.
        treebank (Treebank): Every tree belongs to a Treebank, which defines the
            set of Labels that `Tree`, its parents, and its children can take.

    Raises:
        TypeError: if the `label` passed to `__init__` is not a valid Label.
    &#34;&#34;&#34;

    def __init__(self, treebank, label):
        # Set parent to None: parent, if there is one, will set child&#39;s `parent`
        # param
        self.parent = None
        # TODO: Maybe treebank just needs to be in Label - make it a @property
        # here
        self.treebank = treebank
        # DOP uses strings as labels, GP uses types, so those are OK
        if isinstance(label, (str, type)):
            self.label = treebank.get_label(label)
        # Or if a Label is passed as label, that&#39;s fine too
        elif issubclass(type(label), Label):
            self.label = label;
        # Otherwise it can suck it
        else:
            raise TypeError(f&#34;Invalid label of type {type(label)}&#34;)

    @property
    def label(self):
        &#34;&#34;&#34;Label: Attribute storing a node label&#34;&#34;&#34;
        if hasattr(self, &#39;_label&#39;):
            return self._label

    @label.setter
    def label(self, label):
        &#34;&#34;&#34;Setter for label. Ensures that the tree node is registered with its
        label. Deletes label from node if called with `label=None`
        &#34;&#34;&#34;
        if isinstance(label, Label):
            self._label = label
            self.label.add_node(self)
        elif label is None:
            del(self._label)
        else:
            raise TypeError(
                &#34;You can set a label to be a Label, or None, but not &#34; +
                f&#34;{type(label)}.&#34;
            )

    @abstractmethod
    def __len__(self) -&gt; int:
        &#34;&#34;&#34;Number of children&#34;&#34;&#34;
        pass

    def __iter__(self):
        return TreeIter(self)

    def __copy__(self):
        &#34;&#34;&#34;Generates a deep copy of a tree: the same structure, same Labels, and
        for the Terminals, same content: but each node a distinct object in
        memory from the corresponding node in the original. The new NonTerminal
        and its children belong to the same treebank as the original.

        Returns
        -------
            NonTerminal: copy of original tree

        &gt;&gt;&gt; from functools import reduce
        &gt;&gt;&gt; t = test_trees() + test_fragments()
        &gt;&gt;&gt; tcopy = [copy(x) for x in t]
        &gt;&gt;&gt; idents = [id(cp) == id(og) for cp, og in zip(tcopy, t)]
        &gt;&gt;&gt; equals = [cp == og for cp, og in zip(tcopy, t)]
        &gt;&gt;&gt; print(reduce(lambda a, b: a and b, equals))
        True
        &gt;&gt;&gt; print(reduce(lambda a, b: a or b, idents))
        False
        &#34;&#34;&#34;
        return self.copy_out(self.treebank)

    @abstractmethod
    def depth(self) -&gt; int:
        &#34;&#34;&#34;Length of chain from self to it&#39;s most distant descendant-node&#34;&#34;&#34;
        pass

    @abstractmethod
    def width(self) -&gt; int:
        &#34;&#34;&#34;Number of leaf nodes below current&#34;&#34;&#34;
        pass

    @abstractmethod
    def size(self) -&gt; int:
        &#34;&#34;&#34;Number of nodes in tree overall&#34;&#34;&#34;
        pass

    @abstractmethod
    def to_LaTeX(self) -&gt; str:
        &#34;&#34;&#34;Outputs LaTeX representation of tree. Handy for putting in papers&#34;&#34;&#34;
        pass

    @abstractmethod
    def __call__(self):
        &#34;&#34;&#34;All nodes are callable: Terminals return their leaf, always:
        NonTerminals call an Operator that belongs to the Label
        &#34;&#34;&#34;
        pass

    @abstractmethod
    def __eq__(self, other):
        &#34;&#34;&#34;True if two trees are identical&#34;&#34;&#34;
        pass

    @abstractmethod
    def __str__(self):
        &#34;&#34;&#34;Readable printout&#34;&#34;&#34;
        pass

    @abstractmethod
    def __getitem__(self, position):
        &#34;So children can be indexed positionally&#34;
        pass

    @abstractmethod
    def copy_out(self, treebank):
        &#34;&#34;&#34;Copy self with all children. Copy exists in `treebank`.&#34;&#34;&#34;
        pass

    @abstractmethod
    def delete(self):
        &#34;&#34;&#34;Removes a tree and all its descendants from their treebank.&#34;&#34;&#34;
        pass

    def __repr__(self) -&gt; str:
        &#34;&#34;&#34;Returns a string such that tree == eval(tree.__repr__())&#34;&#34;&#34;
        return f&#39;tree(&#34;{str(self)}&#34;)&#39;


class NonTerminal(Tree):
    &#34;&#34;&#34;Generic class for non-terminal tree nodes: that is, nodes which do not
    carry terminal content like words in syntactic parsing or constants and
    variables in genetic programming, but which can take other tree nodes as
    children

    TODO: add a metadata attribute

    Parameters
    ----------
    _label : Label
        Inherited from Tree. Node label determining which subtrees can be
        substituted where. Set and got by the `label` @property
    parent : NonTerminal or None
        Inherited from Tree. The node dirctly above the present in the tree.
        Each child has a reference to its parent, and each parent has references
        to all its children.
    treebank : Treebank
        Every tree belongs to a Treebank, which defines the set of Labels that
        `Tree`, its parents, and its children can take.
    _children : list of Trees or None
        The nodes directly below the present in the tree.
    &#34;&#34;&#34;

    STRICT_ADDITION = True
    &#34;&#34;&#34;bool: If True, the `+` operator does leftmost nonterminal substitution,
    which throws an error if the liftmost nonterminal leaf node label of the
    left operand does not match the root label of the right operand; if False it
    substitutes the right operand into the leftmost matching nonterminal
    leafnode, and raises an error only if there is no match.
    &#34;&#34;&#34;

    def __init__(self, treebank, label, *children):
        self.children = list(children)
        super().__init__(treebank, label)

    @property
    def children(self):
        &#34;&#34;&#34;Getter for the children attribute&#34;&#34;&#34;
        return self._children

    @children.setter
    def children(self, children):
        &#34;&#34;&#34;Checks that the elements of the `children` param are all Trees,
        and if they are, sets their `parent` attributes to `self`, and set the
        list to be the `_children` attribute of self. The attribute will only be
        set if all list members are valid children: if an invalid child is found
        an error is raised and any list members that had their `parent`
        attribute set to `self` will have it set back to `None`.

        TODO: check that children belong to same treebank, or copy children in
            to Treebank if arg `copy_in = True` (default to False)

        Raises
        ------
        TypeError
            If something other than a tree is passed as a child
        &#34;&#34;&#34;
        for i, c in enumerate(children): # Make sure all children are Trees
            if isinstance(c, self.__class__) or isinstance(c, Terminal):
                c.parent = self # If the child is a tree, self can be its parent
            else:
                # If not...
                for orphan in children[:i]:
                    # This is the saddest line of code I have ever written
                    orphan.parent = None
                raise TypeError(f&#34;You tried to set a {type(c):s}, {c:s} as \
                                a child of the Tree {self:s}. You \
                                should have used a Tree&#34;)
        # If all children typecheck OK, it&#39;s ok to go ahead and set them as
        # the children of the current node
        self._children = children

    def __len__(self) -&gt; int:
        &#34;&#34;&#34;All nodes have a length: Terminals have length 1, while NonTerminals
        have a length equal to the number of children

        Returns
        -------
        int:  Number of children

        &gt;&gt;&gt; t = test_trees()
        &gt;&gt;&gt; print([len(tx) for tx in t])
        [1, 2, 2, 2, 2, 2, 2, 2]
        &gt;&gt;&gt; print([len(tree(f&#34;([S]{&#39;([N]blah)&#39;*x})&#34;)) for x in range(11)])
        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
        &gt;&gt;&gt; tf = test_fragments()
        &gt;&gt;&gt; print([len(tfx) for tfx in tf])
        [2, 2, 0]
        &#34;&#34;&#34;
        return len(self._children) if hasattr(self, &#39;_children&#39;) else 0

    def __str__(self):
        &#34;&#34;&#34;Readable string representation of a tree. This consists of a pair of
        parentheses containing a representation of the tree&#39;s label (label name
        in square brackets), followed by a representation of the node&#39;s
        children, which is just each child&#39;s representation, concatenated, eg:

        ([VP]([V]&#39;bites&#39;)([N]&#39;man&#39;)).

        &gt;&gt;&gt; # No doctest needed here, as doctest for test_trees also tests this
        &#34;&#34;&#34;
        lab_str = self.label if hasattr(self, &#39;_label&#39;) else &#39;&#39;
        # The list comprehension here uses a range rather than looping directly
        # over self because Python loops use IndexError-catching to know when to
        # stop looping, and I want to be able to include str(tree) in the custom
        # error message when a tree is indexed with an invalid index, and if
        # that error is thrown every time a tree is looped over, and the error
        # message calls tree.__str__(), which loops over the tree, which throws
        # the custom error, which calls tree.__str__()...
        #
        # URGH RecursionError: maximum recursion depth exceeded
        #
        # This is a jank-ass solution to the problem and I&#39;m mad about it :|
        return f&#34;({lab_str}{&#39;&#39;.join([str(self[i]) for i in range(len(self))]) if self else &#39;&#39;})&#34;

    def depth(self) -&gt; int:
        &#34;&#34;&#34;All nodes have a depth: the depth of a leaf node is 1, and the depth
        of any other node is the depth of its deepest child + 1

        Returns
        -------
        int:
            Tree depth

        &gt;&gt;&gt; t = test_trees()
        &gt;&gt;&gt; print([tx.depth() for tx in t])
        [1, 3, 3, 3, 4, 3, 3, 2]
        &gt;&gt;&gt; tf = test_fragments()
        &gt;&gt;&gt; print([tfx.depth() for tfx in tf])
        [3, 3, 0]
        &gt;&gt;&gt; blah_depths = []
        &gt;&gt;&gt; blah = &#34;([S]&#39;blah&#39;)&#34;
        &gt;&gt;&gt; print(tree(blah).depth())
        1
        &gt;&gt;&gt; for i in range(8):
        ...     blah = blah.replace(&#34;&#39;blah&#39;&#34;, blah)
        ...     blah_depths.append(tree(blah).depth())
        ...
        &gt;&gt;&gt; print(blah_depths)
        [2, 4, 8, 16, 32, 64, 128, 256]
        &gt;&gt;&gt; tb = Treebank()
        &gt;&gt;&gt; fragment = tree(&#34;([S]([PN]&#39;I&#39;)([VP]))&#34;, treebank = tb)
        &gt;&gt;&gt; fragment.depth()
        2
        &#34;&#34;&#34;
        # Recursive function with two stopping cases: if called on a
        # NonTerminal leafnode, or in a Terminal. The `else` case below handles
        # the former, and for the latter, Terminal has its own version of the
        # function
        return (1 + max([c.depth() for c in self])) if self.children else 0

    def width(self) -&gt; int:
        &#34;&#34;&#34;All nodes have a width: the width of a leaf node is 1, and the width
        of any other node is the sum of its children&#39;s widths. This is
        equivalent to the total number of leaf nodes in the tree

        Returns
        -------
        int:
            Tree width

        &gt;&gt;&gt; t = test_trees()
        &gt;&gt;&gt; print([tx.width() for tx in t])
        [1, 3, 3, 3, 5, 3, 3, 2]
        &gt;&gt;&gt; tf = test_fragments()
        &gt;&gt;&gt; print([tfx.width() for tfx in tf])
        [3, 4, 1]
        &gt;&gt;&gt; blah_widths = []
        &gt;&gt;&gt; blah = &#34;([N]&#39;blah&#39;)&#34;
        &gt;&gt;&gt; print(tree(blah).width())
        1
        &gt;&gt;&gt; for i in range(1,4):
        ...     blah_top = &#34;([S]&#39;blah&#39;)&#34;
        ...     for j in range(8):
        ...         blah_top = blah_top.replace(&#34;&#39;blah&#39;&#34;, blah*i)
        ...         blah_widths.append(tree(blah_top).width())
        ...
        &gt;&gt;&gt; print(blah_widths)
        [1, 1, 1, 1, 1, 1, 1, 1, 2, 4, 8, 16, 32, 64, 128, 256, 3, 9, 27, 81, 243, 729, 2187, 6561]
        &gt;&gt;&gt; tb = Treebank()
        &gt;&gt;&gt; fragment = tree(&#34;([S]([PN]&#39;I&#39;)([VP]))&#34;, treebank = tb)
        &gt;&gt;&gt; fragment.width()
        2
        &#34;&#34;&#34;
        return max(sum([c.width() for c in self]), 1)

    def size(self) -&gt; int:
        &#34;&#34;&#34;All nodes have a size: the size of a leaf node is 1, and the size
        of any other node is the sum of its children&#39;s sizes, plus 1. This is
        the total number of nodes in the tree.

        Returns
        -------
        int:
            total number of nodes in the tree

        &gt;&gt;&gt; t = test_trees()
        &gt;&gt;&gt; print([tx.size() for tx in t])
        [1, 5, 5, 5, 9, 5, 5, 3]
        &gt;&gt;&gt; tf = test_fragments()
        &gt;&gt;&gt; print([tfx.size() for tfx in tf])
        [5, 7, 1]
        &gt;&gt;&gt; blah_sizes = []
        &gt;&gt;&gt; blah = &#34;([N]&#39;blah&#39;)&#34;
        &gt;&gt;&gt; print(tree(blah).size())
        1
        &gt;&gt;&gt; for i in range(1,4):
        ...     blah_top = &#34;([S]&#39;blah&#39;)&#34;
        ...     for j in range(8):
        ...         blah_top = blah_top.replace(&#34;&#39;blah&#39;&#34;, blah*i)
        ...         blah_sizes.append(tree(blah_top).size())
        ...
        &gt;&gt;&gt; print(blah_sizes)
        [2, 3, 4, 5, 6, 7, 8, 9, 3, 7, 15, 31, 63, 127, 255, 511, 4, 13, 40, 121, 364, 1093, 3280, 9841]
        &#34;&#34;&#34;
        return 1 + sum([c.size() for c in self])

    def __eq__(self, other):
        &#34;&#34;&#34;Checks that two trees are the same: for this to return true, the
        trees must be of the same type, with the same root label, with the same
        number of children, and each child in self must equal the child at the
        same index in other. `Terminal`s must also have equal leaves. Magic
        method for operator overloading on `==` and `!=`.

        TODO: make sure Label has an appropriate __eq__ method.

        Parameters
        ----------
        other : Tree
            The right operand

        Returns
        -------
        bool
            True if trees are equal, False otherwise

        &gt;&gt;&gt; t = test_trees()
        &gt;&gt;&gt; t[0] == t[0]
        True
        &gt;&gt;&gt; t[1] == t[1]
        True
        &gt;&gt;&gt; t[3] == t[1]
        True
        &gt;&gt;&gt; t[3] == t[2]
        True
        &gt;&gt;&gt; t[1] == t[3]
        True
        &gt;&gt;&gt; t[1] == t[2]
        True
        &gt;&gt;&gt; t[2] == t[3]
        True
        &gt;&gt;&gt; t[2] == t[1]
        True
        &gt;&gt;&gt; t[1] == t[4]
        False
        &gt;&gt;&gt; t[1] == t[5]
        False
        &gt;&gt;&gt; t[1] == t[6]
        False
        &gt;&gt;&gt; tf = test_fragments()
        &gt;&gt;&gt; for tfx in tf:
        ...     print([int(tfx == tfy) for tfy in tf])
        ...
        [1, 0, 0]
        [0, 1, 0]
        [0, 0, 1]
        &#34;&#34;&#34;
        # First check all the local property comparisons
        if self.__class__ == other.__class__ and self.label == other.label and len(self) == len(other):
            # If all of those come up true, check the children
            for self_c, other_c in zip(self, other):
                # If any children are not equal, self and other are not equal
                if self_c != other_c:
                    return False
            # If all of that fails to return false, self and other are equal
            return True
        # If the local comparisons do not all come out true, they are not equal
        else:
            return False

    def to_LaTeX(self, top = True):
        &#34;&#34;&#34;Converts trees to LaTeX expressions using the `qtree` package.
        Remember to include `\\usepackage{qtree}` in the document header. For
        NonTerminals, the format is `[.$label $child* ]`. The label expression
        is provided by a similar function in Label. The $child expressions are
        recursively in the same format again (if they are also NonTerminals), or
        `[.$label $leaf]` for Terminals, which have a separate `to_LaTeX`
        method.

        Parameters
        ----------
        top : bool
            qtrees expressions must be prefixed with `\\Tree`, but this only
            applies to the whole tree: you don&#39;t put it in front of every node.
            However, this function uses recursive calls to make the LaTeX of
            child nodes, so making sure only the top node has this prefix takes
            a bit of extra logic. If the node has no parent, the `\\Tree` prefix
            is automaticaly applied, otherwise by default it isn&#39;t. However, if
            LaTeX is wanted for a partial tree, `top` may be set to `True`

        Returns
        -------
        str
            LaTeX expression representing the tree.

        &gt;&gt;&gt; t = test_trees()
        &gt;&gt;&gt; for x in t[1:]:
        ...     print(x.to_LaTeX())
        ...
        \Tree [.S [.N sentence ] [.VP [.V parses ] [.N parser ] ] ]
        \Tree [.S [.N sentence ] [.VP [.V parses ] [.N parser ] ] ]
        \Tree [.S [.N sentence ] [.VP [.V parses ] [.N parser ] ] ]
        \Tree [.S [.NP [.Det the ] [.N sentence ] ] [.VP [.V parses ] [.NP [.Det the ] [.N parser ] ] ] ]
        \Tree [.S [.N word ] [.VP [.V parses ] [.N parser ] ] ]
        \Tree [.S [.N sentence ] [.VP [.V parses ] [.V parser ] ] ]
        \Tree [.S [.X x ] [.Y y ] ]
        &gt;&gt;&gt; tf = test_fragments()
        &gt;&gt;&gt; for tfx in tf:
        ...     print(tfx.to_LaTeX())
        ...
        \Tree [.S [.NP [.Det the ] [.N cat ] ] [.VP ] ]
        \Tree [.S [.NP [.Det the ] [.N cat ] ] [.VP [.V ate ] [.NP ] ] ]
        \Tree [.NP ]
        &#34;&#34;&#34;
        # prepends \Tree if needed
        LaTeX = r&#34;\Tree &#34; if not (hasattr(self, &#39;parent&#39;) and self.parent) or top else &#34;&#34;
        LaTeX += f&#34;[{self.label.to_LaTeX()} {&#39;&#39;.join([c.to_LaTeX(top = False) for c in self])}] &#34;
        return LaTeX.strip() if top else LaTeX

    def __getitem__(self, position):
        &#34;&#34;&#34;All trees are indexable, with the i^th index retrieving the i^th
        child, except with Terminals, where the zeroth and only item is the leaf
        value. Multiple indices can be provided, comma separated, to index a
        grandchild, great-grandchild, etc.

        Parameters
        ----------
        position : int or tuple of ints
            If `int`, the index of a child in `self`&#39;s list of children. If
            `tuple`, a sequence of indices to navigate downwards from `self` to
            a specified descendant of `self`

        Returns
        -------
        Tree or str, int, float, etc, depending on the valid types for leaf
        content
            A descendant of `self` located by index. If the penultimate term in
            the list of tuples indicates a `Terminal`, and the last index is 0,
            this will return the leaf content of that `Terminal`

        Raises
        ------
        IndexError:
            Raises a custom IndexError if the path through the tree represented
            by `position` does not exist. This can happen if:
                * A NonTerminal with children is indexed, but the index is out
                of range
                * A NonTerminal without children is indexed at all
                * A Terminal is indexed with an int other than 0
                * A Terminal is indexed with a tuple of length greater than 1,
                even if the first item in the tuple is 0

        &gt;&gt;&gt; t1 = tree(&#34;([S]([N]sentence)([VP]([V]parses)([NP]([Det]a)([N]parser))))&#34;)
        &gt;&gt;&gt; print(t1[0])
        ([N]&#39;sentence&#39;)
        &gt;&gt;&gt; print(t1[0, 0])
        sentence
        &gt;&gt;&gt; print(t1[1, 0])
        ([V]&#39;parses&#39;)
        &gt;&gt;&gt; print(t1[1, 1])
        ([NP]([Det]&#39;a&#39;)([N]&#39;parser&#39;))
        &gt;&gt;&gt; print(t1[1, 1, 0])
        ([Det]&#39;a&#39;)
        &gt;&gt;&gt; print(t1[1, 1, 0, 0])
        a
        &gt;&gt;&gt; print(t1[1, 2]) # doctest: +IGNORE_EXCEPTION_DETAIL
        Traceback (most recent call last):
        IndexError: Index out of range. The Tree:
        ([VP]([V]&#39;parses&#39;)([NP]([Det]&#39;a&#39;)([N]&#39;parser&#39;)))
        was indexed with:
        (2,)
        but does not have a subtree at:
        (2,)
        Index out of range.
        &gt;&gt;&gt; tf = test_fragments()
        &gt;&gt;&gt; print(tf[0][1])
        ([VP])
        &gt;&gt;&gt; print(tf[0][1, 0, 0]) # doctest: +IGNORE_EXCEPTION_DETAIL
        Traceback (most recent call last):
        IndexError: Index out of range. The Tree:
        ([VP])
        was indexed with:
        (0, 0)
        but does not have a subtree at:
        (0,)
        NonTerminal leaf-nodes cannot be indexed
        &gt;&gt;&gt; print(tf[0][0, 1])
        ([N]&#39;cat&#39;)
        &gt;&gt;&gt; print(tf[1][1, 0])
        ([V]&#39;ate&#39;)
        &gt;&gt;&gt; print(tf[1][1])
        ([VP]([V]&#39;ate&#39;)([NP]))
        &gt;&gt;&gt; print(tf[1][1, 1])
        ([NP])
        &gt;&gt;&gt; t2 = tree(&#34;([S]([PN]&#39;we&#39;)([VP]([V]&#39;ate&#39;)([NP]([Det]&#39;a&#39;)([NN]([Adj])([N]&#39;pie&#39;)))))&#34;)
        &gt;&gt;&gt; print(t2[1][1,1,2]) # doctest: +IGNORE_EXCEPTION_DETAIL
        Traceback (most recent call last):
        IndexError: Index out of range. The Tree:
        ([VP]([V]&#39;ate&#39;)([NP]([Det]&#39;a&#39;)([NN]([Adj])([N]&#39;pie&#39;))))
        was indexed with:
        (1, 1, 2)
        but does not have a subtree at:
        (1, 1, 2)
        Index out of range.
        &gt;&gt;&gt; print(t2[1][1,1,2,99]) # doctest: +IGNORE_EXCEPTION_DETAIL
        Traceback (most recent call last):
        IndexError: Index out of range. The Tree:
        ([VP]([V]&#39;ate&#39;)([NP]([Det]&#39;a&#39;)([NN]([Adj])([N]&#39;pie&#39;))))
        was indexed with:
        (1, 1, 2, 99)
        but does not have a subtree at:
        (1, 1, 2)
        Index out of range.
        &gt;&gt;&gt; print(t2[1][1,1,0,0]) # doctest: +IGNORE_EXCEPTION_DETAIL
        Traceback (most recent call last):
        IndexError: Index out of range. The Tree:
        ([VP]([V]&#39;ate&#39;)([NP]([Det]&#39;a&#39;)([NN]([Adj])([N]&#39;pie&#39;))))
        was indexed with:
        (1, 1, 0, 0)
        but does not have a subtree at:
        (1, 1, 0, 0)
        NonTerminal leaf-nodes cannot be indexed
        &gt;&gt;&gt; print(t2[1][1,1,1,1,0,0,1,2,3]) # doctest: +IGNORE_EXCEPTION_DETAIL
        Traceback (most recent call last):
        IndexError: Index out of range. The Tree:
        ([VP]([V]&#39;ate&#39;)([NP]([Det]&#39;a&#39;)([NN]([Adj])([N]&#39;pie&#39;))))
        was indexed with:
        (1, 1, 1, 1, 0, 0, 1, 2, 3)
        but does not have a subtree at:
        (1, 1, 1, 1, 0, 0)
        Terminals do not have child nodes.
        &#34;&#34;&#34;
        # If an int is given as index i, make it a singleton tuple
        if isinstance(position, int):
            position = (position,)
        # If the node has no children, or the index at the head of position is
        # out of range for the list self._children, the index points to a node
        # that doesn&#39;t exist, and an IndexError should be raised
        if position[0] &gt;= len(self) or position[0] &lt; -len(self):
            # if `position` is an `int`, convert it to a singleton `tuple`
            if type(position) == int:
                position = (position, )
            # `wrong` represents the tuple index up to the first point at which
            # it went wrong, which here means just the head of the tuple
            wrong = position[:1]
            # define an extra message to explain exactly how it went wrong...
            if self:
                # ... if self has children, but the index is out of range
                err = &#34;Index out of range.&#34;
            else:
                # ... or if self is a NonTerminal leaf-node, and hence
                # unindexible
                err = &#34;NonTerminal leaf-nodes cannot be indexed&#34;
            # Newlines are used to separate the elements of the error message,
            # so if this is a recursive call, the call above it can easily
            # modify the error message to show the tree the erroneous index was
            # originally called on, the complete index, and the complete &#39;wrong&#39;
            # path
            raise IndexError(
                f&#34;Index out of range. The Tree:\n{self}\nwas indexed with:\n&#34; +
                f&#34;{position}\nbut does not have a subtree at:\n{wrong}\n{err}&#34;
            )
        # This try block does the actual work of accessing children and
        # recursing down the tree if needed, but it needs the error-handling in
        # case the recursive call runs into an IndexError. The error message
        # will have, in the call at which the error was first raised, the string
        # representation of the node at which the error was raised, and values
        # of position and wrong based on the index used int *that* call.
        # However, the error message shown in the end should show the node the
        # original call was made on and the index-tuples called on that node -
        # the complete &#39;position&#39; and the tuple up to the error site, &#39;wrong&#39;
        try:
            # If a tuple of length 1, use the int in the tuple to index self&#39;s
            # list of children
            if len(position) == 1:
                return self._children[position[0]]
            # For all other lengths, use the head of the list to get the correct
            # child, then a recursive call using the tail as the index
            # Note that this:
            #     return self[position[0]][position[1:]]
            # would also work, but would make the call stack almost twice as
            # deep, so I decided against it
            else:
                return self._children[position[0]][position[1:]]
        except IndexError as e:
            # If a downstream call raises an IndexError, modify it to show the
            # error from the viewpoint of the current node, not the downstream
            # node that raised the error
            e_lines = str(e).split(&#34;\n&#34;)
            e_lines[1] = str(self)
            # e_lines[3] is the tuple index *up to* the point where it goes
            # wrong - including the *first* incorrect index but no more. It&#39;s
            # necessary here to just slip the head of the current index onto
            # the front here
            e_lines[3] = f&#34;({position[0]}, {e_lines[3][1:]}&#34;.replace(&#39;,)&#39;, &#39;)&#39;)
            e_lines[5] = f&#34;{position}&#34;
            # The `from None` here prevents the error being shown as a chain of
            # &#34;During handling of the above exception, another exception
            # occurred:&#34; messages
            raise IndexError(&#34;\n&#34;.join(e_lines)) from None



    def __setitem__(self, key, value):
        &#34;&#34;&#34;The children of a Tree can be set using `int` indices, with the i^th
        index setting the i^th child, except with Terminals, where the zeroth
        and only index sets the leaf value. Multiple indices can be provided,
        comma separated, to set a grandchild, great-grandchild, etc. However,
        the path from `self` to site at which `value` is to be inserted must
        go through existing tree-nodes only, otherwise an IndexError is raised.
        If the i^th child slot is not empty, the existing child will be
        replaced and deleted from the `Label`.

        Parameters
        ----------
        key : int
            The index at which the new child is to be placed
        value : Tree or None
            The new child of `self` at index `key`

        Raises
        ------
        IndexError:
            If key is not an int or tuple of ints, or is out of range
        AttributeError:
            If value is not a Tree

        &gt;&gt;&gt; tb = Treebank()
        &gt;&gt;&gt; t0 = tree(&#34;([S]([NP]([Det]&#39;the&#39;)([N]&#39;dog&#39;))([VP]))&#34;, treebank = tb)
        &gt;&gt;&gt; t1 = tree(&#34;([VP]([V]&#39;eats&#39;)([NP]))&#34;, treebank = tb)
        &gt;&gt;&gt; t2 = tree(&#34;([NP]([Det]&#39;the&#39;)([N]&#39;pie&#39;))&#34;, treebank = tb)
        &gt;&gt;&gt; t0[1] = t1
        &gt;&gt;&gt; t0
        tree(&#34;([S]([NP]([Det]&#39;the&#39;)([N]&#39;dog&#39;))([VP]([V]&#39;eats&#39;)([NP])))&#34;)
        &gt;&gt;&gt; t0[1].parent
        tree(&#34;([S]([NP]([Det]&#39;the&#39;)([N]&#39;dog&#39;))([VP]([V]&#39;eats&#39;)([NP])))&#34;)
        &gt;&gt;&gt; t0[1, 1] = t2
        &gt;&gt;&gt; t0
        tree(&#34;([S]([NP]([Det]&#39;the&#39;)([N]&#39;dog&#39;))([VP]([V]&#39;eats&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;pie&#39;))))&#34;)
        &gt;&gt;&gt; t0[1, 1].parent
        tree(&#34;([VP]([V]&#39;eats&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;pie&#39;)))&#34;)
        &#34;&#34;&#34;
        # First, make sure
        if type(key) != int and (type(key) != tuple or (type(key) == tuple and type(key[0]) != int)):
            raise IndexError(&#34;indices for Trees can only be ints or tuples of&#34; +
                f&#34; ints: you used a {type(key).__name__}&#34;)
        elif not isinstance(value, Tree) and not value is None:
            raise AttributeError(&#34;only Trees or None may be set as children &#34; +
                f&#34;of Trees: you used a {type(value).__name__}&#34;)
        elif type(key) == int or len(key) == 1:
            k = key if type(key) == int else key[0]
            try:
                if not self[k] is None:
                    self[k].delete(False)
                self.children[k] = value
                self.children[k].parent = self
            except IndexError:
                raise IndexError
        elif sum(type(k) != int for k in key):
            raise IndexError(
                f&#34;A tuple index must be a tuple of ints only.&#34;
            )
        else:
            try:
                # Uses the head of the key to identify the correct child, then
                # recursively call __setitem__ on the child using the tail.
                # Note that this:
                #     self[key[0]][key[1:]] = value
                # would also work, but would require almost twice many recursive
                # calls, so I decided against it
                self._children[key[0]][key[1:]] = value
            except IndexError as e:
                raise IndexError


    def copy_out(self, treebank = None):
        &#34;&#34;&#34;Generates a deep copy of a tree: the same structure, same Labels, and
        for the Terminals, same content: but each node a distinct object in
        memory from the corresponding node in the original. If a Treebank is
        passed to `treebank`, the new NonTerminal and its children will belong
        to `treebank`.

        If `treebank` is `None`, a new empty Treebank will be created, and the
        new NonTerminal will belong to that instead. This acts as a &#39;dummy
        treebank&#39;, in the case where trees are needed temporarily for some
        computation, without the overhead of storing them in an existing
        treebank.
        &#34;&#34;&#34;
        # If `treebank` is None...
        if not treebank:
            # create a dummy treebank, and then it won&#39;t be None
            treebank = Treebank()
        # Then create the copied NonTerminal, and recursively copy its children,
        # also to `treebank`: this means, if the function is called with
        # `treebank == None`, the whole tree-fragment will be copied to the same
        # dummy treebank.
        return NonTerminal(
            treebank,
            self.label if treebank == self.treebank else treebank.get_label(self.label.classname),
            *[c.copy_out(treebank) for c in self]
        )

    def get_leftmost_substition_site(self):
        &#34;&#34;&#34;
        Returns a SubstitutionSite object pointing to the leftmost non-terminal
        leaf-node: a non-terminal leaf node being a node that is capable of
        having children, but has none.

        Note that this has no counterpart in Terminal: it only makes sense to
        look for NonTerminal leaf nodes at or under NonTerminals

        Returns
        -------
        SubstitutionSite:
            An object containing the parent node of the leftmost nonterminal
            leafnode, the index in the parent at which the substitution site
            occurs, and the label at the substitution site

        &gt;&gt;&gt; t0 = tree(&#34;([S]([NP]([Det])([N]sentence))([VP]([V]parses)([NP]([Det]the)([N]parser))))&#34;)
        &gt;&gt;&gt; t1 = tree(&#34;([S]([NP]([Det])([N]sentence))([VP]([V]parses)([NP]([Det]the)([N]))))&#34;)
        &gt;&gt;&gt; t2 = tree(&#34;([S]([NP]([Det]the)([N]))([VP]([V]parses)([NP])))&#34;)
        &gt;&gt;&gt; t3 = tree(&#34;([S]([NP]([Det])([N]))([VP]([V])([NP]([Det])([N]))))&#34;)
        &gt;&gt;&gt; t4 = tree(&#34;([S]([NP])([VP]))&#34;)
        &gt;&gt;&gt; t5 = tree(&#34;([S]([NP]([Det]the)([N]sentence))([VP]([V]parses)([NP]([Det]the)([N]parser))))&#34;)
        &gt;&gt;&gt; for t in (t0, t1, t2, t3, t4, t5):
        ...     ss = t.get_leftmost_substition_site()
        ...     print(ss.site if ss else ss)
        ...
        ([Det])
        ([Det])
        ([N])
        ([Det])
        ([NP])
        None
        &#34;&#34;&#34;
        # It is assumed that this is not called directly on zero-depth
        # NonTerminals, but more usually on the root node of a tree
        for i, c in enumerate(self):
            # Don&#39;t bother checking any child that is a Terminal, we are only
            # interested in childless NonTerminals
            if not hasattr(c, &#39;leaf&#39;):
                if not hasattr(c, &#39;children&#39;) or not len(c.children):
                    # If the child is childless, it is a nonterminal leafnode,
                    # which we return immediately as the first one we find is
                    # the leftmost. The object returned, however, is not the
                    # node itself, but a dataclass object containing `self` (the
                    # parent of the substitution site), i, the index of the
                    # substitution site in self, and the label at the
                    # substitution site, as this determines what can be
                    # substituted there. SubstitutionSite also has a method
                    # which takes a subtree as an argument, and performs the
                    # substitution if the label matches
                    return SubstitutionSite(self, i, c.label)
                # otherwise, recursively call this function
                ss = c.get_leftmost_substition_site()
                # If a ss is found, return it. This function doesn&#39;t reach a
                # `return` line if no nonterminal leaf is found, so will return
                # `None`, meaning lnl will be None if no ss is found my the
                # recursive call, so the conditional won&#39;t be triggered
                if ss:
                    return ss

    def get_all_substitition_sites(self):
        &#34;&#34;&#34;
        Returns the all non-terminal leaf-node: a non-terminal leaf node
        being a node that is capable of having children, but has none.

        Note that this has no counterpart in Terminal: it only makes sense to
        look for NonTerminal leaf nodes at or under NonTerminals

        Returns
        -------
        list of SubstitutionSites:
            A list of dataclass objects containing the parent nodes of each
            nonterminal leafnode, its index in its parent, and its label.

        &gt;&gt;&gt; t0 = tree(&#34;([S]([NP]([Det])([N]sentence))([VP]([V]parses)([NP]([Det]the)([N]parser))))&#34;)
        &gt;&gt;&gt; t1 = tree(&#34;([S]([NP]([Det])([N]sentence))([VP]([V]parses)([NP]([Det]the)([N]))))&#34;)
        &gt;&gt;&gt; t2 = tree(&#34;([S]([NP]([Det]the)([N]))([VP]([V]parses)([NP])))&#34;)
        &gt;&gt;&gt; t3 = tree(&#34;([S]([NP]([Det])([N]))([VP]([V])([NP]([Det])([N]))))&#34;)
        &gt;&gt;&gt; t4 = tree(&#34;([S]([NP])([VP]))&#34;)
        &gt;&gt;&gt; t5 = tree(&#34;([S]([NP]([Det]the)([N]sentence))([VP]([V]parses)([NP]([Det]the)([N]parser))))&#34;)
        &gt;&gt;&gt; for t in (t0, t1, t2, t3, t4, t5):
        ...     print([s.site for s in t.get_all_substitition_sites()])
        ...
        [tree(&#34;([Det])&#34;)]
        [tree(&#34;([Det])&#34;), tree(&#34;([N])&#34;)]
        [tree(&#34;([N])&#34;), tree(&#34;([NP])&#34;)]
        [tree(&#34;([Det])&#34;), tree(&#34;([N])&#34;), tree(&#34;([V])&#34;), tree(&#34;([Det])&#34;), tree(&#34;([N])&#34;)]
        [tree(&#34;([NP])&#34;), tree(&#34;([VP])&#34;)]
        []
        &#34;&#34;&#34;
        # Initialise an empty list: try to put substitution sites in it, if
        # there are any, if not return it empty
        sites = []
        # It is assumed that this is not called directly on zero-depth
        # NonTerminals, but more usually on the root node of a tree.
        # Loop over the enumeration of self, as we will need the index of any
        # substitution site found
        for i, c in enumerate(self):
            # Ignore Terminals
            if not hasattr(c, &#39;leaf&#39;):
                # If a child is childess, it&#39;s a substitution site and can be
                # added to the list
                if not hasattr(c, &#39;children&#39;) or not len(c.children):
                    # The object returned, however, is not the
                    # node itself, but a dataclass object containing `self` (the
                    # parent of the substitution site), i, the index of the
                    # substitution site in self, and the label at the
                    # substitution site, as this determines what can be
                    # substituted there. SubstitutionSite also has a method
                    # which takes a subtree as an argument, and performs the
                    # substitution if the label matches
                    sites += [SubstitutionSite(self, i, c.label)]
                # Otherwise, recursively call on the child, and see if there are
                # any substitution sites further down the tree
                sites += c.get_all_substitition_sites()
        return sites

    def __iadd__(self, other):
        &#34;&#34;&#34;Magic method used for operator overloading on `+=`. Either an alias
        for strict_addition (substitution on the leftmost nonterminal leaf node
        only: throws error if Labels unmatched) if the `STRICT_ADDITION` class
        attribute is set to `True`; otherwise an alias for permissive_addition
        (substitution on leftmost Label-matched nonterminal leaf node: only
        throws an error if no matching nonterminal leaf node exists). `self`
        is modified in place, and the added children will belong to the same
        treebank as self.

        Returns
        -------
        Tree
            self

        Raises
        ------
        TypeError
            If the right operand is not a Tree

        &gt;&gt;&gt; dop3 = Treebank(operators = {&#34;&#34;: Operators.CONCAT})
        &gt;&gt;&gt; t0 = tree(&#34;([S]([PN]&#39;I&#39;)([VP]))&#34;, treebank = dop3)
        &gt;&gt;&gt; t1 = tree(&#34;([VP]([V]&#39;pet&#39;)([N]&#39;cats&#39;))&#34;, treebank = dop3)
        &gt;&gt;&gt; t0+=t1
        &gt;&gt;&gt; dop3.print_all_labels()
        ======================
        S:
        ([S]([PN]&#39;I&#39;)([VP]([V]&#39;pet&#39;)([N]&#39;cats&#39;)))
        ======================
        PN:
        ([PN]&#39;I&#39;)
        ======================
        VP:
        ([VP]([V]&#39;pet&#39;)([N]&#39;cats&#39;))
        ======================
        V:
        ([V]&#39;pet&#39;)
        ======================
        N:
        ([N]&#39;cats&#39;)
        ======================
        &#34;&#34;&#34;
        if not isinstance(other, Tree) :
            raise TypeError(
                f&#34;Cannot add a {type(other)} to a NonTerminal; you can &#34; +
                f&#34;only add another Tree.&#34;
            )
        return self.add_strict(other) if NonTerminal.STRICT_ADDITION else self.add_permissive(other)

    def __add__(self, other):
        &#34;&#34;&#34;Magic method used for operator overloading on `+`. Either an alias
        for strict_addition (substitution on the leftmost nonterminal leaf node
        only: throws error if Labels unmatched) if the `STRICT_ADDITION` class
        attribute is set to `True`; otherwise an alias for permissive_addition
        (substitution on leftmost Label-matched nonterminal leaf node: only
        throws an error if no matching nonterminal leaf node exists). `self`
        is copied into a dummy treebank, and the added children will belong to
        the same dummy treebank as `copy(self)`.

        Returns
        -------
        Tree :
            copy(self) with copy(other) substituted at leftmost (if STRICT) or
            leftmost matching (if PERMISSIVE) nonterminal leaf node.

        Raises
        ------
        TypeError
            If the right operand is not a Tree

        &gt;&gt;&gt; dop = Treebank(operators = {&#34;&#34;: Operators.CONCAT})
        &gt;&gt;&gt; t0 = tree(&#34;([S]([PN]&#39;I&#39;)([VP]))&#34;, treebank = dop)
        &gt;&gt;&gt; t1 = tree(&#34;([VP]([V]&#39;pet&#39;)([N]&#39;cats&#39;))&#34;, treebank = dop)
        &gt;&gt;&gt; dop.print_all_labels()
        ======================
        S:
        ([S]([PN]&#39;I&#39;)([VP]))
        ======================
        PN:
        ([PN]&#39;I&#39;)
        ======================
        VP:
        ([VP])
        ([VP]([V]&#39;pet&#39;)([N]&#39;cats&#39;))
        ======================
        V:
        ([V]&#39;pet&#39;)
        ======================
        N:
        ([N]&#39;cats&#39;)
        ======================
        &gt;&gt;&gt; t0 + t1
        tree(&#34;([S]([PN]&#39;I&#39;)([VP]([V]&#39;pet&#39;)([N]&#39;cats&#39;)))&#34;)
        &gt;&gt;&gt; dop.print_all_labels()
        ======================
        S:
        ([S]([PN]&#39;I&#39;)([VP]))
        ([S]([PN]&#39;I&#39;)([VP]([V]&#39;pet&#39;)([N]&#39;cats&#39;)))
        ======================
        PN:
        ([PN]&#39;I&#39;)
        ([PN]&#39;I&#39;)
        ======================
        VP:
        ([VP])
        ([VP]([V]&#39;pet&#39;)([N]&#39;cats&#39;))
        ([VP]([V]&#39;pet&#39;)([N]&#39;cats&#39;))
        ======================
        V:
        ([V]&#39;pet&#39;)
        ([V]&#39;pet&#39;)
        ======================
        N:
        ([N]&#39;cats&#39;)
        ([N]&#39;cats&#39;)
        ======================
        &#34;&#34;&#34;

        # copy self to dummy treebank
        cp = copy(self)
        # use __iadd__ to add `other`
        cp += copy(other)
        return cp

    def add_strict(self, other):
        &#34;&#34;&#34;Adds Trees t1 and t2 by substituting t2 for the leftmost non-terminal
        leaf-node of t1, iff they have the same label. Changes t1 in place, but
        copies children from t2; returns changed t1.

        Parameters
        ----------
        other : Tree
            `Terminal` or `Nonterminal` to be substituted.

        Returns
        -------
        self : `self`, changed in place.

        Raises
        ------
        ValueError
            If there is no nonterminal leafnode in `self`, or the leftmost
            nonterminal leafnode has a label that does not match the root label
            of `other`.

        &gt;&gt;&gt; tb = Treebank()
        &gt;&gt;&gt; t0 = tree(&#34;([S]([NP]([Det])([N]sentence))([VP]([V]parses)([NP]([Det]the)([N]parser))))&#34;, treebank = tb)
        &gt;&gt;&gt; t1 = tree(&#34;([S]([NP]([Det])([N]sentence))([VP]([V]parses)([NP]([Det]the)([N]))))&#34;, treebank = tb)
        &gt;&gt;&gt; t2 = tree(&#34;([S]([NP]([Det]the)([N]))([VP]([V]parses)([NP])))&#34;, treebank = tb)
        &gt;&gt;&gt; t3 = tree(&#34;([S]([NP]([Det])([N]))([VP]([V])([NP]([Det])([N]))))&#34;, treebank = tb)
        &gt;&gt;&gt; t4 = tree(&#34;([S]([NP])([VP]))&#34;, treebank = tb)
        &gt;&gt;&gt; t5 = tree(&#34;([S]([NP]([Det]the)([N]sentence))([VP]([V]parses)([NP]([Det]the)([N]parser))))&#34;, treebank = tb)
        &gt;&gt;&gt; det = tree(&#34;([Det]a)&#34;, treebank = tb)
        &gt;&gt;&gt; n = tree(&#34;([N]pudding)&#34;, treebank = tb)
        &gt;&gt;&gt; np = tree(&#34;([NP]([Det]the)([NN]([Adj]big)([N]banana)))&#34;, treebank = tb)
        &gt;&gt;&gt; v = tree(&#34;([V]badoinks)&#34;, treebank = tb)
        &gt;&gt;&gt; vp = tree(&#34;([VP]([VP]([V]is)([NP]([Det]your)([N]god)))([Adv]now))&#34;, treebank = tb)
        &gt;&gt;&gt; print(copy(t0+det))
        ([S]([NP]([Det]&#39;a&#39;)([N]&#39;sentence&#39;))([VP]([V]&#39;parses&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;parser&#39;))))
        &gt;&gt;&gt; print(copy(t1+det))
        ([S]([NP]([Det]&#39;a&#39;)([N]&#39;sentence&#39;))([VP]([V]&#39;parses&#39;)([NP]([Det]&#39;the&#39;)([N]))))
        &gt;&gt;&gt; print(copy(t1+n)) # doctest: +IGNORE_EXCEPTION_DETAIL
        Traceback (most recent call last):
        ValueError
        : Subtree ([N]pudding) with root label [N] cannot be substituted at index 1 of ([NP]([Det])([N]sentence)) due to a mismatch with substitution site label [Det].
        &gt;&gt;&gt; print(t1+det+n)
        ([S]([NP]([Det]&#39;a&#39;)([N]&#39;sentence&#39;))([VP]([V]&#39;parses&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;pudding&#39;))))
        &gt;&gt;&gt; print(t1+n+det) # doctest: +IGNORE_EXCEPTION_DETAIL
        Traceback (most recent call last):
        ValueError
        : &#34;Subtree ([N]pudding) with root label [N] cannot be substituted at index 0 of ([NP]([Det])([N]sentence)) due to a mismatch with substitution site label [Det].
        &gt;&gt;&gt; print(t2+n)
        ([S]([NP]([Det]&#39;the&#39;)([N]&#39;pudding&#39;))([VP]([V]&#39;parses&#39;)([NP])))
        &gt;&gt;&gt; print(t2+n+np)
        ([S]([NP]([Det]&#39;the&#39;)([N]&#39;pudding&#39;))([VP]([V]&#39;parses&#39;)([NP]([Det]&#39;the&#39;)([NN]([Adj]&#39;big&#39;)([N]&#39;banana&#39;)))))
        &gt;&gt;&gt; print(t3+det+n+v+det+n)
        ([S]([NP]([Det]&#39;a&#39;)([N]&#39;pudding&#39;))([VP]([V]&#39;badoinks&#39;)([NP]([Det]&#39;a&#39;)([N]&#39;pudding&#39;))))
        &gt;&gt;&gt; print(t4+np+vp)
        ([S]([NP]([Det]&#39;the&#39;)([NN]([Adj]&#39;big&#39;)([N]&#39;banana&#39;)))([VP]([VP]([V]&#39;is&#39;)([NP]([Det]&#39;your&#39;)([N]&#39;god&#39;)))([Adv]&#39;now&#39;)))
        &gt;&gt;&gt; print((t4+np+vp)())
        ((&#39;the&#39;, (&#39;big&#39;, &#39;banana&#39;)), ((&#39;is&#39;, (&#39;your&#39;, &#39;god&#39;)), &#39;now&#39;))
        &gt;&gt;&gt; print(t5+n) # doctest: +IGNORE_EXCEPTION_DETAIL
        Traceback (most recent call last):
        ValueError
        : Cannot add Trees t1 and t2; t1 has no non-terminal leaf-nodes
        &#34;&#34;&#34;
        # get leftmost nonterminal leaf node, if it exists. Note, the object
        # returned by get_leftmost_substition_site, however, is not the node
        # itself, but a dataclass object containing `self` (the parent of the
        # substitution site), i, the index of the substitution site in self, and
        # the label at the substitution site, as this determines what can be
        # substituted there.
        ss = self.get_leftmost_substition_site()
        if ss:
            # call method at SubstitutionSite which takes a subtree as an
            # argument, and performs the substitution if the label matches, or
            # raises an exception if it doesn&#39;t
            ss.perform_substitution(other)
            return self
        else:
            # If no substitution site found, raise error
            raise ValueError(
                f&#34;Cannot add Trees t1 and t2; t1 has no non-terminal leaf-nodes&#34;
            )

    def add_permissive(self, other):
        &#34;&#34;&#34;Adds Trees t1 and t2 by substituting t2 for the leftmost non-terminal
        leaf-node of t1, iff they have the same label. Changes t1 in place, but
        copies children from t2; returns changed t1.

        Parameters
        ----------
        other : Tree
            `Terminal` or `Nonterminal` to be substituted.

        Returns
        -------
        NonTerminal: `self`, changed in place.

        Raises
        ------
        ValueError
            If there is no nonterminal leafnode in `self` with a label that
            matches the root label of `other`.

        &gt;&gt;&gt; NonTerminal.STRICT_ADDITION = False
        &gt;&gt;&gt; t0 = tree(&#34;([S]([NP]([Det])([N]sentence))([VP]([V]parses)([NP]([Det]the)([N]parser))))&#34;)
        &gt;&gt;&gt; t1 = tree(&#34;([S]([NP]([Det])([N]sentence))([VP]([V]parses)([NP]([Det]the)([N]))))&#34;)
        &gt;&gt;&gt; t2 = tree(&#34;([S]([NP]([Det]the)([N]))([VP]([V]parses)([NP])))&#34;)
        &gt;&gt;&gt; t3 = tree(&#34;([S]([NP]([Det])([N]))([VP]([V])([NP]([Det])([N]))))&#34;)
        &gt;&gt;&gt; t4 = tree(&#34;([S]([NP])([VP]))&#34;)
        &gt;&gt;&gt; t5 = tree(&#34;([S]([NP]([Det]the)([N]sentence))([VP]([V]parses)([NP]([Det]the)([N]parser))))&#34;)
        &gt;&gt;&gt; det = tree(&#34;([Det]a)&#34;)
        &gt;&gt;&gt; n = tree(&#34;([N]pudding)&#34;)
        &gt;&gt;&gt; np = tree(&#34;([NP]([Det]the)([NN]([Adj]big)([N]banana)))&#34;)
        &gt;&gt;&gt; v = tree(&#34;([V]badoinks)&#34;)
        &gt;&gt;&gt; vp = tree(&#34;([VP]([VP]([V]is)([NP]([Det]your)([N]god)))([Adv]now))&#34;)
        &gt;&gt;&gt; print(copy(t0+det))
        ([S]([NP]([Det]&#39;a&#39;)([N]&#39;sentence&#39;))([VP]([V]&#39;parses&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;parser&#39;))))
        &gt;&gt;&gt; print(copy(t1+det))
        ([S]([NP]([Det]&#39;a&#39;)([N]&#39;sentence&#39;))([VP]([V]&#39;parses&#39;)([NP]([Det]&#39;the&#39;)([N]))))
        &gt;&gt;&gt; print(copy(t1)+copy(n))
        ([S]([NP]([Det])([N]&#39;sentence&#39;))([VP]([V]&#39;parses&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;pudding&#39;))))
        &gt;&gt;&gt; print(copy(t1)+copy(det)+copy(n))
        ([S]([NP]([Det]&#39;a&#39;)([N]&#39;sentence&#39;))([VP]([V]&#39;parses&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;pudding&#39;))))
        &gt;&gt;&gt; print(copy(t1)+copy(n)+copy(det))
        ([S]([NP]([Det]&#39;a&#39;)([N]&#39;sentence&#39;))([VP]([V]&#39;parses&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;pudding&#39;))))
        &gt;&gt;&gt; print(copy(t2)+copy(n))
        ([S]([NP]([Det]&#39;the&#39;)([N]&#39;pudding&#39;))([VP]([V]&#39;parses&#39;)([NP])))
        &gt;&gt;&gt; print(copy(t2)+copy(n)+copy(np))
        ([S]([NP]([Det]&#39;the&#39;)([N]&#39;pudding&#39;))([VP]([V]&#39;parses&#39;)([NP]([Det]&#39;the&#39;)([NN]([Adj]&#39;big&#39;)([N]&#39;banana&#39;)))))
        &gt;&gt;&gt; print(copy(t3)+copy(det)+copy(n)+copy(v)+copy(det)+copy(n))
        ([S]([NP]([Det]&#39;a&#39;)([N]&#39;pudding&#39;))([VP]([V]&#39;badoinks&#39;)([NP]([Det]&#39;a&#39;)([N]&#39;pudding&#39;))))
        &gt;&gt;&gt; print(copy(t4)+copy(np)+copy(vp))
        ([S]([NP]([Det]&#39;the&#39;)([NN]([Adj]&#39;big&#39;)([N]&#39;banana&#39;)))([VP]([VP]([V]&#39;is&#39;)([NP]([Det]&#39;your&#39;)([N]&#39;god&#39;)))([Adv]&#39;now&#39;)))
        &gt;&gt;&gt; print((copy(t4)+copy(np)+copy(vp))())
        ((&#39;the&#39;, (&#39;big&#39;, &#39;banana&#39;)), ((&#39;is&#39;, (&#39;your&#39;, &#39;god&#39;)), &#39;now&#39;))
        &gt;&gt;&gt; print(copy(t5)+copy(n)) # doctest: +IGNORE_EXCEPTION_DETAIL
        Traceback (most recent call last):
        ValueError
        : Cannot add Trees t1 &lt;([S]([NP]([Det]&#39;the&#39;)([N]&#39;sentence&#39;))([VP]([V]&#39;parses&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;parser&#39;))))&gt; and t2 &lt;([N]&#39;pudding&#39;)&gt;; Cannot add Trees t1 &amp; t2; t1 has no nonterminal leafnodes
        &gt;&gt;&gt; print(copy(t0)+tree(&#34;([IDEK]asdfg)&#34;)) # doctest: +IGNORE_EXCEPTION_DETAIL
        Traceback (most recent call last):
        ValueError
        : Cannot add Trees t1 &lt;([S]([NP]([Det])([N]&#39;sentence&#39;))([VP]([V]&#39;parses&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;parser&#39;))))&gt; and t2 &lt;([IDEK]&#39;asdfg&#39;)&gt;; no nonterminal leafnode of t1 matches the root label of t2
        &gt;&gt;&gt; NonTerminal.STRICT_ADDITION = True # Put these back where I found them, or other tests get broken
        &#34;&#34;&#34;
        # Get list of all substitution sites. Note, the objects
        # returned by get_all_substitition_sites, however, are not the nodes
        # themselve, but dataclass objects containing the parent of the
        # substitution site, i, the index of the substitution site in the
        # parent, and the label at the substitution site, as this determines
        # what can be substituted there.
        subsites = self.get_all_substitition_sites()
        # Search the list for the first site matching the label of the subtree
        for ss in subsites:
            # If/when found ...
            if ss.label.classname == other.label.classname:
                # call method at SubstitutionSite which takes a subtree as an
                # argument, and performs the substitution if the label matches.
                # Go on to the next is it doesn&#39;t and...
                ss.perform_substitution(other.copy_out(self.treebank))
                return self
        else:
            # ...if no suitable node is found, raise error:
            raise ValueError(
                f&#34;Cannot add Trees t1 ({self}) and t2 ({other}); &#34; +
                (
                    &#34;no nonterminal leafnode of t1 matches the root label of t2&#34;
                    if subsites else
                    &#34;Cannot add Trees t1 &amp; t2; t1 has no nonterminal leafnodes&#34;
                )
            )

    def __call__(self):
        &#34;&#34;&#34;Magic method that makes NonTerminals Callable: but really it&#39;s just
        calling label (Labels are also callable), which is just calling an
        Operator (also also callable).
        &#34;&#34;&#34;
        return self.label(*[c() for c in self])

    def index_of(self, child: Tree, descendants=False, strict=True) -&gt; (int, Tuple[int]):
        &#34;&#34;&#34;Takes a child node and returns its position in the `NonTerminal`&#39;s
        children, or, if `descendants` is True, it&#39;s descendants. If a `Tree`
        is passed to `child` that is not a child/descendant of `self`, returns
        the empty `tuple` if not `strict`, otherwise raises a `ValueError`.

        Parameters
        ----------
        child : Tree
            The `Tree` we are looking for.
        descendants : bool
            If `True`, search all the descendants of `self`, otherwise, just
            search its children. False by default.
        strict : bool
            If `True`, raises a ValueError if the child is not found: otherwise
            returns `()`.

        Returns
        -------
        int or tuple of ints
            Index. If `descendants` is `False` and `strict` is `True`, returns
            the index of `child` in `self` as an `int`: otherwise, it returns a
            tuple, giving the path from `self` to `child` - which is empty if
            there is no path and `strict` is false.

        Raises
        ------
        ValueError
            If `child` is not found and `strict` is `True`.

        &gt;&gt;&gt; tb = Treebank()
        &gt;&gt;&gt; tree0 = tree(&#34;([S]([NP]([PN]&#39;she&#39;))([VP]([V]&#39;saw&#39;)([S]([NP]([NP]([Det]&#39;the&#39;)([N]&#39;dog&#39;))([PP]([Prep]&#39;with&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;telescope&#39;))))([VP]([V]&#39;observing&#39;)([NP]([PN]&#39;neptune&#39;))))))&#34;, treebank = tb)
        &gt;&gt;&gt; tree1 = tree(&#34;([NP]([Det]&#39;the&#39;)([N]&#39;dog&#39;))&#34;, treebank = tb)
        &gt;&gt;&gt; tree2 = tree0[1,1,0,0]
        &gt;&gt;&gt; for i, t in enumerate(tree0):
        ...     print(i == tree0.index_of(t))
        True
        True
        &gt;&gt;&gt; tree0.index_of(tree2, True, False)
        (1, 1, 0, 0)
        &gt;&gt;&gt; tree0.index_of(tree1, True, False)
        ()
        &gt;&gt;&gt; tree0.index_of(tree2, False, False)
        ()
        &gt;&gt;&gt; tree0.index_of(tree1, False, False)
        ()
        &gt;&gt;&gt; tree0.index_of(tree2, True, True)
        (1, 1, 0, 0)
        &gt;&gt;&gt; tree0.index_of(tree1, True, True) # doctest: +IGNORE_EXCEPTION_DETAIL
        Traceback (most recent call last):
        ValueError: Descendant not found
        &gt;&gt;&gt; tree0.index_of(tree2, False, True) # doctest: +IGNORE_EXCEPTION_DETAIL
        Traceback (most recent call last):
        ValueError: Child not found
        &gt;&gt;&gt; tree0.index_of(tree1, False, True) # doctest: +IGNORE_EXCEPTION_DETAIL
        Traceback (most recent call last):
        ValueError: Child not found
        &#34;&#34;&#34;
        # if we are looking through the entire tree...
        # (note that in this condition all our indices are tuples, indicating a
        # path through the tree.
        if descendants:
            # ...then first, consider the case where the child we&#39;re looking for
            # is the direct child of self. In this case we can avoid code
            # duplication by calling index_of again, but this time taking the
            # !descendants branch. strict is false in the index_of call below,
            # even if the originating call is strict, because if we don&#39;t find
            # child in the children of self, we don&#39;t want to raise an
            # exception until we know it&#39;s not in the grandchildren, great-
            # grandchildren, etc. Because strict is false, we know that if child
            # is found by this call, it will return a tuple, which is what we
            # want
            idx = self.index_of(child, strict=False)
            # idx is either a singleton tuple (child is a child of self) or
            # empty. If singleton...
            if len(idx):
                # ...return it: otherwise...
                return idx
            else:
                # ...we need to look further down the tree. Loop with enumerate
                # because we need the index, in case the child is found. Since
                # we&#39;re using &#39;child&#39; for the Tree we&#39;re looking for, we&#39;ll use
                # &#39;kid&#39; for the actual children of self
                for i, kid in enumerate(self):
                    # Terminals don&#39;t have children, so the search is only
                    # continued if kid is a NonTerminal...
                    if isinstance(kid, NonTerminal):
                        # ...again, a recursive call is wanted here, but this
                        # time with `descendants` set to true: strict is still
                        # set to false in the recursive call: if the originating
                        # call is strict, this loop will complete without
                        # returning, in which case the following code will
                        # either return empty or raise ValueError.
                        idx = kid.index_of(child, True, False)
                        # If idx is not empty, child was found in the
                        # descendants of &#39;kid&#39; at the tuple index at kid[*idx]:
                        # e.g., if (2,0,1) is returned, child == kid[2,0,1], so
                        # ...
                        if len(idx):
                            # given that kid == self[i], child == self[i, *idx],
                            # e.g., if kid = self[1] and child == kid[2,0,1],
                            # then child = self[1,2,0,1]
                            return (i,) + idx
                # If the function call is still running here, no child was found
                # and the proper behaviour is determined by whether `strict`.
                if not strict:
                    return ()
                else:
                    # The error specifies descendant since the function searched
                    # the descendants, not just thie children of self
                    raise ValueError(&#34;Descendant not found&#34;)
        # If not `descendants`, things are simpler. However, note that this is
        # the only branch of the function code that searches directly in the
        # children of a NonTerminal for a child: the descendant-searching
        # branch uses a call to this branch to check for immediate children.
        else:
            # Note that we are looking specifically for a child that is
            # *identical* to `child`, not just equal: however, the list.index()
            # function uses equality. Therefore, we convert `child`...
            ch_id = id(child)
            # ...and the list of children to ids
            k_ids = [id(k) for k in self._children]
            # if child&#39;s id is found in the list of the kids ids...
            if ch_id in k_ids:
                # ...then get the index it was found at...
                idx = k_ids.index(ch_id)
                # ...so return it, either as an int or a singleton tuple.
                return idx if strict else (idx,)
            # Otherwise, the child isn&#39;t found, and the appropriate response is
            # determined by `strict`.
            elif not strict:
                return ()
            else:
                raise ValueError(&#34;Child not found&#34;)

    def delete(self, _top = True):
        &#34;&#34;&#34;Completely removes the NonTerminal from the treebank, along with all
        its descendants. Just to make sure the GC gets what needs to be got, as
        well as deleting all references to the tree in the Labels, it also
        typically (_fill_leaf = False) removes all references held by the nodes
        of the tree to each other. However, the default behaviour of the
        function

        Parameters
        ----------
        _fill_leaf : bool
            If `True`, will cause the parent node of `self` to fill `self&#39;s`
            position in the list of children with an non-terminal leaf node (a
            `NonTerminal` with no children). This is the default value, but is
            set to false when `delete` recursively calls itself on the chidren
            of `self`

        &gt;&gt;&gt; tb = Treebank()
        &gt;&gt;&gt; tb.print_all_labels()
        ======================
        &gt;&gt;&gt; tree0 = tree(&#34;([S]([NP]([PN]&#39;she&#39;))([VP]([V]&#39;saw&#39;)([S]([NP]([NP]([Det]&#39;the&#39;)([N]&#39;dog&#39;))([PP]([Prep]&#39;with&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;telescope&#39;))))([VP]([V]&#39;observing&#39;)([NP]([PN]&#39;neptune&#39;))))))&#34;, treebank = tb)
        &gt;&gt;&gt; tb.print_all_labels()
        ======================
        S:
        ([S]([NP]([NP]([Det]&#39;the&#39;)([N]&#39;dog&#39;))([PP]([Prep]&#39;with&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;telescope&#39;))))([VP]([V]&#39;observing&#39;)([NP]([PN]&#39;neptune&#39;))))
        ([S]([NP]([PN]&#39;she&#39;))([VP]([V]&#39;saw&#39;)([S]([NP]([NP]([Det]&#39;the&#39;)([N]&#39;dog&#39;))([PP]([Prep]&#39;with&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;telescope&#39;))))([VP]([V]&#39;observing&#39;)([NP]([PN]&#39;neptune&#39;))))))
        ======================
        NP:
        ([NP]([PN]&#39;she&#39;))
        ([NP]([Det]&#39;the&#39;)([N]&#39;dog&#39;))
        ([NP]([Det]&#39;the&#39;)([N]&#39;telescope&#39;))
        ([NP]([NP]([Det]&#39;the&#39;)([N]&#39;dog&#39;))([PP]([Prep]&#39;with&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;telescope&#39;))))
        ([NP]([PN]&#39;neptune&#39;))
        ======================
        PN:
        ([PN]&#39;she&#39;)
        ([PN]&#39;neptune&#39;)
        ======================
        VP:
        ([VP]([V]&#39;observing&#39;)([NP]([PN]&#39;neptune&#39;)))
        ([VP]([V]&#39;saw&#39;)([S]([NP]([NP]([Det]&#39;the&#39;)([N]&#39;dog&#39;))([PP]([Prep]&#39;with&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;telescope&#39;))))([VP]([V]&#39;observing&#39;)([NP]([PN]&#39;neptune&#39;)))))
        ======================
        V:
        ([V]&#39;saw&#39;)
        ([V]&#39;observing&#39;)
        ======================
        Det:
        ([Det]&#39;the&#39;)
        ([Det]&#39;the&#39;)
        ======================
        N:
        ([N]&#39;dog&#39;)
        ([N]&#39;telescope&#39;)
        ======================
        PP:
        ([PP]([Prep]&#39;with&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;telescope&#39;)))
        ======================
        Prep:
        ([Prep]&#39;with&#39;)
        ======================
        &gt;&gt;&gt; tree0[0].delete()
        &gt;&gt;&gt; tree0
        tree(&#34;([S]([NP])([VP]([V]&#39;saw&#39;)([S]([NP]([NP]([Det]&#39;the&#39;)([N]&#39;dog&#39;))([PP]([Prep]&#39;with&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;telescope&#39;))))([VP]([V]&#39;observing&#39;)([NP]([PN]&#39;neptune&#39;))))))&#34;)
        &gt;&gt;&gt; tb.print_all_labels()
        ======================
        S:
        ([S]([NP]([NP]([Det]&#39;the&#39;)([N]&#39;dog&#39;))([PP]([Prep]&#39;with&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;telescope&#39;))))([VP]([V]&#39;observing&#39;)([NP]([PN]&#39;neptune&#39;))))
        ([S]([NP])([VP]([V]&#39;saw&#39;)([S]([NP]([NP]([Det]&#39;the&#39;)([N]&#39;dog&#39;))([PP]([Prep]&#39;with&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;telescope&#39;))))([VP]([V]&#39;observing&#39;)([NP]([PN]&#39;neptune&#39;))))))
        ======================
        NP:
        ([NP]([Det]&#39;the&#39;)([N]&#39;dog&#39;))
        ([NP]([Det]&#39;the&#39;)([N]&#39;telescope&#39;))
        ([NP]([NP]([Det]&#39;the&#39;)([N]&#39;dog&#39;))([PP]([Prep]&#39;with&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;telescope&#39;))))
        ([NP]([PN]&#39;neptune&#39;))
        ([NP])
        ======================
        PN:
        ([PN]&#39;neptune&#39;)
        ======================
        VP:
        ([VP]([V]&#39;observing&#39;)([NP]([PN]&#39;neptune&#39;)))
        ([VP]([V]&#39;saw&#39;)([S]([NP]([NP]([Det]&#39;the&#39;)([N]&#39;dog&#39;))([PP]([Prep]&#39;with&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;telescope&#39;))))([VP]([V]&#39;observing&#39;)([NP]([PN]&#39;neptune&#39;)))))
        ======================
        V:
        ([V]&#39;saw&#39;)
        ([V]&#39;observing&#39;)
        ======================
        Det:
        ([Det]&#39;the&#39;)
        ([Det]&#39;the&#39;)
        ======================
        N:
        ([N]&#39;dog&#39;)
        ([N]&#39;telescope&#39;)
        ======================
        PP:
        ([PP]([Prep]&#39;with&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;telescope&#39;)))
        ======================
        Prep:
        ([Prep]&#39;with&#39;)
        ======================
        &gt;&gt;&gt; tree0[1,1,1].delete()
        &gt;&gt;&gt; tree0
        tree(&#34;([S]([NP])([VP]([V]&#39;saw&#39;)([S]([NP]([NP]([Det]&#39;the&#39;)([N]&#39;dog&#39;))([PP]([Prep]&#39;with&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;telescope&#39;))))([VP]))))&#34;)
        &gt;&gt;&gt; tb.print_all_labels()
        ======================
        S:
        ([S]([NP]([NP]([Det]&#39;the&#39;)([N]&#39;dog&#39;))([PP]([Prep]&#39;with&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;telescope&#39;))))([VP]))
        ([S]([NP])([VP]([V]&#39;saw&#39;)([S]([NP]([NP]([Det]&#39;the&#39;)([N]&#39;dog&#39;))([PP]([Prep]&#39;with&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;telescope&#39;))))([VP]))))
        ======================
        NP:
        ([NP]([Det]&#39;the&#39;)([N]&#39;dog&#39;))
        ([NP]([Det]&#39;the&#39;)([N]&#39;telescope&#39;))
        ([NP]([NP]([Det]&#39;the&#39;)([N]&#39;dog&#39;))([PP]([Prep]&#39;with&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;telescope&#39;))))
        ([NP])
        ======================
        PN:
        ======================
        VP:
        ([VP]([V]&#39;saw&#39;)([S]([NP]([NP]([Det]&#39;the&#39;)([N]&#39;dog&#39;))([PP]([Prep]&#39;with&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;telescope&#39;))))([VP])))
        ([VP])
        ======================
        V:
        ([V]&#39;saw&#39;)
        ======================
        Det:
        ([Det]&#39;the&#39;)
        ([Det]&#39;the&#39;)
        ======================
        N:
        ([N]&#39;dog&#39;)
        ([N]&#39;telescope&#39;)
        ======================
        PP:
        ([PP]([Prep]&#39;with&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;telescope&#39;)))
        ======================
        Prep:
        ([Prep]&#39;with&#39;)
        ======================
        &gt;&gt;&gt; tree0[1,1].delete()
        &gt;&gt;&gt; tree0
        tree(&#34;([S]([NP])([VP]([V]&#39;saw&#39;)([S])))&#34;)
        &gt;&gt;&gt; tb.print_all_labels()
        ======================
        S:
        ([S]([NP])([VP]([V]&#39;saw&#39;)([S])))
        ([S])
        ======================
        NP:
        ([NP])
        ======================
        PN:
        ======================
        VP:
        ([VP]([V]&#39;saw&#39;)([S]))
        ======================
        V:
        ([V]&#39;saw&#39;)
        ======================
        Det:
        ======================
        N:
        ======================
        PP:
        ======================
        Prep:
        ======================
        &gt;&gt;&gt; tree0.delete()
        &gt;&gt;&gt; tb.print_all_labels()
        ======================
        S:
        ======================
        NP:
        ======================
        PN:
        ======================
        VP:
        ======================
        V:
        ======================
        Det:
        ======================
        N:
        ======================
        PP:
        ======================
        Prep:
        ======================
        &#34;&#34;&#34;
        for child in self:
            child.delete(False)
        if self.parent:
            if _top:
                self.parent.children[self.parent.index_of(self)] = NonTerminal(
                    self.treebank, self.label
                )
            else:
                self.parent.children[self.parent.index_of(self)] = None
            self.parent = None
        # Note that Label.remove_node() also removes the Label from the node,
        # so no need to do that here
        self.label.remove_node(self)



class Terminal(Tree):
    &#34;&#34;&#34;A general class of terminal node, agnostic as to whether we are using
    Trees to represent strings, functions, music, visual images, motor scores,
    etc.

    TODO: add a metadata attribute

    Attributes:
        _label (Label): Inherited from Tree. Node label determining
            which subtrees can be substituted where. Set and got by the `label`
            @property
        parent (NonTerminal or None): Inherited from Tree. The node
            dirctly above the present in the tree. Each child has a reference to
            its parent, and each parent has references to all its children.
        treebank (Treebank): Every Tree belongs to a Treebank, which defines the
            set of Labels that `Tree`, its parents, and its children can take.
        leaf: The terminal content of this branch of the tree, like a word in
            syntactic parsing, or a constant or variable in Genetic Programming
    &#34;&#34;&#34;
    def __init__(self, treebank, label, leaf):
        try:
            self.leaf = eval(leaf)
        except Exception:
            self.leaf = leaf
        super().__init__(treebank, label)

    def __str__(self):
        &#34;&#34;&#34;Readable string representation of a Terminal. This consists of a pair
        of parentheses containing a representation of the node&#39;s label (label
        name in square brackets), followed by the leaf value, e.g.:

        ([N]&#39;telescope&#39;).
        &#34;&#34;&#34;
        return f&#34;({self.label if hasattr(self, &#39;_label&#39;) else &#39;&#39;}{repr(self.leaf)})&#34;

    def __eq__(self, other):
        &#34;&#34;&#34;Magic method to operator-overload `==` and `!=`

        Returns
        -------
            bool: True if class, label and leaf are the same, else False.

        &gt;&gt;&gt; # The tests on NonTerminal.__eq__ also test this
        &gt;&gt;&gt; tb = Treebank()
        &gt;&gt;&gt; tree(&#39;([N]bridge)&#39;, tb) == tree(&#39;([N]bridge)&#39;, tb)
        True
        &gt;&gt;&gt; tree(&#39;([N]bridge)&#39;, tb) == tree(&#39;([V]bridge)&#39;, tb)
        False
        &gt;&gt;&gt; tree(&#39;([N]bridge)&#39;, tb) == tree(&#39;([N]man)&#39;, tb)
        False
        &gt;&gt;&gt; tree(&#39;([N]bridge)&#39;) == tree(&#39;([N]bridge)&#39;)
        False
        &gt;&gt;&gt; tree(&#39;([N]bridge)&#39;) == tree(&#39;([V]bridge)&#39;)
        False
        &gt;&gt;&gt; tree(&#39;([N]bridge)&#39;) == tree(&#39;([N]man)&#39;)
        False
        &#34;&#34;&#34;
        return self.__class__ == other.__class__ and self.leaf == other.leaf and self.label == other.label

    def __len__(self) -&gt; int:
        &#34;&#34;&#34;All nodes have a length: Terminals have length 1, while NonTerminals
        have a length equal to the number of children

        Returns
        -------
        int:  1
        &#34;&#34;&#34;
        return 1

    def depth(self) -&gt; int:
        &#34;&#34;&#34;All terminals have depth 1&#34;&#34;&#34;
        return 1

    def width(self) -&gt; int:
        &#34;&#34;&#34;All terminals have width 1&#34;&#34;&#34;
        return 1

    def size(self) -&gt; int:
        &#34;&#34;&#34;All terminals have size 1&#34;&#34;&#34;
        return 1

    def to_LaTeX(self, top = True):
        &#34;&#34;&#34;Converts trees to LaTeX expressions using the `qtree` package.
        Remember to include `\\usepackage{qtree}` in the document header. For
        Terminals, the format is `[.$label $leaf]`. The label expression is
        provided by a similar function in Label.

        Parameters
        ----------:
            top (bool): qtrees expressions must be prefixed with `\\Tree`, but
                this only applies to the whole tree: you don&#39;t put it in front
                of every node. However, this function uses recursive calls to
                make the LaTeX of child nodes, so making sure only the top node
                has this prefix takes a bit of extra logic. If the node has no
                parent, the `\\Tree` prefix is automaticaly applied, otherwise
                by default it isn&#39;t. However, if LaTeX is wanted for a partial
                tree, `top` may be set to `True`

        &gt;&gt;&gt; t = test_trees()
        &gt;&gt;&gt; for x in t:
        ...     print(x.to_LaTeX())
        ...
        \Tree [.N poo ]
        \Tree [.S [.N sentence ] [.VP [.V parses ] [.N parser ] ] ]
        \Tree [.S [.N sentence ] [.VP [.V parses ] [.N parser ] ] ]
        \Tree [.S [.N sentence ] [.VP [.V parses ] [.N parser ] ] ]
        \Tree [.S [.NP [.Det the ] [.N sentence ] ] [.VP [.V parses ] [.NP [.Det the ] [.N parser ] ] ] ]
        \Tree [.S [.N word ] [.VP [.V parses ] [.N parser ] ] ]
        \Tree [.S [.N sentence ] [.VP [.V parses ] [.V parser ] ] ]
        \Tree [.S [.X x ] [.Y y ] ]
        &#34;&#34;&#34;
        # prepends \Tree if needed
        LaTeX = r&#34;\Tree &#34; if not (hasattr(self, &#39;parent&#39;) and self.parent) or top else &#34;&#34;
        # LaTeX of the Label is . followed by the label name
        LaTeX += f&#34;[{self.label.to_LaTeX()} {self.leaf} ] &#34;
        return LaTeX.strip() if top else LaTeX

    def __call__(self):
        &#34;&#34;&#34;All nodes are callable, but on Terminals it just returns the leaf.

        Returns
        -------
            The leaf value.

        &gt;&gt;&gt; t = test_trees()[0]
        &gt;&gt;&gt; print(t())
        poo
        &#34;&#34;&#34;
        return self.leaf

    def __getitem__(self, position):
        &#34;&#34;&#34;Returns leaf if index is 0, throws error otherwise.

        Returns
        -------
            leaf

        Raises:
            IndexError: If index is not 0

        &gt;&gt;&gt; t = tree(&#34;([N]&#39;sentence&#39;)&#34;)
        &gt;&gt;&gt; print(t[0])
        sentence
        &gt;&gt;&gt; print(t[0, 0]) # doctest: +IGNORE_EXCEPTION_DETAIL
        Traceback (most recent call last):
        IndexError: Index out of range. The Tree:
        ([N]&#39;sentence&#39;)
        was indexed with:
        (0, 0)
        but does not have a subtree at:
        (0, 0)
        Terminals do not have child nodes.
        &#34;&#34;&#34;
        # If the index at this point is anything other than 0 or (0,), it points
        # to a node that isn&#39;t there, and a custom IndexError should be raised.
        # This shows the string representation of the tree where the error was
        # raised (`self`), the erroneous index (`position`), the index up to and
        # incuding its first erroneous element (`wrong`), and a message
        # indicating what went wrong (`err`)
        if not position in (0, (0,)):
            if type(position) == int:
                position = (position, )
            if position[0] == 0:
                wrong = position[:2]
                err = &#34;Terminals do not have child nodes.&#34;
            else:
                wrong = position[:1]
                err = &#34;Terminals can only be indexed with 0, which returns the terminal content.&#34;
            raise IndexError(
                f&#34;Index out of range. The Tree:\n{self}\nwas indexed with:\n&#34; +
                f&#34;{position}\nbut does not have a subtree at:\n{wrong}\n{err}&#34;
            )
        return self.leaf


    def copy_out(self, treebank = None):
        &#34;&#34;&#34;Generates a deep copy of a Terminal: same Labels, and  same content:
        but a distinct object in memory from the original. If `treebank` is a
        Treebank, The new Terminal will be copied into `treebank`. If `treebank`
        is `None`, a dummy treebank will be created, and the Terminal will be
        copied into that.

        Returns
        -------
            Terminal: copy of original tree

        &#34;&#34;&#34;
        # If `treebank` is not provided...
        if not treebank:
            # ...make a dummy treebank for the copied Terminal to live in
            treebank = Treebank()
        # return the copy Terminal, with `treebank=treebank`
        return Terminal(
            treebank,
            self.label if treebank == self.treebank else treebank.get_label(self.label.classname),
            copy(self.leaf)
        )

    def delete(self, _top = True):
        if _top:
            self.parent.children[self.parent.index_of(self)] = NonTerminal(
                self.treebank, self.label
            )
        else:
            self.parent.children[self.parent.index_of(self)] = None
        self.label.remove_node(self)


class TreeIter:
    &#34;&#34;&#34;Iterator that iterates over a Tree. This was needed because I wanted to
    include informative IndexError messages in the custom __getitem__ methods in
    Tree, but the default __iter__ used catching IndexErrors to tell when the
    iteraton was done, which meant that the code used to generate these
    informative error messages was running a *lot*, mostly to no purpose, and
    sometimes
    &#34;&#34;&#34;
    def __init__(self, tree):
        self._pos = 0
        self._tree = tree

    def __iter__(self):
        return self

    def __next__(self):
        if self._pos &lt; len(self._tree):
            self._pos += 1
            return self._tree[self._pos - 1]
        else:
            raise StopIteration


class Label:
    &#34;&#34;&#34;Node label used for all subclasses of Tree. Each category of
    tree-node has exactly one Label created, and all nodes of that category
    have the same Label object set to their `label` property.

    Attributes:
        treebank (Treebank): Every tree belongs to a Treebank, which defines the
            set of Labels that `Tree`, its parents, and its children can take.
        is_default (Label): A treebank may have a _default_label, to be supplied
            if a request for a label is made without specifying which Label is
            needed. If `self` is the _default_label, then `is_default == True`
        nodes (list of Trees): List of all the tree nodes labelled with
            this particular `Label`.
        classname (str): Unique name for the `Label`.
        operator (function): the function from Operators which is called when
            Label.__call__(*children_of_nonterminal) is called

    Raises:
        AttributeError: If creation of a `Label` is attempted with a non-unique
            classname.
    &#34;&#34;&#34;

    def __init__(self, treebank, classname = None, operator = Operators.ID):
        # create a list to store all Trees with this Label
        self.nodes = []
        self._classname = classname
        self.operator = operator
        treebank.add_label(self)
        self.is_default = False

    @property
    def classname(self):
        &#34;&#34;&#34;(str) The name of the Label, and of the corresponding category of
        trees.
        &#34;&#34;&#34;
        return self._classname

    @classname.setter
    def classname(self, name):
        &#34;&#34;&#34;Setter for classname. Checks that the name is a `str`, as this is the
        only valid type for classnames, and checks that the name is unique.

        Note:
            This will need to be updated for Genetic Programming: I want to use
                `type` objects here)

        Raises:
            TypeError: if `name` is not a `str`
        &#34;&#34;&#34;
        if name is None:
            name = &#34;&#34;
        if type(name) is not str: # Type check
            raise TypeError(&#34;Names of Labels can only be strings&#34;)
        # OK, fine I guess.
        self._classname = name

    def __call__(self, *args):
        &#34;&#34;&#34;Magic method that allows a Label to be called like a function.
        This defines the function that is called to combine the values of its
        children to get the value of the node. However, since sometimes more
        than one Label may have the same functionality (e.g., space-separated
        concatenation in DOP), it is best to use dependency-injection with
        Operators. Thus, call simply calls the supplied operator, with the
        supplied *args.
        &#34;&#34;&#34;
        return self.operator(*args)

    def add_node(self, node: Tree):
        &#34;&#34;&#34;When a label is added to a node, the node is also added to the label:
        a Label is fundamentally a substitutability class. Each label object has
        a list `self.nodes` in which all nodes in the class are stored.

        To guarantee consistency, `add_node` checks that `node` is indeed a
        subclass of `Tree`, and that it does not belong to any other
        `Label`, and that it has a reference to the present `Label`.

        Parameters
        ----------
        node : Tree
            The node to be added.

        Raise
        -----
        TypeError
            If the node is not actually a Tree

        &gt;&gt;&gt; tb = Treebank()
        &gt;&gt;&gt; tb.default_label = Label(tb, &#39;*&#39;)
        &gt;&gt;&gt; adv = Label(tb, &#39;Adv&#39;)
        &gt;&gt;&gt; print(adv)
        [Adv]
        &gt;&gt;&gt; sad_tree = tree(&#34;(&#39;alone&#39;)&#34;, tb)
        &gt;&gt;&gt; print(sad_tree)
        (&#39;alone&#39;)
        &gt;&gt;&gt; adv.add_node(sad_tree)
        &gt;&gt;&gt; adv.print_terminal_subtrees()
        ([Adv]&#39;alone&#39;)
        &#34;&#34;&#34;
        # Check the type first
        if issubclass(type(node), Tree):
            # If it already has `self` as its label, all that is needed is to
            # add it to self.nodes. This is the expected behaviour, as the
            # setter for label in Tree is what calls add_node, and is
            # itself called in Tree.__init__, which its inheritors
            # typically extend rather than override; but just in case...
            if node.label is not self:
                # If the node.label just isn&#39;t set, all that is needed to set
                # it: bu just in case...
                if node.label is not None:
                    # If it already has a different Label, then make sure it
                    # is removed from the other Label&#39;s node list
                    node.label.remove_node(node)
                # So now we&#39;re sure we can set the label param on node
                # TODO: There is no `self.nodes.append(node)` on this branch,
                # because this is done in the label setter in Tree.
                # I tried having the `self.nodes.append(node)` below under
                # a separate conditional checking that `node` isn&#39;t already in
                # `self.nodes`, which does remove the dependency but makes
                # everything super slow. Is there a better way of removing this
                # dependency
                node.label = self
            # And now we&#39;re sure it&#39;s OK to add the node to the node list,
            # unless node&#39;s label.setter already did this
            else:
                self.nodes.append(node)
        else:
            # But if the type check fails...
            raise TypeError(
                &#34;When you add a node to a Label, it must be a Tree. You added&#34; +
                f&#34; a {type(node):s}, and that makes me sad.&#34; # womp womp
            )

    def remove_node(self, node: Tree):
        &#34;&#34;&#34;A bit of tear-down is needed if a Label is removed from a node: the
        Label is a substitutability class, and maintains a record of all the
        trees in the class, so the node must also be removed from the `Label`&#39;s
        list.

        Parameters
        ----------
        node : Tree
            The node to be removed

        &gt;&gt;&gt; tb = Treebank()
        &gt;&gt;&gt; tb.default_label = Label(tb, &#39;*&#39;)
        &gt;&gt;&gt; t_1 = tree(&#34;([S]([NP]([Det]&#39;the&#39;)([N]&#39;sentence&#39;))([VP]([V]&#39;parses&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;parser&#39;))))&#34;, tb)
        &gt;&gt;&gt; t_2 = tree(&#34;([S]([N]&#39;word&#39;)([VP]([V]&#39;parses&#39;)([N]&#39;parser&#39;)))&#34;, tb)
        &gt;&gt;&gt; t_3 = tree(&#34;([S]([N]&#39;sentence&#39;)([VP]([V]&#39;parses&#39;)([V]&#39;parser&#39;)))&#34;, tb)
        &gt;&gt;&gt; t_1[0,0].label.remove_node(t_1[0,0])
        &gt;&gt;&gt; print(t_1)
        ([S]([NP](&#39;the&#39;)([N]&#39;sentence&#39;))([VP]([V]&#39;parses&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;parser&#39;))))
        &gt;&gt;&gt; tb.default_label.add_node(t_1[0,0])
        &gt;&gt;&gt; print(t_1)
        ([S]([NP](&#39;the&#39;)([N]&#39;sentence&#39;))([VP]([V]&#39;parses&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;parser&#39;))))
        &#34;&#34;&#34;
        # Using this loop to remove the node from nodes, because __eq__ is
        # overriden in Tree, and it is important that the node that is removed
        # is the exact node passed to the method, not just the first one to have
        # the same value.
        for i, t in enumerate(self.nodes):
            if t is node:
                del self.nodes[i]
                break
        node.label = None

    def __str__(self):
        &#34;&#34;&#34;String representation of Label for use with __str__ methods in Tree
        classes. Returns &#34;&#34; for unlabelled nodes.

        Returns
        -------
            str: classname in square brackets, or empty string for
                _default_label

        &gt;&gt;&gt; # No doctests here - the tests for __str__ in the `Tree` classes
        &gt;&gt;&gt; # implicitly also test this
        &#34;&#34;&#34;
        return &#34;&#34; if self.classname == &#34;&#34; or self.is_default else f&#34;[{self.classname}]&#34;

    # Get rid of __repr__s for now, they are just causing trouble
    def __repr__(self):
        return f&#34;Label(&#39;{self.classname}&#39;)&#34;

    def __contains__(self, tree):
        return bool(sum([id(tree)==id(t) for t in self.nodes]))

    def to_LaTeX(self):
        &#34;&#34;&#34;String representation of Label for use with to_LaTeX methods in Tree
        classes. Returns &#34;&#34; for unlabelled nodes.

        Returns
        -------
            str: classname preceded by `.`, or empty string for _default_label

        &gt;&gt;&gt; # No doctests here - the tests for to_LaTeX in the `Tree` classes
        &gt;&gt;&gt; # implicitly also test this
        &#34;&#34;&#34;
        return &#34;&#34; if self.is_default else f&#34;.{self.classname}&#34;

    def print_terminal_subtrees(self, is_LaTeX=False):
        &#34;&#34;&#34;A helper function for testing and inspection, mostly. Prints out all
        trees with the current `Label`, either using `__str__` or `to_LaTeX`.

        Parameters
        ----------
        is_LaTeX : bool
            If true, print the trees in LaTeX `qtree` format: otherwise just use
            the standard str format

        &gt;&gt;&gt; tb = Treebank()
        &gt;&gt;&gt; tb.default_label = Label(tb, &#39;*&#39;)
        &gt;&gt;&gt; x_tree = tree(&#34;((&#39;list&#39;)((&#39;of&#39;)((&#39;all&#39;)((&#39;the&#39;)((&#39;fucks&#39;)(&#39;I&#39;)(&#39;give&#39;))))))&#34;, tb)
        &gt;&gt;&gt; print(x_tree)
        ((&#39;list&#39;)((&#39;of&#39;)((&#39;all&#39;)((&#39;the&#39;)((&#39;fucks&#39;)(&#39;I&#39;)(&#39;give&#39;))))))
        &gt;&gt;&gt; tb.default_label.print_terminal_subtrees()
        (&#39;list&#39;)
        (&#39;of&#39;)
        (&#39;all&#39;)
        (&#39;the&#39;)
        (&#39;fucks&#39;)
        (&#39;I&#39;)
        (&#39;give&#39;)
        ((&#39;fucks&#39;)(&#39;I&#39;)(&#39;give&#39;))
        ((&#39;the&#39;)((&#39;fucks&#39;)(&#39;I&#39;)(&#39;give&#39;)))
        ((&#39;all&#39;)((&#39;the&#39;)((&#39;fucks&#39;)(&#39;I&#39;)(&#39;give&#39;))))
        ((&#39;of&#39;)((&#39;all&#39;)((&#39;the&#39;)((&#39;fucks&#39;)(&#39;I&#39;)(&#39;give&#39;)))))
        ((&#39;list&#39;)((&#39;of&#39;)((&#39;all&#39;)((&#39;the&#39;)((&#39;fucks&#39;)(&#39;I&#39;)(&#39;give&#39;))))))
        &gt;&gt;&gt; tb.default_label.print_terminal_subtrees(is_LaTeX = True)
        \Tree [ list ]
        \Tree [ of ]
        \Tree [ all ]
        \Tree [ the ]
        \Tree [ fucks ]
        \Tree [ I ]
        \Tree [ give ]
        \Tree [ [ fucks ] [ I ] [ give ] ]
        \Tree [ [ the ] [ [ fucks ] [ I ] [ give ] ] ]
        \Tree [ [ all ] [ [ the ] [ [ fucks ] [ I ] [ give ] ] ] ]
        \Tree [ [ of ] [ [ all ] [ [ the ] [ [ fucks ] [ I ] [ give ] ] ] ] ]
        \Tree [ [ list ] [ [ of ] [ [ all ] [ [ the ] [ [ fucks ] [ I ] [ give ] ] ] ] ] ]
        &#34;&#34;&#34;
        if is_LaTeX: # Resolve the conditional first, so it is only done once
            for tree in self.nodes:
                # LaTeXise all the things!
                print(tree.to_LaTeX())
        else:
            for tree in self.nodes:
                # Or just print them!
                print(tree)

    @property
    def roots(self) -&gt; List[Tree]:
        &#34;&#34;&#34;(list[Tree]): all nodes in `self` that have no parent node

        &gt;&gt;&gt; tb = Treebank()
        &gt;&gt;&gt; tb.default_label = Label(tb, &#39;X&#39;)
        &gt;&gt;&gt; t1 = tree(&#34;([S]([NP](&#39;the&#39;)([N]&#39;sentence&#39;))([VP]([V]&#39;parses&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;parser&#39;))))&#34;, tb)
        &gt;&gt;&gt; t2 = tree(&#34;([S]([N]&#39;word&#39;)([VP]([V]&#39;parses&#39;)([N]&#39;parser&#39;)))&#34;, tb)
        &gt;&gt;&gt; t3 = tree(&#34;([S]([N]&#39;sentence&#39;)([VP]([V]&#39;parses&#39;)([V]&#39;parser&#39;)))&#34;, tb)
        &gt;&gt;&gt; x_tree = tree(&#34;((&#39;list&#39;)((&#39;of&#39;)((&#39;all&#39;)((&#39;the&#39;)((&#39;fucks&#39;)(&#39;I&#39;)(&#39;give&#39;))))))&#34;, tb)
        &gt;&gt;&gt; hippo = tree(&#34;([NP]([Det]&#39;a&#39;)([AdjP]([Adj]&#39;giant&#39;)([N]&#39;hippopotamus&#39;)))&#34;, tb)
        &gt;&gt;&gt; sad = tree(&#34;([Adv]&#39;alone&#39;)&#34;, tb)
        &gt;&gt;&gt; print(tb.classnames[&#39;V&#39;].roots)
        []
        &gt;&gt;&gt; def print_roots(name):
        ...     for root in tb.classnames[name].roots:
        ...         print(root)
        ...
        &gt;&gt;&gt; print_roots(&#39;S&#39;)
        ([S]([NP](&#39;the&#39;)([N]&#39;sentence&#39;))([VP]([V]&#39;parses&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;parser&#39;))))
        ([S]([N]&#39;word&#39;)([VP]([V]&#39;parses&#39;)([N]&#39;parser&#39;)))
        ([S]([N]&#39;sentence&#39;)([VP]([V]&#39;parses&#39;)([V]&#39;parser&#39;)))
        &gt;&gt;&gt; print_roots(&#39;X&#39;)
        ((&#39;list&#39;)((&#39;of&#39;)((&#39;all&#39;)((&#39;the&#39;)((&#39;fucks&#39;)(&#39;I&#39;)(&#39;give&#39;))))))
        &gt;&gt;&gt; print_roots(&#39;Adv&#39;)
        ([Adv]&#39;alone&#39;)
        &gt;&gt;&gt; print_roots(&#39;NP&#39;)
        ([NP]([Det]&#39;a&#39;)([AdjP]([Adj]&#39;giant&#39;)([N]&#39;hippopotamus&#39;)))
        &#34;&#34;&#34;
        return list(filter(lambda node: not bool(node.parent), self.nodes))


@runtime_checkable
class TreebankIO(Protocol):
    # def __init__(self, tree_type: type):
    #     ...

    def load(cls, filename: str, clear: bool):
        ...

    def save(cls, filename: str):
        ...


@runtime_checkable
class JSONiser(Protocol):
    # def __init__(self, tree_type: type):
    #     ...

    def load(cls, filename: str, clear: bool):
        ...

    def save(cls, filename: str):
        ...

    def to_json(self) -&gt; json:
        ...

    def from_json(self, json_treebank: str, clear: bool):
        ...


class JSONIO:
    &#34;&#34;&#34;Translates between a Treebank and JSON: saves and loads a Treebank
        to/from a JSON file.

    Attributes:
        tree_type (type): Specify the tree-system you wish to use (e.g. Tree,
        DOP, GP, etc) by passing in the class name here: this ensures that the
        IO writes from the correct Label-class, and when reading generates trees
        using the correct Terminal and NonTerminal classes. Use the class
        itself, not an instance of the class. DEPRECATED

    Raises:
        TypeError: If the value passes is not of type `type` (that is, not a
            class), or if the type is not Tree or one of its subclasses.
    &#34;&#34;&#34;
    # def __init__(self, tree_type: type):
    #     if isinstance(tree_type, &#39;type&#39;) and issubclass(tree_type, Tree):
    #         self._tree_type = tree_type
    #     elif isinstance(tree_type, &#39;Tree&#39;):
    #         er = &#34;tree_type should be the class Tree or one of its subclasses: &#34;
    #         raise TypeError(er + &#34;not an instance of the class.&#34;)
    #     elif isinstance(tree_type, &#39;type&#39;):
    #         raise TypeError(er + f&#34;not a {tree_type}&#34;)
    #     else:
    #         raise TypeError(er + f&#34;not a {type(tree_type)}&#34;)

    # NOE
    # @property
    # def _all_roots(treebank):
    #     &#34;&#34;&#34;An alias for `get_all_root_nodes` in `Treebank`&#34;&#34;&#34;
    #     return self._tree_type.L().get_all_root_nodes()

    def to_json(self, treebank) -&gt; json:
        &#34;&#34;&#34;Gets a JSON representation of the entire treebank: that is, for each
        Label, JSON representations of all root nodes with that Label.

        Returns
        -------
            (str): string containing the json expression for the entire treebank
        &#34;&#34;&#34;
        # Label.get_all_root_nodes returns a dict with lists of Trees as values,
        # but that&#39;s not quite what we want; the dict and list comprehensions
        # here convert the trees to strings.
        return json.dumps(
            {k: [str(t) for t in v] for k, v in treebank._all_roots if v},
            indent = 4
        )

    def save(self, filename: str):
        &#34;&#34;&#34;Saves the JSON representation of the treebank to a file.

        Parameters
        ----------
            filename (str): name of file to be saved
        &#34;&#34;&#34;
        with open(filename, &#39;w&#39;) as outfile:
            json.dump(self.to_json(), outfile)

    def from_json(self, json_treebank: str):
        &#34;&#34;&#34;Populates an entire treebank from JSON

        Parameters
        ----------
            json (str):
            clear (bool): Ensures there are no other trees already loaded before
                proceeding, if True.
        &#34;&#34;&#34;
        if clear:
            self._L.clear()
        trees_dict = json.loads(json_treebank)
        for val in trees_dict.values():
            for tree in val:
                self._tree_type.tree(tree)

    def load(self, filename: str, clear: bool):
        &#34;&#34;&#34;Reads in a JSON file for an entire treebank, populates the treebank.
        &#34;&#34;&#34;
        with open(filename) as json_treebank:
            self.from_json(json_treebank.read(), clear, tree_type)

# TESTME
@dataclass
class SubstitutionSite:
    &#34;&#34;&#34;Dataclass containing all the information about a nonterminal leaf node
    needed to do a node substitution at that location: its label (so we can
    check the substitution is valid), its parent, and its index in its parent
    (so the substitution can be performed).

    Attributes:
        parent (NonTerminal): parent node of the nonterminal leaf node, needed
            to perform substitution.
        index (int): index of nonterminal leaf node, needed to perform
            substitution.
        label (Label): Label of nonterminal leaf node, needed to ensure
            substitution if valid.
    &#34;&#34;&#34;
    parent: NonTerminal
    index: int
    label: Label

    def perform_substitution(self, subtree: Tree):
        &#34;&#34;&#34;Takes a subtree and, if it has the same node label, swaps it for the
        nonterminal leafnode at the substitution site

        Parameters
        ----------
            subtree (Tree): The subtree to be swapped into place.
        Raises:
            ValueError: if the Label at the substitution site does not match the
                root label of the subtree to be substituted
        &#34;&#34;&#34;
        # If substitution is legit...
        if subtree.label == self.label:
            # ...then, do it. ...
            self.parent[self.index] = subtree
            subtree.parent = self.parent
        else:
            # ... otherwise, noep.
            raise ValueError(
                f&#34;Subtree {subtree} with root label {subtree.label} &#34; +
                f&#34;(id = {id(subtree.label)}) cannot be substituted at index &#34; +
                f&#34;{self.index} of {self.parent} due to a mismatch with &#34; +
                f&#34;substitution site label {self.label} (id = {id(self.label)}).&#34;
            )

    @property
    def site(self) -&gt; NonTerminal:
        &#34;&#34;&#34;(NonTerminal) The actual nonterminal leafnode.&#34;&#34;&#34;
        return self.parent[self.index]

&#34;&#34;&#34;Remove all IO shit from this
IOs take Treebanks as args when writing
IOs take Treebanks as optional args when reading, if none provided, create new
Treebank: if one is provided, add new trees to old, no need for `clear` arg
&#34;&#34;&#34;
class Treebank:
    &#34;&#34;&#34;
    A `Treebank` represents a collection of trees as a collection of
    node-labels (class `Label`), each of which defines a substitutability class
    within the set of `Terminals` and `NonTerminals` in the collection of trees,
    such that all `Terminals` and `NonTerminals` belong to exactly one `Label`
    of the `Treebank`. Implementing an algorithm such as DOP or GP takes only
    one `Treebank`, but using DOP or GP to define agents within a multi-agent
    algorithm, multiple `Treebanks` will be needed - one for each agent. In this
    case, each `Treebank` will be complete and self-contained, with no
    `Treebank` having access to any other `Treebank`&#39;s `Labels` or trees.

    Attributes:
        classnames (dict): `dict` mapping from each label name to the unique
            `Label` with that name.
        operators (dict of functions): A dictionary of functions which define
            how the content of a node is generated by combining the contents of
            its children. For DOP and other NLP uses, a single default operator
            is recommended: `Operators.CONCAT`, which concatenates child strings
            with spaces as separators - with the result that the content of a
            tree that parses a sentence is the original sentence. However, it is
            possible to have a variety of Operators accessed with string keys -
            useful for Genetic Programming.
        _default_label (Label): Default label to be supplied if a request for a
            label is made without specifying which Label is needed.
    &#34;&#34;&#34;

    def __init__(self, operators = {&#34;&#34;: Operators.ID}):
        self.classnames = {}
        self.operators = operators
        self._default_label = None

    def get_label(self, classname = None):
        &#34;&#34;&#34;Returns the `Label` with the provided `classname`, retrieving the
        existing label if one exists, creating a new one otherwise. If
        `classname == None`, returns the `_default_label` if one exists, raises
        an `AttributeError` otherwise.

        Parameters
        ----------
            classname (str): Name for a category of Trees

        Raises:
            AttributeError: If `classname == None` and no `_default_label` is
                set.

        &gt;&gt;&gt; tb = Treebank()
        &gt;&gt;&gt; tb.get_label() # doctest: +IGNORE_EXCEPTION_DETAIL
        Traceback (most recent call last):
        AttributeError: You cannot create unlabelled trees unless Label._default_label has been set
        &gt;&gt;&gt; print(tb.classnames)
        {}
        &gt;&gt;&gt; x = tb.get_label(&#39;X&#39;)
        &gt;&gt;&gt; print(tb.classnames)
        {&#39;X&#39;: Label(&#39;X&#39;)}
        &gt;&gt;&gt; x1 = tb.get_label(&#39;X&#39;)
        &gt;&gt;&gt; print(tb.classnames)
        {&#39;X&#39;: Label(&#39;X&#39;)}
        &gt;&gt;&gt; y = tb.get_label(&#39;Y&#39;)
        &gt;&gt;&gt; print(tb.classnames)
        {&#39;X&#39;: Label(&#39;X&#39;), &#39;Y&#39;: Label(&#39;Y&#39;)}
        &gt;&gt;&gt; id(x) == id(x1)
        True
        &gt;&gt;&gt; id(x) != id(y)
        True
        &#34;&#34;&#34;
        # If classname is None...
        if not classname:
            # ... return the default label, if it exists...
            if isinstance(self.default_label, Label):
                return self.default_label
            else:
                # ... if it doesn&#39;t, that&#39;s bad.
                raise AttributeError(
                    &#34;You cannot create unlabelled trees unless &#34; +
                    &#34;a default_label has been set&#34;
                )
        # If classname is *not* None, &amp; a label with that name already exists...
        elif classname in self.classnames:
            # ...get that label from the dict and return it...
            return self.classnames[classname]
        else:
            #...or, if it doesn&#39;t, then create it. The Label.__init__ method
            # will ensure the new Label goes in the dict.
            return Label(
                self,
                classname,
                self.operators[classname] if classname in self.operators else self.operators[&#34;&#34;]
            )

    @property
    def default_label(self):
        &#34;&#34;&#34;Class attribute used where unlabelled nodes are needed - i.e. all
        nodes belong to the same category. Since the Label class is used to
        manage node substitution, a single default Label object is still
        needed for this.&#34;&#34;&#34;
        return self._default_label

    @default_label.setter
    def default_label(self, deflab):
        &#34;&#34;&#34;Setter for _default_label. Checks that the `Label` is indeed a
        `Label`.

        Parameters
        ----------
            deflab (Label): the default label.

        Raises:
            TypeError: If the `deflab` isn&#39;t a Label
        &#34;&#34;&#34;
        if type(deflab) is Label:
            if self._default_label:
                self._default_label.is_default = False
            deflab.is_default = True
            self._default_label = deflab
        else:
            raise TypeError(
                f&#34;The default Label needs to be a {Label}, not a {type(deflab)}&#34;
            )

    def add_label(self, label):
        &#34;&#34;&#34;Adds a new Label to the Treebank.

        Parameters
        ----------
            label (Label): the new Label.

        Raises:
            AttributeError: If `label` isn&#39;t a Label.
        &#34;&#34;&#34;
        if label.classname in self.classnames:
            raise AttributeError(
                f&#34;The Treebank already contains a label named {label.classname}&#34;
            )
        else:
            self.classnames[label.classname] = label

    def make_class_name(self): #
        &#34;&#34;&#34;Makes up a classname if one is needed but none is supplied.

        Returns
        -------
            name (str): String of the form &#39;L&#39; + an int equal to the number of
                already existing labels
        &#34;&#34;&#34;
        name = &#34;L&#34; + str(len(self.classnames)) #If there are 5 labels
        #already, this will be L5, for example
        return name

    def print_all_labels(self, is_LaTeX=False):
        &#34;&#34;&#34;A helper class for testing and inspection, mostly. Prints out all
        trees from all `Labels` in the `Treebank`, either using `__str__` or
        `to_LaTeX`.

        Parameters
        ----------
            is_LaTeX (bool): if true, print the trees in LaTeX `qtree` format:
                otherwise just use the standard str format
        &#34;&#34;&#34;
        # make this a variable to ensure consistency
        spacer = &#34;======================&#34;
        print(spacer)
        # Label.classnames is a dict, so the loop can get the names *and* Labels
        for name, label in self.classnames.items():
            print(f&#34;{name}:&#34;)
            label.print_terminal_subtrees(is_LaTeX)
            print(spacer)

    def clear(self):
        &#34;&#34;&#34;Erases the entire treebank. Handle with care.&#34;&#34;&#34;
        self.classnames = {}

    def get_all_root_nodes(self) -&gt; Dict[str, List[Tree]]:
        &#34;&#34;&#34;Generates a dict containing all the Label names as keys, and the list
        of all treenodes in that label which have no parent node. Labels
        containing no root nodes
        &#34;&#34;&#34;
        return {name: val.roots for name, val in self.classnames.items()}

    def tree(self, treestr: str):
        &#34;&#34;&#34;
        Creates a Tree from a string. The string format is for a NonTerminal is:

            `&#39;([$label]{$node_data}($child)*)&#39;`

        ...where `$label` is the name of the `Label` on the node, `{$node_data}`
        an optional `dict` containing metadata for the node, and ($child) is
        the Tree.__str__() representation of each of the node&#39;s children. The
        string format for a Terminal is:

            `&#39;([$label]{$node_data}$leaf)&#39;`

        ... where `$leaf` is the the terminal content of the node â€” for
        instance, a string literal representing a word in a parse of a sentence.
        If `$leaf` cannot be evaluated with `eval`, it is cast to a `str`.

        Parameters
        ----------
            treestr (str): A treestring in the same format that Tree.__str__()
                outputs

        Returns
        -------
            Tree: A Tree, such that treestr == tree(treestr).__str__()

        Raises:
            AttributeError: if `treestr` is malformed.

        &gt;&gt;&gt; tb = Treebank()
        &gt;&gt;&gt; t = tb.tree(&#34;([S]([N]sentence)([VP]([V]parses)([N]parser)))&#34;)
        &gt;&gt;&gt; print(t)
        ([S]([N]&#39;sentence&#39;)([VP]([V]&#39;parses&#39;)([N]&#39;parser&#39;)))
        &gt;&gt;&gt; tt = eval(repr(t))
        &gt;&gt;&gt; print(tt)
        ([S]([N]&#39;sentence&#39;)([VP]([V]&#39;parses&#39;)([N]&#39;parser&#39;)))
        &gt;&gt;&gt; print(tt())
        (&#39;sentence&#39;, (&#39;parses&#39;, &#39;parser&#39;))
        &gt;&gt;&gt; #Label.print_all_labels()
        &#34;&#34;&#34;
        # if the treestr is valid, this regex will have exactly one match
        m = re.match(
            r&#34;\((\[(?P&lt;label&gt;[^\]]*)\])?(?P&lt;node_data&gt;\{.*\})?((?P&lt;children&gt;\(.*\)*?)|(?P&lt;leaf&gt;.*))\)&#34;,
            treestr
        )
        if m:
            # Capture groups from the regex:
            # Node label. Can be empty if default_label is set in Label (TESTME)
            lab = m.group(&#34;label&#34;)
            # Metadata on node. Placeholder, for now.
            node_data = m.group(&#34;node_data&#34;)
            # children are other nodes under the present node; leaf is element
            # of the content the tree ranges over - typically a str for DOP, a
            # float for GP
            children = m.group(&#34;children&#34;)
            leaf = m.group(&#34;leaf&#34;)
        else:
            # Throw an error of treestr not valid
            raise AttributeError(f&#34;Malformed treestring: {treestr}&#34;)
        # gets new Label if no existing label has name `lab`, else gets existing
        # Label: or, if `lab` does not exist, gets the default Label
        the_label = self.get_label(lab) if lab else self.get_label()
        # Empty list for children. If no children or leaf, this is a
        # non-terminal leaf node
        child_list = []
        if leaf:
            # Awkward alias for the relevant Terminal subclass __init__ method
            # to create new Terminal with leaf
            return Terminal(self, the_label, leaf)
        # If there are children, make trees for them
        elif children:
            # Parens demarcate a child: However, a child may also have children,
            # so to distinguish between brackets of the immediate child and
            # further downstream children, we must tack the bracketing level:
            # `level` keeps track of the number of unclosed brackets. If the
            # level drops to zero, the last paren character is the end of the
            # last child substring, and the next paren character, if there is
            # one, is the start of the next
            level = 0
            # Iterate through the chracters in the `children` substring,
            # add them to `current_child`
            current_child = &#34;&#34;
            for char in children:
                current_child += char
                # add parens to the count when `&#39;(&#39;` is found
                if char == &#34;(&#34;:
                    level += 1
                # remove parens from the count when `&#39;)&#39;` is found
                elif char == &#34;)&#34;:
                    level -= 1
                    # and the next paren character, if there is one, is the
                    # start of the next
                    if level == 0:
                        # If the level drops to zero, the last paren character
                        # is the end of the last child substring...
                        child_list.append(self.tree(current_child))
                        # ...and the next paren character, if there is one, is
                        # the start of the next
                        current_child = &#34;&#34;
                    elif level &lt; 0:
                        # raise an exception if parens are unbalanced
                        raise AttributeError(
                            f&#34;Your treestr&#39;s representations of its children \
                            is malformed: {children}&#34;
                        )
                elif level == 0:
                    raise AttributeError(
                        f&#34;Your treestr, contains stray text between the string \
                        representations of its children: {children}&#34;
                    )
            if level != 0:
                raise AttributeError(
                    f&#34;Your treestr&#39;s representations of its children has \
                    unbalanced parentheses: {children}&#34;
                )
        # alias for the constructor of the relevant NonTerminal: creates and
        # returns new NonTerminal with the right label and children
        return NonTerminal(self, the_label, *child_list)

def test_trees(tb = None):
    &#34;&#34;&#34;
    Creates a collection of sample trees for testing.

    &gt;&gt;&gt; t = test_trees()
    &gt;&gt;&gt; for tx in t:
    ...     print(tx)
    ...
    ([N]&#39;poo&#39;)
    ([S]([N]&#39;sentence&#39;)([VP]([V]&#39;parses&#39;)([N]&#39;parser&#39;)))
    ([S]([N]&#39;sentence&#39;)([VP]([V]&#39;parses&#39;)([N]&#39;parser&#39;)))
    ([S]([N]&#39;sentence&#39;)([VP]([V]&#39;parses&#39;)([N]&#39;parser&#39;)))
    ([S]([NP]([Det]&#39;the&#39;)([N]&#39;sentence&#39;))([VP]([V]&#39;parses&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;parser&#39;))))
    ([S]([N]&#39;word&#39;)([VP]([V]&#39;parses&#39;)([N]&#39;parser&#39;)))
    ([S]([N]&#39;sentence&#39;)([VP]([V]&#39;parses&#39;)([V]&#39;parser&#39;)))
    ([S]([X]&#39;x&#39;)([Y]&#39;y&#39;))
    &#34;&#34;&#34;
    tb = tb if tb else Treebank()
    t = [None]*8
    t[0] = Terminal(tb, tb.get_label(&#34;N&#34;), &#34;poo&#34;)
    t[1] = tree(
        &#34;([S]([N]sentence)([VP]([V]parses)([N]parser)))&#34;,
        tb
    )
    t[2] = NonTerminal(
        tb, &#34;S&#34;, Terminal(
            tb, &#34;N&#34;, &#34;sentence&#34;
        ), NonTerminal(
            tb, &#34;VP&#34;, Terminal(
                tb, &#34;V&#34;, &#34;parses&#34;
            ), Terminal(
                tb, &#34;N&#34;, &#34;parser&#34;
            )
        )
    )
    t[3] = NonTerminal(
        tb, &#34;S&#34;, Terminal(
            tb, &#34;N&#34;, &#34;sentence&#34;
        ), NonTerminal(
            tb, &#34;VP&#34;, Terminal(
                tb, &#34;V&#34;, &#34;parses&#34;
            ), Terminal(
                tb, &#34;N&#34;, &#34;parser&#34;
            )
        )
    )
    t[4] = tree(
        &#34;([S]([NP]([Det]the)([N]sentence))([VP]([V]parses)([NP]([Det]the)([N]parser))))&#34;,
        treebank = tb
    )
    t[5] = tree(&#34;([S]([N]word)([VP]([V]parses)([N]parser)))&#34;, treebank = tb)
    t[6] = tree(&#34;([S]([N]sentence)([VP]([V]parses)([V]parser)))&#34;, treebank = tb)
    t[7] = tree(&#34;([S]([X]x)([Y]y))&#34;, treebank = tb)
    return t

def test_fragments(tb = None):
    tb = tb if tb else Treebank()
    return [
        tree(&#34;([S]([NP]([Det]the)([N]cat))([VP]))&#34;, treebank = tb),
        tree(&#34;([S]([NP]([Det]the)([N]cat))([VP]([V]ate)([NP])))&#34;, treebank = tb),
        tree(&#34;([NP])&#34;, treebank = tb)
    ]

def tree(treestr: str, treebank = None, operator = Operators.ID):
    if not treebank:
        treebank = Treebank(operators = {&#34;&#34;: operator})
    return treebank.tree(treestr)

def main():
    import doctest
    doctest.testmod()
    # t = tree(&#34;([S]([X]x)([Y]y))&#34;)
    # print(t())


if __name__ == &#39;__main__&#39;:
    main()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="trees.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main():
    import doctest
    doctest.testmod()
    # t = tree(&#34;([S]([X]x)([Y]y))&#34;)
    # print(t())</code></pre>
</details>
</dd>
<dt id="trees.test_fragments"><code class="name flex">
<span>def <span class="ident">test_fragments</span></span>(<span>tb=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_fragments(tb = None):
    tb = tb if tb else Treebank()
    return [
        tree(&#34;([S]([NP]([Det]the)([N]cat))([VP]))&#34;, treebank = tb),
        tree(&#34;([S]([NP]([Det]the)([N]cat))([VP]([V]ate)([NP])))&#34;, treebank = tb),
        tree(&#34;([NP])&#34;, treebank = tb)
    ]</code></pre>
</details>
</dd>
<dt id="trees.test_trees"><code class="name flex">
<span>def <span class="ident">test_trees</span></span>(<span>tb=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a collection of sample trees for testing.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; t = test_trees()
&gt;&gt;&gt; for tx in t:
...     print(tx)
...
([N]'poo')
([S]([N]'sentence')([VP]([V]'parses')([N]'parser')))
([S]([N]'sentence')([VP]([V]'parses')([N]'parser')))
([S]([N]'sentence')([VP]([V]'parses')([N]'parser')))
([S]([NP]([Det]'the')([N]'sentence'))([VP]([V]'parses')([NP]([Det]'the')([N]'parser'))))
([S]([N]'word')([VP]([V]'parses')([N]'parser')))
([S]([N]'sentence')([VP]([V]'parses')([V]'parser')))
([S]([X]'x')([Y]'y'))
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_trees(tb = None):
    &#34;&#34;&#34;
    Creates a collection of sample trees for testing.

    &gt;&gt;&gt; t = test_trees()
    &gt;&gt;&gt; for tx in t:
    ...     print(tx)
    ...
    ([N]&#39;poo&#39;)
    ([S]([N]&#39;sentence&#39;)([VP]([V]&#39;parses&#39;)([N]&#39;parser&#39;)))
    ([S]([N]&#39;sentence&#39;)([VP]([V]&#39;parses&#39;)([N]&#39;parser&#39;)))
    ([S]([N]&#39;sentence&#39;)([VP]([V]&#39;parses&#39;)([N]&#39;parser&#39;)))
    ([S]([NP]([Det]&#39;the&#39;)([N]&#39;sentence&#39;))([VP]([V]&#39;parses&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;parser&#39;))))
    ([S]([N]&#39;word&#39;)([VP]([V]&#39;parses&#39;)([N]&#39;parser&#39;)))
    ([S]([N]&#39;sentence&#39;)([VP]([V]&#39;parses&#39;)([V]&#39;parser&#39;)))
    ([S]([X]&#39;x&#39;)([Y]&#39;y&#39;))
    &#34;&#34;&#34;
    tb = tb if tb else Treebank()
    t = [None]*8
    t[0] = Terminal(tb, tb.get_label(&#34;N&#34;), &#34;poo&#34;)
    t[1] = tree(
        &#34;([S]([N]sentence)([VP]([V]parses)([N]parser)))&#34;,
        tb
    )
    t[2] = NonTerminal(
        tb, &#34;S&#34;, Terminal(
            tb, &#34;N&#34;, &#34;sentence&#34;
        ), NonTerminal(
            tb, &#34;VP&#34;, Terminal(
                tb, &#34;V&#34;, &#34;parses&#34;
            ), Terminal(
                tb, &#34;N&#34;, &#34;parser&#34;
            )
        )
    )
    t[3] = NonTerminal(
        tb, &#34;S&#34;, Terminal(
            tb, &#34;N&#34;, &#34;sentence&#34;
        ), NonTerminal(
            tb, &#34;VP&#34;, Terminal(
                tb, &#34;V&#34;, &#34;parses&#34;
            ), Terminal(
                tb, &#34;N&#34;, &#34;parser&#34;
            )
        )
    )
    t[4] = tree(
        &#34;([S]([NP]([Det]the)([N]sentence))([VP]([V]parses)([NP]([Det]the)([N]parser))))&#34;,
        treebank = tb
    )
    t[5] = tree(&#34;([S]([N]word)([VP]([V]parses)([N]parser)))&#34;, treebank = tb)
    t[6] = tree(&#34;([S]([N]sentence)([VP]([V]parses)([V]parser)))&#34;, treebank = tb)
    t[7] = tree(&#34;([S]([X]x)([Y]y))&#34;, treebank = tb)
    return t</code></pre>
</details>
</dd>
<dt id="trees.tree"><code class="name flex">
<span>def <span class="ident">tree</span></span>(<span>treestr:Â str, treebank=None, operator=&lt;function Operators.ID&gt;)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tree(treestr: str, treebank = None, operator = Operators.ID):
    if not treebank:
        treebank = Treebank(operators = {&#34;&#34;: operator})
    return treebank.tree(treestr)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="trees.JSONIO"><code class="flex name class">
<span>class <span class="ident">JSONIO</span></span>
</code></dt>
<dd>
<div class="desc"><p>Translates between a Treebank and JSON: saves and loads a Treebank
to/from a JSON file.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>tree_type</code></strong> :&ensp;<code>type</code></dt>
<dd>Specify the tree-system you wish to use (e.g. Tree,</dd>
</dl>
<p>DOP, GP, etc) by passing in the class name here: this ensures that the
IO writes from the correct Label-class, and when reading generates trees
using the correct Terminal and NonTerminal classes. Use the class
itself, not an instance of the class. DEPRECATED</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>If the value passes is not of type <code>type</code> (that is, not a
class), or if the type is not Tree or one of its subclasses.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class JSONIO:
    &#34;&#34;&#34;Translates between a Treebank and JSON: saves and loads a Treebank
        to/from a JSON file.

    Attributes:
        tree_type (type): Specify the tree-system you wish to use (e.g. Tree,
        DOP, GP, etc) by passing in the class name here: this ensures that the
        IO writes from the correct Label-class, and when reading generates trees
        using the correct Terminal and NonTerminal classes. Use the class
        itself, not an instance of the class. DEPRECATED

    Raises:
        TypeError: If the value passes is not of type `type` (that is, not a
            class), or if the type is not Tree or one of its subclasses.
    &#34;&#34;&#34;
    # def __init__(self, tree_type: type):
    #     if isinstance(tree_type, &#39;type&#39;) and issubclass(tree_type, Tree):
    #         self._tree_type = tree_type
    #     elif isinstance(tree_type, &#39;Tree&#39;):
    #         er = &#34;tree_type should be the class Tree or one of its subclasses: &#34;
    #         raise TypeError(er + &#34;not an instance of the class.&#34;)
    #     elif isinstance(tree_type, &#39;type&#39;):
    #         raise TypeError(er + f&#34;not a {tree_type}&#34;)
    #     else:
    #         raise TypeError(er + f&#34;not a {type(tree_type)}&#34;)

    # NOE
    # @property
    # def _all_roots(treebank):
    #     &#34;&#34;&#34;An alias for `get_all_root_nodes` in `Treebank`&#34;&#34;&#34;
    #     return self._tree_type.L().get_all_root_nodes()

    def to_json(self, treebank) -&gt; json:
        &#34;&#34;&#34;Gets a JSON representation of the entire treebank: that is, for each
        Label, JSON representations of all root nodes with that Label.

        Returns
        -------
            (str): string containing the json expression for the entire treebank
        &#34;&#34;&#34;
        # Label.get_all_root_nodes returns a dict with lists of Trees as values,
        # but that&#39;s not quite what we want; the dict and list comprehensions
        # here convert the trees to strings.
        return json.dumps(
            {k: [str(t) for t in v] for k, v in treebank._all_roots if v},
            indent = 4
        )

    def save(self, filename: str):
        &#34;&#34;&#34;Saves the JSON representation of the treebank to a file.

        Parameters
        ----------
            filename (str): name of file to be saved
        &#34;&#34;&#34;
        with open(filename, &#39;w&#39;) as outfile:
            json.dump(self.to_json(), outfile)

    def from_json(self, json_treebank: str):
        &#34;&#34;&#34;Populates an entire treebank from JSON

        Parameters
        ----------
            json (str):
            clear (bool): Ensures there are no other trees already loaded before
                proceeding, if True.
        &#34;&#34;&#34;
        if clear:
            self._L.clear()
        trees_dict = json.loads(json_treebank)
        for val in trees_dict.values():
            for tree in val:
                self._tree_type.tree(tree)

    def load(self, filename: str, clear: bool):
        &#34;&#34;&#34;Reads in a JSON file for an entire treebank, populates the treebank.
        &#34;&#34;&#34;
        with open(filename) as json_treebank:
            self.from_json(json_treebank.read(), clear, tree_type)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="trees.JSONIO.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>self, json_treebank:Â str)</span>
</code></dt>
<dd>
<div class="desc"><p>Populates an entire treebank from JSON</p>
<h2 id="parameters">Parameters</h2>
<pre><code>json (str):
clear (bool): Ensures there are no other trees already loaded before
    proceeding, if True.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_json(self, json_treebank: str):
    &#34;&#34;&#34;Populates an entire treebank from JSON

    Parameters
    ----------
        json (str):
        clear (bool): Ensures there are no other trees already loaded before
            proceeding, if True.
    &#34;&#34;&#34;
    if clear:
        self._L.clear()
    trees_dict = json.loads(json_treebank)
    for val in trees_dict.values():
        for tree in val:
            self._tree_type.tree(tree)</code></pre>
</details>
</dd>
<dt id="trees.JSONIO.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>self, filename:Â str, clear:Â bool)</span>
</code></dt>
<dd>
<div class="desc"><p>Reads in a JSON file for an entire treebank, populates the treebank.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load(self, filename: str, clear: bool):
    &#34;&#34;&#34;Reads in a JSON file for an entire treebank, populates the treebank.
    &#34;&#34;&#34;
    with open(filename) as json_treebank:
        self.from_json(json_treebank.read(), clear, tree_type)</code></pre>
</details>
</dd>
<dt id="trees.JSONIO.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, filename:Â str)</span>
</code></dt>
<dd>
<div class="desc"><p>Saves the JSON representation of the treebank to a file.</p>
<h2 id="parameters">Parameters</h2>
<pre><code>filename (str): name of file to be saved
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(self, filename: str):
    &#34;&#34;&#34;Saves the JSON representation of the treebank to a file.

    Parameters
    ----------
        filename (str): name of file to be saved
    &#34;&#34;&#34;
    with open(filename, &#39;w&#39;) as outfile:
        json.dump(self.to_json(), outfile)</code></pre>
</details>
</dd>
<dt id="trees.JSONIO.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self, treebank) â€‘>Â <moduleÂ 'json'Â fromÂ '/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/json/__init__.py'></span>
</code></dt>
<dd>
<div class="desc"><p>Gets a JSON representation of the entire treebank: that is, for each
Label, JSON representations of all root nodes with that Label.</p>
<h2 id="returns">Returns</h2>
<pre><code>(str): string containing the json expression for the entire treebank
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self, treebank) -&gt; json:
    &#34;&#34;&#34;Gets a JSON representation of the entire treebank: that is, for each
    Label, JSON representations of all root nodes with that Label.

    Returns
    -------
        (str): string containing the json expression for the entire treebank
    &#34;&#34;&#34;
    # Label.get_all_root_nodes returns a dict with lists of Trees as values,
    # but that&#39;s not quite what we want; the dict and list comprehensions
    # here convert the trees to strings.
    return json.dumps(
        {k: [str(t) for t in v] for k, v in treebank._all_roots if v},
        indent = 4
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="trees.JSONiser"><code class="flex name class">
<span>class <span class="ident">JSONiser</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for protocol classes.</p>
<p>Protocol classes are defined as::</p>
<pre><code>class Proto(Protocol):
    def meth(self) -&gt; int:
        ...
</code></pre>
<p>Such classes are primarily used with static type checkers that recognize
structural subtyping (static duck-typing), for example::</p>
<pre><code>class C:
    def meth(self) -&gt; int:
        return 0

def func(x: Proto) -&gt; int:
    return x.meth()

func(C())  # Passes static type check
</code></pre>
<p>See PEP 544 for details. Protocol classes decorated with
@typing.runtime_checkable act as simple-minded runtime protocols that check
only the presence of given attributes, ignoring their type signatures.
Protocol classes can be generic, they are defined as::</p>
<pre><code>class GenProto(Protocol[T]):
    def meth(self) -&gt; T:
        ...
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@runtime_checkable
class JSONiser(Protocol):
    # def __init__(self, tree_type: type):
    #     ...

    def load(cls, filename: str, clear: bool):
        ...

    def save(cls, filename: str):
        ...

    def to_json(self) -&gt; json:
        ...

    def from_json(self, json_treebank: str, clear: bool):
        ...</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="trees.JSONiser.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>self, json_treebank:Â str, clear:Â bool)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_json(self, json_treebank: str, clear: bool):
    ...</code></pre>
</details>
</dd>
<dt id="trees.JSONiser.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>cls, filename:Â str, clear:Â bool)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load(cls, filename: str, clear: bool):
    ...</code></pre>
</details>
</dd>
<dt id="trees.JSONiser.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>cls, filename:Â str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(cls, filename: str):
    ...</code></pre>
</details>
</dd>
<dt id="trees.JSONiser.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) â€‘>Â <moduleÂ 'json'Â fromÂ '/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/json/__init__.py'></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; json:
    ...</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="trees.Label"><code class="flex name class">
<span>class <span class="ident">Label</span></span>
<span>(</span><span>treebank, classname=None, operator=&lt;function Operators.ID&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Node label used for all subclasses of Tree. Each category of
tree-node has exactly one Label created, and all nodes of that category
have the same Label object set to their <code>label</code> property.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>treebank</code></strong> :&ensp;<code><a title="trees.Treebank" href="#trees.Treebank">Treebank</a></code></dt>
<dd>Every tree belongs to a Treebank, which defines the
set of Labels that <code><a title="trees.Tree" href="#trees.Tree">Tree</a></code>, its parents, and its children can take.</dd>
<dt><strong><code>is_default</code></strong> :&ensp;<code><a title="trees.Label" href="#trees.Label">Label</a></code></dt>
<dd>A treebank may have a _default_label, to be supplied
if a request for a label is made without specifying which Label is
needed. If <code>self</code> is the _default_label, then <code>is_default == True</code></dd>
<dt><strong><code>nodes</code></strong> :&ensp;<code>list</code> of <code>Trees</code></dt>
<dd>List of all the tree nodes labelled with
this particular <code><a title="trees.Label" href="#trees.Label">Label</a></code>.</dd>
<dt><strong><code>classname</code></strong> :&ensp;<code>str</code></dt>
<dd>Unique name for the <code><a title="trees.Label" href="#trees.Label">Label</a></code>.</dd>
<dt><strong><code>operator</code></strong> :&ensp;<code>function</code></dt>
<dd>the function from Operators which is called when
Label.<strong>call</strong>(*children_of_nonterminal) is called</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>AttributeError</code></dt>
<dd>If creation of a <code><a title="trees.Label" href="#trees.Label">Label</a></code> is attempted with a non-unique
classname.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Label:
    &#34;&#34;&#34;Node label used for all subclasses of Tree. Each category of
    tree-node has exactly one Label created, and all nodes of that category
    have the same Label object set to their `label` property.

    Attributes:
        treebank (Treebank): Every tree belongs to a Treebank, which defines the
            set of Labels that `Tree`, its parents, and its children can take.
        is_default (Label): A treebank may have a _default_label, to be supplied
            if a request for a label is made without specifying which Label is
            needed. If `self` is the _default_label, then `is_default == True`
        nodes (list of Trees): List of all the tree nodes labelled with
            this particular `Label`.
        classname (str): Unique name for the `Label`.
        operator (function): the function from Operators which is called when
            Label.__call__(*children_of_nonterminal) is called

    Raises:
        AttributeError: If creation of a `Label` is attempted with a non-unique
            classname.
    &#34;&#34;&#34;

    def __init__(self, treebank, classname = None, operator = Operators.ID):
        # create a list to store all Trees with this Label
        self.nodes = []
        self._classname = classname
        self.operator = operator
        treebank.add_label(self)
        self.is_default = False

    @property
    def classname(self):
        &#34;&#34;&#34;(str) The name of the Label, and of the corresponding category of
        trees.
        &#34;&#34;&#34;
        return self._classname

    @classname.setter
    def classname(self, name):
        &#34;&#34;&#34;Setter for classname. Checks that the name is a `str`, as this is the
        only valid type for classnames, and checks that the name is unique.

        Note:
            This will need to be updated for Genetic Programming: I want to use
                `type` objects here)

        Raises:
            TypeError: if `name` is not a `str`
        &#34;&#34;&#34;
        if name is None:
            name = &#34;&#34;
        if type(name) is not str: # Type check
            raise TypeError(&#34;Names of Labels can only be strings&#34;)
        # OK, fine I guess.
        self._classname = name

    def __call__(self, *args):
        &#34;&#34;&#34;Magic method that allows a Label to be called like a function.
        This defines the function that is called to combine the values of its
        children to get the value of the node. However, since sometimes more
        than one Label may have the same functionality (e.g., space-separated
        concatenation in DOP), it is best to use dependency-injection with
        Operators. Thus, call simply calls the supplied operator, with the
        supplied *args.
        &#34;&#34;&#34;
        return self.operator(*args)

    def add_node(self, node: Tree):
        &#34;&#34;&#34;When a label is added to a node, the node is also added to the label:
        a Label is fundamentally a substitutability class. Each label object has
        a list `self.nodes` in which all nodes in the class are stored.

        To guarantee consistency, `add_node` checks that `node` is indeed a
        subclass of `Tree`, and that it does not belong to any other
        `Label`, and that it has a reference to the present `Label`.

        Parameters
        ----------
        node : Tree
            The node to be added.

        Raise
        -----
        TypeError
            If the node is not actually a Tree

        &gt;&gt;&gt; tb = Treebank()
        &gt;&gt;&gt; tb.default_label = Label(tb, &#39;*&#39;)
        &gt;&gt;&gt; adv = Label(tb, &#39;Adv&#39;)
        &gt;&gt;&gt; print(adv)
        [Adv]
        &gt;&gt;&gt; sad_tree = tree(&#34;(&#39;alone&#39;)&#34;, tb)
        &gt;&gt;&gt; print(sad_tree)
        (&#39;alone&#39;)
        &gt;&gt;&gt; adv.add_node(sad_tree)
        &gt;&gt;&gt; adv.print_terminal_subtrees()
        ([Adv]&#39;alone&#39;)
        &#34;&#34;&#34;
        # Check the type first
        if issubclass(type(node), Tree):
            # If it already has `self` as its label, all that is needed is to
            # add it to self.nodes. This is the expected behaviour, as the
            # setter for label in Tree is what calls add_node, and is
            # itself called in Tree.__init__, which its inheritors
            # typically extend rather than override; but just in case...
            if node.label is not self:
                # If the node.label just isn&#39;t set, all that is needed to set
                # it: bu just in case...
                if node.label is not None:
                    # If it already has a different Label, then make sure it
                    # is removed from the other Label&#39;s node list
                    node.label.remove_node(node)
                # So now we&#39;re sure we can set the label param on node
                # TODO: There is no `self.nodes.append(node)` on this branch,
                # because this is done in the label setter in Tree.
                # I tried having the `self.nodes.append(node)` below under
                # a separate conditional checking that `node` isn&#39;t already in
                # `self.nodes`, which does remove the dependency but makes
                # everything super slow. Is there a better way of removing this
                # dependency
                node.label = self
            # And now we&#39;re sure it&#39;s OK to add the node to the node list,
            # unless node&#39;s label.setter already did this
            else:
                self.nodes.append(node)
        else:
            # But if the type check fails...
            raise TypeError(
                &#34;When you add a node to a Label, it must be a Tree. You added&#34; +
                f&#34; a {type(node):s}, and that makes me sad.&#34; # womp womp
            )

    def remove_node(self, node: Tree):
        &#34;&#34;&#34;A bit of tear-down is needed if a Label is removed from a node: the
        Label is a substitutability class, and maintains a record of all the
        trees in the class, so the node must also be removed from the `Label`&#39;s
        list.

        Parameters
        ----------
        node : Tree
            The node to be removed

        &gt;&gt;&gt; tb = Treebank()
        &gt;&gt;&gt; tb.default_label = Label(tb, &#39;*&#39;)
        &gt;&gt;&gt; t_1 = tree(&#34;([S]([NP]([Det]&#39;the&#39;)([N]&#39;sentence&#39;))([VP]([V]&#39;parses&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;parser&#39;))))&#34;, tb)
        &gt;&gt;&gt; t_2 = tree(&#34;([S]([N]&#39;word&#39;)([VP]([V]&#39;parses&#39;)([N]&#39;parser&#39;)))&#34;, tb)
        &gt;&gt;&gt; t_3 = tree(&#34;([S]([N]&#39;sentence&#39;)([VP]([V]&#39;parses&#39;)([V]&#39;parser&#39;)))&#34;, tb)
        &gt;&gt;&gt; t_1[0,0].label.remove_node(t_1[0,0])
        &gt;&gt;&gt; print(t_1)
        ([S]([NP](&#39;the&#39;)([N]&#39;sentence&#39;))([VP]([V]&#39;parses&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;parser&#39;))))
        &gt;&gt;&gt; tb.default_label.add_node(t_1[0,0])
        &gt;&gt;&gt; print(t_1)
        ([S]([NP](&#39;the&#39;)([N]&#39;sentence&#39;))([VP]([V]&#39;parses&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;parser&#39;))))
        &#34;&#34;&#34;
        # Using this loop to remove the node from nodes, because __eq__ is
        # overriden in Tree, and it is important that the node that is removed
        # is the exact node passed to the method, not just the first one to have
        # the same value.
        for i, t in enumerate(self.nodes):
            if t is node:
                del self.nodes[i]
                break
        node.label = None

    def __str__(self):
        &#34;&#34;&#34;String representation of Label for use with __str__ methods in Tree
        classes. Returns &#34;&#34; for unlabelled nodes.

        Returns
        -------
            str: classname in square brackets, or empty string for
                _default_label

        &gt;&gt;&gt; # No doctests here - the tests for __str__ in the `Tree` classes
        &gt;&gt;&gt; # implicitly also test this
        &#34;&#34;&#34;
        return &#34;&#34; if self.classname == &#34;&#34; or self.is_default else f&#34;[{self.classname}]&#34;

    # Get rid of __repr__s for now, they are just causing trouble
    def __repr__(self):
        return f&#34;Label(&#39;{self.classname}&#39;)&#34;

    def __contains__(self, tree):
        return bool(sum([id(tree)==id(t) for t in self.nodes]))

    def to_LaTeX(self):
        &#34;&#34;&#34;String representation of Label for use with to_LaTeX methods in Tree
        classes. Returns &#34;&#34; for unlabelled nodes.

        Returns
        -------
            str: classname preceded by `.`, or empty string for _default_label

        &gt;&gt;&gt; # No doctests here - the tests for to_LaTeX in the `Tree` classes
        &gt;&gt;&gt; # implicitly also test this
        &#34;&#34;&#34;
        return &#34;&#34; if self.is_default else f&#34;.{self.classname}&#34;

    def print_terminal_subtrees(self, is_LaTeX=False):
        &#34;&#34;&#34;A helper function for testing and inspection, mostly. Prints out all
        trees with the current `Label`, either using `__str__` or `to_LaTeX`.

        Parameters
        ----------
        is_LaTeX : bool
            If true, print the trees in LaTeX `qtree` format: otherwise just use
            the standard str format

        &gt;&gt;&gt; tb = Treebank()
        &gt;&gt;&gt; tb.default_label = Label(tb, &#39;*&#39;)
        &gt;&gt;&gt; x_tree = tree(&#34;((&#39;list&#39;)((&#39;of&#39;)((&#39;all&#39;)((&#39;the&#39;)((&#39;fucks&#39;)(&#39;I&#39;)(&#39;give&#39;))))))&#34;, tb)
        &gt;&gt;&gt; print(x_tree)
        ((&#39;list&#39;)((&#39;of&#39;)((&#39;all&#39;)((&#39;the&#39;)((&#39;fucks&#39;)(&#39;I&#39;)(&#39;give&#39;))))))
        &gt;&gt;&gt; tb.default_label.print_terminal_subtrees()
        (&#39;list&#39;)
        (&#39;of&#39;)
        (&#39;all&#39;)
        (&#39;the&#39;)
        (&#39;fucks&#39;)
        (&#39;I&#39;)
        (&#39;give&#39;)
        ((&#39;fucks&#39;)(&#39;I&#39;)(&#39;give&#39;))
        ((&#39;the&#39;)((&#39;fucks&#39;)(&#39;I&#39;)(&#39;give&#39;)))
        ((&#39;all&#39;)((&#39;the&#39;)((&#39;fucks&#39;)(&#39;I&#39;)(&#39;give&#39;))))
        ((&#39;of&#39;)((&#39;all&#39;)((&#39;the&#39;)((&#39;fucks&#39;)(&#39;I&#39;)(&#39;give&#39;)))))
        ((&#39;list&#39;)((&#39;of&#39;)((&#39;all&#39;)((&#39;the&#39;)((&#39;fucks&#39;)(&#39;I&#39;)(&#39;give&#39;))))))
        &gt;&gt;&gt; tb.default_label.print_terminal_subtrees(is_LaTeX = True)
        \Tree [ list ]
        \Tree [ of ]
        \Tree [ all ]
        \Tree [ the ]
        \Tree [ fucks ]
        \Tree [ I ]
        \Tree [ give ]
        \Tree [ [ fucks ] [ I ] [ give ] ]
        \Tree [ [ the ] [ [ fucks ] [ I ] [ give ] ] ]
        \Tree [ [ all ] [ [ the ] [ [ fucks ] [ I ] [ give ] ] ] ]
        \Tree [ [ of ] [ [ all ] [ [ the ] [ [ fucks ] [ I ] [ give ] ] ] ] ]
        \Tree [ [ list ] [ [ of ] [ [ all ] [ [ the ] [ [ fucks ] [ I ] [ give ] ] ] ] ] ]
        &#34;&#34;&#34;
        if is_LaTeX: # Resolve the conditional first, so it is only done once
            for tree in self.nodes:
                # LaTeXise all the things!
                print(tree.to_LaTeX())
        else:
            for tree in self.nodes:
                # Or just print them!
                print(tree)

    @property
    def roots(self) -&gt; List[Tree]:
        &#34;&#34;&#34;(list[Tree]): all nodes in `self` that have no parent node

        &gt;&gt;&gt; tb = Treebank()
        &gt;&gt;&gt; tb.default_label = Label(tb, &#39;X&#39;)
        &gt;&gt;&gt; t1 = tree(&#34;([S]([NP](&#39;the&#39;)([N]&#39;sentence&#39;))([VP]([V]&#39;parses&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;parser&#39;))))&#34;, tb)
        &gt;&gt;&gt; t2 = tree(&#34;([S]([N]&#39;word&#39;)([VP]([V]&#39;parses&#39;)([N]&#39;parser&#39;)))&#34;, tb)
        &gt;&gt;&gt; t3 = tree(&#34;([S]([N]&#39;sentence&#39;)([VP]([V]&#39;parses&#39;)([V]&#39;parser&#39;)))&#34;, tb)
        &gt;&gt;&gt; x_tree = tree(&#34;((&#39;list&#39;)((&#39;of&#39;)((&#39;all&#39;)((&#39;the&#39;)((&#39;fucks&#39;)(&#39;I&#39;)(&#39;give&#39;))))))&#34;, tb)
        &gt;&gt;&gt; hippo = tree(&#34;([NP]([Det]&#39;a&#39;)([AdjP]([Adj]&#39;giant&#39;)([N]&#39;hippopotamus&#39;)))&#34;, tb)
        &gt;&gt;&gt; sad = tree(&#34;([Adv]&#39;alone&#39;)&#34;, tb)
        &gt;&gt;&gt; print(tb.classnames[&#39;V&#39;].roots)
        []
        &gt;&gt;&gt; def print_roots(name):
        ...     for root in tb.classnames[name].roots:
        ...         print(root)
        ...
        &gt;&gt;&gt; print_roots(&#39;S&#39;)
        ([S]([NP](&#39;the&#39;)([N]&#39;sentence&#39;))([VP]([V]&#39;parses&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;parser&#39;))))
        ([S]([N]&#39;word&#39;)([VP]([V]&#39;parses&#39;)([N]&#39;parser&#39;)))
        ([S]([N]&#39;sentence&#39;)([VP]([V]&#39;parses&#39;)([V]&#39;parser&#39;)))
        &gt;&gt;&gt; print_roots(&#39;X&#39;)
        ((&#39;list&#39;)((&#39;of&#39;)((&#39;all&#39;)((&#39;the&#39;)((&#39;fucks&#39;)(&#39;I&#39;)(&#39;give&#39;))))))
        &gt;&gt;&gt; print_roots(&#39;Adv&#39;)
        ([Adv]&#39;alone&#39;)
        &gt;&gt;&gt; print_roots(&#39;NP&#39;)
        ([NP]([Det]&#39;a&#39;)([AdjP]([Adj]&#39;giant&#39;)([N]&#39;hippopotamus&#39;)))
        &#34;&#34;&#34;
        return list(filter(lambda node: not bool(node.parent), self.nodes))</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="trees.Label.classname"><code class="name">var <span class="ident">classname</span></code></dt>
<dd>
<div class="desc"><p>(str) The name of the Label, and of the corresponding category of
trees.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def classname(self):
    &#34;&#34;&#34;(str) The name of the Label, and of the corresponding category of
    trees.
    &#34;&#34;&#34;
    return self._classname</code></pre>
</details>
</dd>
<dt id="trees.Label.roots"><code class="name">var <span class="ident">roots</span> :Â List[<a title="trees.Tree" href="#trees.Tree">Tree</a>]</code></dt>
<dd>
<div class="desc"><p>(list[Tree]): all nodes in <code>self</code> that have no parent node</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; tb = Treebank()
&gt;&gt;&gt; tb.default_label = Label(tb, 'X')
&gt;&gt;&gt; t1 = tree(&quot;([S]([NP]('the')([N]'sentence'))([VP]([V]'parses')([NP]([Det]'the')([N]'parser'))))&quot;, tb)
&gt;&gt;&gt; t2 = tree(&quot;([S]([N]'word')([VP]([V]'parses')([N]'parser')))&quot;, tb)
&gt;&gt;&gt; t3 = tree(&quot;([S]([N]'sentence')([VP]([V]'parses')([V]'parser')))&quot;, tb)
&gt;&gt;&gt; x_tree = tree(&quot;(('list')(('of')(('all')(('the')(('fucks')('I')('give'))))))&quot;, tb)
&gt;&gt;&gt; hippo = tree(&quot;([NP]([Det]'a')([AdjP]([Adj]'giant')([N]'hippopotamus')))&quot;, tb)
&gt;&gt;&gt; sad = tree(&quot;([Adv]'alone')&quot;, tb)
&gt;&gt;&gt; print(tb.classnames['V'].roots)
[]
&gt;&gt;&gt; def print_roots(name):
...     for root in tb.classnames[name].roots:
...         print(root)
...
&gt;&gt;&gt; print_roots('S')
([S]([NP]('the')([N]'sentence'))([VP]([V]'parses')([NP]([Det]'the')([N]'parser'))))
([S]([N]'word')([VP]([V]'parses')([N]'parser')))
([S]([N]'sentence')([VP]([V]'parses')([V]'parser')))
&gt;&gt;&gt; print_roots('X')
(('list')(('of')(('all')(('the')(('fucks')('I')('give'))))))
&gt;&gt;&gt; print_roots('Adv')
([Adv]'alone')
&gt;&gt;&gt; print_roots('NP')
([NP]([Det]'a')([AdjP]([Adj]'giant')([N]'hippopotamus')))
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def roots(self) -&gt; List[Tree]:
    &#34;&#34;&#34;(list[Tree]): all nodes in `self` that have no parent node

    &gt;&gt;&gt; tb = Treebank()
    &gt;&gt;&gt; tb.default_label = Label(tb, &#39;X&#39;)
    &gt;&gt;&gt; t1 = tree(&#34;([S]([NP](&#39;the&#39;)([N]&#39;sentence&#39;))([VP]([V]&#39;parses&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;parser&#39;))))&#34;, tb)
    &gt;&gt;&gt; t2 = tree(&#34;([S]([N]&#39;word&#39;)([VP]([V]&#39;parses&#39;)([N]&#39;parser&#39;)))&#34;, tb)
    &gt;&gt;&gt; t3 = tree(&#34;([S]([N]&#39;sentence&#39;)([VP]([V]&#39;parses&#39;)([V]&#39;parser&#39;)))&#34;, tb)
    &gt;&gt;&gt; x_tree = tree(&#34;((&#39;list&#39;)((&#39;of&#39;)((&#39;all&#39;)((&#39;the&#39;)((&#39;fucks&#39;)(&#39;I&#39;)(&#39;give&#39;))))))&#34;, tb)
    &gt;&gt;&gt; hippo = tree(&#34;([NP]([Det]&#39;a&#39;)([AdjP]([Adj]&#39;giant&#39;)([N]&#39;hippopotamus&#39;)))&#34;, tb)
    &gt;&gt;&gt; sad = tree(&#34;([Adv]&#39;alone&#39;)&#34;, tb)
    &gt;&gt;&gt; print(tb.classnames[&#39;V&#39;].roots)
    []
    &gt;&gt;&gt; def print_roots(name):
    ...     for root in tb.classnames[name].roots:
    ...         print(root)
    ...
    &gt;&gt;&gt; print_roots(&#39;S&#39;)
    ([S]([NP](&#39;the&#39;)([N]&#39;sentence&#39;))([VP]([V]&#39;parses&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;parser&#39;))))
    ([S]([N]&#39;word&#39;)([VP]([V]&#39;parses&#39;)([N]&#39;parser&#39;)))
    ([S]([N]&#39;sentence&#39;)([VP]([V]&#39;parses&#39;)([V]&#39;parser&#39;)))
    &gt;&gt;&gt; print_roots(&#39;X&#39;)
    ((&#39;list&#39;)((&#39;of&#39;)((&#39;all&#39;)((&#39;the&#39;)((&#39;fucks&#39;)(&#39;I&#39;)(&#39;give&#39;))))))
    &gt;&gt;&gt; print_roots(&#39;Adv&#39;)
    ([Adv]&#39;alone&#39;)
    &gt;&gt;&gt; print_roots(&#39;NP&#39;)
    ([NP]([Det]&#39;a&#39;)([AdjP]([Adj]&#39;giant&#39;)([N]&#39;hippopotamus&#39;)))
    &#34;&#34;&#34;
    return list(filter(lambda node: not bool(node.parent), self.nodes))</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="trees.Label.add_node"><code class="name flex">
<span>def <span class="ident">add_node</span></span>(<span>self, node:Â <a title="trees.Tree" href="#trees.Tree">Tree</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>When a label is added to a node, the node is also added to the label:
a Label is fundamentally a substitutability class. Each label object has
a list <code>self.nodes</code> in which all nodes in the class are stored.</p>
<p>To guarantee consistency, <code>add_node</code> checks that <code>node</code> is indeed a
subclass of <code><a title="trees.Tree" href="#trees.Tree">Tree</a></code>, and that it does not belong to any other
<code><a title="trees.Label" href="#trees.Label">Label</a></code>, and that it has a reference to the present <code><a title="trees.Label" href="#trees.Label">Label</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code><a title="trees.Tree" href="#trees.Tree">Tree</a></code></dt>
<dd>The node to be added.</dd>
</dl>
<h2 id="raise">Raise</h2>
<p>TypeError
If the node is not actually a Tree</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; tb = Treebank()
&gt;&gt;&gt; tb.default_label = Label(tb, '*')
&gt;&gt;&gt; adv = Label(tb, 'Adv')
&gt;&gt;&gt; print(adv)
[Adv]
&gt;&gt;&gt; sad_tree = tree(&quot;('alone')&quot;, tb)
&gt;&gt;&gt; print(sad_tree)
('alone')
&gt;&gt;&gt; adv.add_node(sad_tree)
&gt;&gt;&gt; adv.print_terminal_subtrees()
([Adv]'alone')
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_node(self, node: Tree):
    &#34;&#34;&#34;When a label is added to a node, the node is also added to the label:
    a Label is fundamentally a substitutability class. Each label object has
    a list `self.nodes` in which all nodes in the class are stored.

    To guarantee consistency, `add_node` checks that `node` is indeed a
    subclass of `Tree`, and that it does not belong to any other
    `Label`, and that it has a reference to the present `Label`.

    Parameters
    ----------
    node : Tree
        The node to be added.

    Raise
    -----
    TypeError
        If the node is not actually a Tree

    &gt;&gt;&gt; tb = Treebank()
    &gt;&gt;&gt; tb.default_label = Label(tb, &#39;*&#39;)
    &gt;&gt;&gt; adv = Label(tb, &#39;Adv&#39;)
    &gt;&gt;&gt; print(adv)
    [Adv]
    &gt;&gt;&gt; sad_tree = tree(&#34;(&#39;alone&#39;)&#34;, tb)
    &gt;&gt;&gt; print(sad_tree)
    (&#39;alone&#39;)
    &gt;&gt;&gt; adv.add_node(sad_tree)
    &gt;&gt;&gt; adv.print_terminal_subtrees()
    ([Adv]&#39;alone&#39;)
    &#34;&#34;&#34;
    # Check the type first
    if issubclass(type(node), Tree):
        # If it already has `self` as its label, all that is needed is to
        # add it to self.nodes. This is the expected behaviour, as the
        # setter for label in Tree is what calls add_node, and is
        # itself called in Tree.__init__, which its inheritors
        # typically extend rather than override; but just in case...
        if node.label is not self:
            # If the node.label just isn&#39;t set, all that is needed to set
            # it: bu just in case...
            if node.label is not None:
                # If it already has a different Label, then make sure it
                # is removed from the other Label&#39;s node list
                node.label.remove_node(node)
            # So now we&#39;re sure we can set the label param on node
            # TODO: There is no `self.nodes.append(node)` on this branch,
            # because this is done in the label setter in Tree.
            # I tried having the `self.nodes.append(node)` below under
            # a separate conditional checking that `node` isn&#39;t already in
            # `self.nodes`, which does remove the dependency but makes
            # everything super slow. Is there a better way of removing this
            # dependency
            node.label = self
        # And now we&#39;re sure it&#39;s OK to add the node to the node list,
        # unless node&#39;s label.setter already did this
        else:
            self.nodes.append(node)
    else:
        # But if the type check fails...
        raise TypeError(
            &#34;When you add a node to a Label, it must be a Tree. You added&#34; +
            f&#34; a {type(node):s}, and that makes me sad.&#34; # womp womp
        )</code></pre>
</details>
</dd>
<dt id="trees.Label.print_terminal_subtrees"><code class="name flex">
<span>def <span class="ident">print_terminal_subtrees</span></span>(<span>self, is_LaTeX=False)</span>
</code></dt>
<dd>
<div class="desc"><p>A helper function for testing and inspection, mostly. Prints out all
trees with the current <code><a title="trees.Label" href="#trees.Label">Label</a></code>, either using <code>__str__</code> or <code>to_LaTeX</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>is_LaTeX</code></strong> :&ensp;<code>bool</code></dt>
<dd>If true, print the trees in LaTeX <code>qtree</code> format: otherwise just use
the standard str format</dd>
</dl>
<pre><code class="language-python-repl">&gt;&gt;&gt; tb = Treebank()
&gt;&gt;&gt; tb.default_label = Label(tb, '*')
&gt;&gt;&gt; x_tree = tree(&quot;(('list')(('of')(('all')(('the')(('fucks')('I')('give'))))))&quot;, tb)
&gt;&gt;&gt; print(x_tree)
(('list')(('of')(('all')(('the')(('fucks')('I')('give'))))))
&gt;&gt;&gt; tb.default_label.print_terminal_subtrees()
('list')
('of')
('all')
('the')
('fucks')
('I')
('give')
(('fucks')('I')('give'))
(('the')(('fucks')('I')('give')))
(('all')(('the')(('fucks')('I')('give'))))
(('of')(('all')(('the')(('fucks')('I')('give')))))
(('list')(('of')(('all')(('the')(('fucks')('I')('give'))))))
&gt;&gt;&gt; tb.default_label.print_terminal_subtrees(is_LaTeX = True)
\Tree [ list ]
\Tree [ of ]
\Tree [ all ]
\Tree [ the ]
\Tree [ fucks ]
\Tree [ I ]
\Tree [ give ]
\Tree [ [ fucks ] [ I ] [ give ] ]
\Tree [ [ the ] [ [ fucks ] [ I ] [ give ] ] ]
\Tree [ [ all ] [ [ the ] [ [ fucks ] [ I ] [ give ] ] ] ]
\Tree [ [ of ] [ [ all ] [ [ the ] [ [ fucks ] [ I ] [ give ] ] ] ] ]
\Tree [ [ list ] [ [ of ] [ [ all ] [ [ the ] [ [ fucks ] [ I ] [ give ] ] ] ] ] ]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_terminal_subtrees(self, is_LaTeX=False):
    &#34;&#34;&#34;A helper function for testing and inspection, mostly. Prints out all
    trees with the current `Label`, either using `__str__` or `to_LaTeX`.

    Parameters
    ----------
    is_LaTeX : bool
        If true, print the trees in LaTeX `qtree` format: otherwise just use
        the standard str format

    &gt;&gt;&gt; tb = Treebank()
    &gt;&gt;&gt; tb.default_label = Label(tb, &#39;*&#39;)
    &gt;&gt;&gt; x_tree = tree(&#34;((&#39;list&#39;)((&#39;of&#39;)((&#39;all&#39;)((&#39;the&#39;)((&#39;fucks&#39;)(&#39;I&#39;)(&#39;give&#39;))))))&#34;, tb)
    &gt;&gt;&gt; print(x_tree)
    ((&#39;list&#39;)((&#39;of&#39;)((&#39;all&#39;)((&#39;the&#39;)((&#39;fucks&#39;)(&#39;I&#39;)(&#39;give&#39;))))))
    &gt;&gt;&gt; tb.default_label.print_terminal_subtrees()
    (&#39;list&#39;)
    (&#39;of&#39;)
    (&#39;all&#39;)
    (&#39;the&#39;)
    (&#39;fucks&#39;)
    (&#39;I&#39;)
    (&#39;give&#39;)
    ((&#39;fucks&#39;)(&#39;I&#39;)(&#39;give&#39;))
    ((&#39;the&#39;)((&#39;fucks&#39;)(&#39;I&#39;)(&#39;give&#39;)))
    ((&#39;all&#39;)((&#39;the&#39;)((&#39;fucks&#39;)(&#39;I&#39;)(&#39;give&#39;))))
    ((&#39;of&#39;)((&#39;all&#39;)((&#39;the&#39;)((&#39;fucks&#39;)(&#39;I&#39;)(&#39;give&#39;)))))
    ((&#39;list&#39;)((&#39;of&#39;)((&#39;all&#39;)((&#39;the&#39;)((&#39;fucks&#39;)(&#39;I&#39;)(&#39;give&#39;))))))
    &gt;&gt;&gt; tb.default_label.print_terminal_subtrees(is_LaTeX = True)
    \Tree [ list ]
    \Tree [ of ]
    \Tree [ all ]
    \Tree [ the ]
    \Tree [ fucks ]
    \Tree [ I ]
    \Tree [ give ]
    \Tree [ [ fucks ] [ I ] [ give ] ]
    \Tree [ [ the ] [ [ fucks ] [ I ] [ give ] ] ]
    \Tree [ [ all ] [ [ the ] [ [ fucks ] [ I ] [ give ] ] ] ]
    \Tree [ [ of ] [ [ all ] [ [ the ] [ [ fucks ] [ I ] [ give ] ] ] ] ]
    \Tree [ [ list ] [ [ of ] [ [ all ] [ [ the ] [ [ fucks ] [ I ] [ give ] ] ] ] ] ]
    &#34;&#34;&#34;
    if is_LaTeX: # Resolve the conditional first, so it is only done once
        for tree in self.nodes:
            # LaTeXise all the things!
            print(tree.to_LaTeX())
    else:
        for tree in self.nodes:
            # Or just print them!
            print(tree)</code></pre>
</details>
</dd>
<dt id="trees.Label.remove_node"><code class="name flex">
<span>def <span class="ident">remove_node</span></span>(<span>self, node:Â <a title="trees.Tree" href="#trees.Tree">Tree</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>A bit of tear-down is needed if a Label is removed from a node: the
Label is a substitutability class, and maintains a record of all the
trees in the class, so the node must also be removed from the <code><a title="trees.Label" href="#trees.Label">Label</a></code>'s
list.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code><a title="trees.Tree" href="#trees.Tree">Tree</a></code></dt>
<dd>The node to be removed</dd>
</dl>
<pre><code class="language-python-repl">&gt;&gt;&gt; tb = Treebank()
&gt;&gt;&gt; tb.default_label = Label(tb, '*')
&gt;&gt;&gt; t_1 = tree(&quot;([S]([NP]([Det]'the')([N]'sentence'))([VP]([V]'parses')([NP]([Det]'the')([N]'parser'))))&quot;, tb)
&gt;&gt;&gt; t_2 = tree(&quot;([S]([N]'word')([VP]([V]'parses')([N]'parser')))&quot;, tb)
&gt;&gt;&gt; t_3 = tree(&quot;([S]([N]'sentence')([VP]([V]'parses')([V]'parser')))&quot;, tb)
&gt;&gt;&gt; t_1[0,0].label.remove_node(t_1[0,0])
&gt;&gt;&gt; print(t_1)
([S]([NP]('the')([N]'sentence'))([VP]([V]'parses')([NP]([Det]'the')([N]'parser'))))
&gt;&gt;&gt; tb.default_label.add_node(t_1[0,0])
&gt;&gt;&gt; print(t_1)
([S]([NP]('the')([N]'sentence'))([VP]([V]'parses')([NP]([Det]'the')([N]'parser'))))
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_node(self, node: Tree):
    &#34;&#34;&#34;A bit of tear-down is needed if a Label is removed from a node: the
    Label is a substitutability class, and maintains a record of all the
    trees in the class, so the node must also be removed from the `Label`&#39;s
    list.

    Parameters
    ----------
    node : Tree
        The node to be removed

    &gt;&gt;&gt; tb = Treebank()
    &gt;&gt;&gt; tb.default_label = Label(tb, &#39;*&#39;)
    &gt;&gt;&gt; t_1 = tree(&#34;([S]([NP]([Det]&#39;the&#39;)([N]&#39;sentence&#39;))([VP]([V]&#39;parses&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;parser&#39;))))&#34;, tb)
    &gt;&gt;&gt; t_2 = tree(&#34;([S]([N]&#39;word&#39;)([VP]([V]&#39;parses&#39;)([N]&#39;parser&#39;)))&#34;, tb)
    &gt;&gt;&gt; t_3 = tree(&#34;([S]([N]&#39;sentence&#39;)([VP]([V]&#39;parses&#39;)([V]&#39;parser&#39;)))&#34;, tb)
    &gt;&gt;&gt; t_1[0,0].label.remove_node(t_1[0,0])
    &gt;&gt;&gt; print(t_1)
    ([S]([NP](&#39;the&#39;)([N]&#39;sentence&#39;))([VP]([V]&#39;parses&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;parser&#39;))))
    &gt;&gt;&gt; tb.default_label.add_node(t_1[0,0])
    &gt;&gt;&gt; print(t_1)
    ([S]([NP](&#39;the&#39;)([N]&#39;sentence&#39;))([VP]([V]&#39;parses&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;parser&#39;))))
    &#34;&#34;&#34;
    # Using this loop to remove the node from nodes, because __eq__ is
    # overriden in Tree, and it is important that the node that is removed
    # is the exact node passed to the method, not just the first one to have
    # the same value.
    for i, t in enumerate(self.nodes):
        if t is node:
            del self.nodes[i]
            break
    node.label = None</code></pre>
</details>
</dd>
<dt id="trees.Label.to_LaTeX"><code class="name flex">
<span>def <span class="ident">to_LaTeX</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>String representation of Label for use with to_LaTeX methods in Tree
classes. Returns "" for unlabelled nodes.</p>
<h2 id="returns">Returns</h2>
<pre><code>str: classname preceded by &lt;code&gt;.&lt;/code&gt;, or empty string for _default_label
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; # No doctests here - the tests for to_LaTeX in the &lt;code&gt;&lt;a title=&quot;trees.Tree&quot; href=&quot;#trees.Tree&quot;&gt;Tree&lt;/a&gt;&lt;/code&gt; classes
&gt;&gt;&gt; # implicitly also test this
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_LaTeX(self):
    &#34;&#34;&#34;String representation of Label for use with to_LaTeX methods in Tree
    classes. Returns &#34;&#34; for unlabelled nodes.

    Returns
    -------
        str: classname preceded by `.`, or empty string for _default_label

    &gt;&gt;&gt; # No doctests here - the tests for to_LaTeX in the `Tree` classes
    &gt;&gt;&gt; # implicitly also test this
    &#34;&#34;&#34;
    return &#34;&#34; if self.is_default else f&#34;.{self.classname}&#34;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="trees.NonTerminal"><code class="flex name class">
<span>class <span class="ident">NonTerminal</span></span>
<span>(</span><span>treebank, label, *children)</span>
</code></dt>
<dd>
<div class="desc"><p>Generic class for non-terminal tree nodes: that is, nodes which do not
carry terminal content like words in syntactic parsing or constants and
variables in genetic programming, but which can take other tree nodes as
children</p>
<p>TODO: add a metadata attribute</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>_label</code></strong> :&ensp;<code><a title="trees.Label" href="#trees.Label">Label</a></code></dt>
<dd>Inherited from Tree. Node label determining which subtrees can be
substituted where. Set and got by the <code>label</code> @property</dd>
<dt><strong><code>parent</code></strong> :&ensp;<code><a title="trees.NonTerminal" href="#trees.NonTerminal">NonTerminal</a></code> or <code>None</code></dt>
<dd>Inherited from Tree. The node dirctly above the present in the tree.
Each child has a reference to its parent, and each parent has references
to all its children.</dd>
<dt><strong><code>treebank</code></strong> :&ensp;<code><a title="trees.Treebank" href="#trees.Treebank">Treebank</a></code></dt>
<dd>Every tree belongs to a Treebank, which defines the set of Labels that
<code><a title="trees.Tree" href="#trees.Tree">Tree</a></code>, its parents, and its children can take.</dd>
<dt><strong><code>_children</code></strong> :&ensp;<code>list</code> of <code>Trees</code> or <code>None</code></dt>
<dd>The nodes directly below the present in the tree.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NonTerminal(Tree):
    &#34;&#34;&#34;Generic class for non-terminal tree nodes: that is, nodes which do not
    carry terminal content like words in syntactic parsing or constants and
    variables in genetic programming, but which can take other tree nodes as
    children

    TODO: add a metadata attribute

    Parameters
    ----------
    _label : Label
        Inherited from Tree. Node label determining which subtrees can be
        substituted where. Set and got by the `label` @property
    parent : NonTerminal or None
        Inherited from Tree. The node dirctly above the present in the tree.
        Each child has a reference to its parent, and each parent has references
        to all its children.
    treebank : Treebank
        Every tree belongs to a Treebank, which defines the set of Labels that
        `Tree`, its parents, and its children can take.
    _children : list of Trees or None
        The nodes directly below the present in the tree.
    &#34;&#34;&#34;

    STRICT_ADDITION = True
    &#34;&#34;&#34;bool: If True, the `+` operator does leftmost nonterminal substitution,
    which throws an error if the liftmost nonterminal leaf node label of the
    left operand does not match the root label of the right operand; if False it
    substitutes the right operand into the leftmost matching nonterminal
    leafnode, and raises an error only if there is no match.
    &#34;&#34;&#34;

    def __init__(self, treebank, label, *children):
        self.children = list(children)
        super().__init__(treebank, label)

    @property
    def children(self):
        &#34;&#34;&#34;Getter for the children attribute&#34;&#34;&#34;
        return self._children

    @children.setter
    def children(self, children):
        &#34;&#34;&#34;Checks that the elements of the `children` param are all Trees,
        and if they are, sets their `parent` attributes to `self`, and set the
        list to be the `_children` attribute of self. The attribute will only be
        set if all list members are valid children: if an invalid child is found
        an error is raised and any list members that had their `parent`
        attribute set to `self` will have it set back to `None`.

        TODO: check that children belong to same treebank, or copy children in
            to Treebank if arg `copy_in = True` (default to False)

        Raises
        ------
        TypeError
            If something other than a tree is passed as a child
        &#34;&#34;&#34;
        for i, c in enumerate(children): # Make sure all children are Trees
            if isinstance(c, self.__class__) or isinstance(c, Terminal):
                c.parent = self # If the child is a tree, self can be its parent
            else:
                # If not...
                for orphan in children[:i]:
                    # This is the saddest line of code I have ever written
                    orphan.parent = None
                raise TypeError(f&#34;You tried to set a {type(c):s}, {c:s} as \
                                a child of the Tree {self:s}. You \
                                should have used a Tree&#34;)
        # If all children typecheck OK, it&#39;s ok to go ahead and set them as
        # the children of the current node
        self._children = children

    def __len__(self) -&gt; int:
        &#34;&#34;&#34;All nodes have a length: Terminals have length 1, while NonTerminals
        have a length equal to the number of children

        Returns
        -------
        int:  Number of children

        &gt;&gt;&gt; t = test_trees()
        &gt;&gt;&gt; print([len(tx) for tx in t])
        [1, 2, 2, 2, 2, 2, 2, 2]
        &gt;&gt;&gt; print([len(tree(f&#34;([S]{&#39;([N]blah)&#39;*x})&#34;)) for x in range(11)])
        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
        &gt;&gt;&gt; tf = test_fragments()
        &gt;&gt;&gt; print([len(tfx) for tfx in tf])
        [2, 2, 0]
        &#34;&#34;&#34;
        return len(self._children) if hasattr(self, &#39;_children&#39;) else 0

    def __str__(self):
        &#34;&#34;&#34;Readable string representation of a tree. This consists of a pair of
        parentheses containing a representation of the tree&#39;s label (label name
        in square brackets), followed by a representation of the node&#39;s
        children, which is just each child&#39;s representation, concatenated, eg:

        ([VP]([V]&#39;bites&#39;)([N]&#39;man&#39;)).

        &gt;&gt;&gt; # No doctest needed here, as doctest for test_trees also tests this
        &#34;&#34;&#34;
        lab_str = self.label if hasattr(self, &#39;_label&#39;) else &#39;&#39;
        # The list comprehension here uses a range rather than looping directly
        # over self because Python loops use IndexError-catching to know when to
        # stop looping, and I want to be able to include str(tree) in the custom
        # error message when a tree is indexed with an invalid index, and if
        # that error is thrown every time a tree is looped over, and the error
        # message calls tree.__str__(), which loops over the tree, which throws
        # the custom error, which calls tree.__str__()...
        #
        # URGH RecursionError: maximum recursion depth exceeded
        #
        # This is a jank-ass solution to the problem and I&#39;m mad about it :|
        return f&#34;({lab_str}{&#39;&#39;.join([str(self[i]) for i in range(len(self))]) if self else &#39;&#39;})&#34;

    def depth(self) -&gt; int:
        &#34;&#34;&#34;All nodes have a depth: the depth of a leaf node is 1, and the depth
        of any other node is the depth of its deepest child + 1

        Returns
        -------
        int:
            Tree depth

        &gt;&gt;&gt; t = test_trees()
        &gt;&gt;&gt; print([tx.depth() for tx in t])
        [1, 3, 3, 3, 4, 3, 3, 2]
        &gt;&gt;&gt; tf = test_fragments()
        &gt;&gt;&gt; print([tfx.depth() for tfx in tf])
        [3, 3, 0]
        &gt;&gt;&gt; blah_depths = []
        &gt;&gt;&gt; blah = &#34;([S]&#39;blah&#39;)&#34;
        &gt;&gt;&gt; print(tree(blah).depth())
        1
        &gt;&gt;&gt; for i in range(8):
        ...     blah = blah.replace(&#34;&#39;blah&#39;&#34;, blah)
        ...     blah_depths.append(tree(blah).depth())
        ...
        &gt;&gt;&gt; print(blah_depths)
        [2, 4, 8, 16, 32, 64, 128, 256]
        &gt;&gt;&gt; tb = Treebank()
        &gt;&gt;&gt; fragment = tree(&#34;([S]([PN]&#39;I&#39;)([VP]))&#34;, treebank = tb)
        &gt;&gt;&gt; fragment.depth()
        2
        &#34;&#34;&#34;
        # Recursive function with two stopping cases: if called on a
        # NonTerminal leafnode, or in a Terminal. The `else` case below handles
        # the former, and for the latter, Terminal has its own version of the
        # function
        return (1 + max([c.depth() for c in self])) if self.children else 0

    def width(self) -&gt; int:
        &#34;&#34;&#34;All nodes have a width: the width of a leaf node is 1, and the width
        of any other node is the sum of its children&#39;s widths. This is
        equivalent to the total number of leaf nodes in the tree

        Returns
        -------
        int:
            Tree width

        &gt;&gt;&gt; t = test_trees()
        &gt;&gt;&gt; print([tx.width() for tx in t])
        [1, 3, 3, 3, 5, 3, 3, 2]
        &gt;&gt;&gt; tf = test_fragments()
        &gt;&gt;&gt; print([tfx.width() for tfx in tf])
        [3, 4, 1]
        &gt;&gt;&gt; blah_widths = []
        &gt;&gt;&gt; blah = &#34;([N]&#39;blah&#39;)&#34;
        &gt;&gt;&gt; print(tree(blah).width())
        1
        &gt;&gt;&gt; for i in range(1,4):
        ...     blah_top = &#34;([S]&#39;blah&#39;)&#34;
        ...     for j in range(8):
        ...         blah_top = blah_top.replace(&#34;&#39;blah&#39;&#34;, blah*i)
        ...         blah_widths.append(tree(blah_top).width())
        ...
        &gt;&gt;&gt; print(blah_widths)
        [1, 1, 1, 1, 1, 1, 1, 1, 2, 4, 8, 16, 32, 64, 128, 256, 3, 9, 27, 81, 243, 729, 2187, 6561]
        &gt;&gt;&gt; tb = Treebank()
        &gt;&gt;&gt; fragment = tree(&#34;([S]([PN]&#39;I&#39;)([VP]))&#34;, treebank = tb)
        &gt;&gt;&gt; fragment.width()
        2
        &#34;&#34;&#34;
        return max(sum([c.width() for c in self]), 1)

    def size(self) -&gt; int:
        &#34;&#34;&#34;All nodes have a size: the size of a leaf node is 1, and the size
        of any other node is the sum of its children&#39;s sizes, plus 1. This is
        the total number of nodes in the tree.

        Returns
        -------
        int:
            total number of nodes in the tree

        &gt;&gt;&gt; t = test_trees()
        &gt;&gt;&gt; print([tx.size() for tx in t])
        [1, 5, 5, 5, 9, 5, 5, 3]
        &gt;&gt;&gt; tf = test_fragments()
        &gt;&gt;&gt; print([tfx.size() for tfx in tf])
        [5, 7, 1]
        &gt;&gt;&gt; blah_sizes = []
        &gt;&gt;&gt; blah = &#34;([N]&#39;blah&#39;)&#34;
        &gt;&gt;&gt; print(tree(blah).size())
        1
        &gt;&gt;&gt; for i in range(1,4):
        ...     blah_top = &#34;([S]&#39;blah&#39;)&#34;
        ...     for j in range(8):
        ...         blah_top = blah_top.replace(&#34;&#39;blah&#39;&#34;, blah*i)
        ...         blah_sizes.append(tree(blah_top).size())
        ...
        &gt;&gt;&gt; print(blah_sizes)
        [2, 3, 4, 5, 6, 7, 8, 9, 3, 7, 15, 31, 63, 127, 255, 511, 4, 13, 40, 121, 364, 1093, 3280, 9841]
        &#34;&#34;&#34;
        return 1 + sum([c.size() for c in self])

    def __eq__(self, other):
        &#34;&#34;&#34;Checks that two trees are the same: for this to return true, the
        trees must be of the same type, with the same root label, with the same
        number of children, and each child in self must equal the child at the
        same index in other. `Terminal`s must also have equal leaves. Magic
        method for operator overloading on `==` and `!=`.

        TODO: make sure Label has an appropriate __eq__ method.

        Parameters
        ----------
        other : Tree
            The right operand

        Returns
        -------
        bool
            True if trees are equal, False otherwise

        &gt;&gt;&gt; t = test_trees()
        &gt;&gt;&gt; t[0] == t[0]
        True
        &gt;&gt;&gt; t[1] == t[1]
        True
        &gt;&gt;&gt; t[3] == t[1]
        True
        &gt;&gt;&gt; t[3] == t[2]
        True
        &gt;&gt;&gt; t[1] == t[3]
        True
        &gt;&gt;&gt; t[1] == t[2]
        True
        &gt;&gt;&gt; t[2] == t[3]
        True
        &gt;&gt;&gt; t[2] == t[1]
        True
        &gt;&gt;&gt; t[1] == t[4]
        False
        &gt;&gt;&gt; t[1] == t[5]
        False
        &gt;&gt;&gt; t[1] == t[6]
        False
        &gt;&gt;&gt; tf = test_fragments()
        &gt;&gt;&gt; for tfx in tf:
        ...     print([int(tfx == tfy) for tfy in tf])
        ...
        [1, 0, 0]
        [0, 1, 0]
        [0, 0, 1]
        &#34;&#34;&#34;
        # First check all the local property comparisons
        if self.__class__ == other.__class__ and self.label == other.label and len(self) == len(other):
            # If all of those come up true, check the children
            for self_c, other_c in zip(self, other):
                # If any children are not equal, self and other are not equal
                if self_c != other_c:
                    return False
            # If all of that fails to return false, self and other are equal
            return True
        # If the local comparisons do not all come out true, they are not equal
        else:
            return False

    def to_LaTeX(self, top = True):
        &#34;&#34;&#34;Converts trees to LaTeX expressions using the `qtree` package.
        Remember to include `\\usepackage{qtree}` in the document header. For
        NonTerminals, the format is `[.$label $child* ]`. The label expression
        is provided by a similar function in Label. The $child expressions are
        recursively in the same format again (if they are also NonTerminals), or
        `[.$label $leaf]` for Terminals, which have a separate `to_LaTeX`
        method.

        Parameters
        ----------
        top : bool
            qtrees expressions must be prefixed with `\\Tree`, but this only
            applies to the whole tree: you don&#39;t put it in front of every node.
            However, this function uses recursive calls to make the LaTeX of
            child nodes, so making sure only the top node has this prefix takes
            a bit of extra logic. If the node has no parent, the `\\Tree` prefix
            is automaticaly applied, otherwise by default it isn&#39;t. However, if
            LaTeX is wanted for a partial tree, `top` may be set to `True`

        Returns
        -------
        str
            LaTeX expression representing the tree.

        &gt;&gt;&gt; t = test_trees()
        &gt;&gt;&gt; for x in t[1:]:
        ...     print(x.to_LaTeX())
        ...
        \Tree [.S [.N sentence ] [.VP [.V parses ] [.N parser ] ] ]
        \Tree [.S [.N sentence ] [.VP [.V parses ] [.N parser ] ] ]
        \Tree [.S [.N sentence ] [.VP [.V parses ] [.N parser ] ] ]
        \Tree [.S [.NP [.Det the ] [.N sentence ] ] [.VP [.V parses ] [.NP [.Det the ] [.N parser ] ] ] ]
        \Tree [.S [.N word ] [.VP [.V parses ] [.N parser ] ] ]
        \Tree [.S [.N sentence ] [.VP [.V parses ] [.V parser ] ] ]
        \Tree [.S [.X x ] [.Y y ] ]
        &gt;&gt;&gt; tf = test_fragments()
        &gt;&gt;&gt; for tfx in tf:
        ...     print(tfx.to_LaTeX())
        ...
        \Tree [.S [.NP [.Det the ] [.N cat ] ] [.VP ] ]
        \Tree [.S [.NP [.Det the ] [.N cat ] ] [.VP [.V ate ] [.NP ] ] ]
        \Tree [.NP ]
        &#34;&#34;&#34;
        # prepends \Tree if needed
        LaTeX = r&#34;\Tree &#34; if not (hasattr(self, &#39;parent&#39;) and self.parent) or top else &#34;&#34;
        LaTeX += f&#34;[{self.label.to_LaTeX()} {&#39;&#39;.join([c.to_LaTeX(top = False) for c in self])}] &#34;
        return LaTeX.strip() if top else LaTeX

    def __getitem__(self, position):
        &#34;&#34;&#34;All trees are indexable, with the i^th index retrieving the i^th
        child, except with Terminals, where the zeroth and only item is the leaf
        value. Multiple indices can be provided, comma separated, to index a
        grandchild, great-grandchild, etc.

        Parameters
        ----------
        position : int or tuple of ints
            If `int`, the index of a child in `self`&#39;s list of children. If
            `tuple`, a sequence of indices to navigate downwards from `self` to
            a specified descendant of `self`

        Returns
        -------
        Tree or str, int, float, etc, depending on the valid types for leaf
        content
            A descendant of `self` located by index. If the penultimate term in
            the list of tuples indicates a `Terminal`, and the last index is 0,
            this will return the leaf content of that `Terminal`

        Raises
        ------
        IndexError:
            Raises a custom IndexError if the path through the tree represented
            by `position` does not exist. This can happen if:
                * A NonTerminal with children is indexed, but the index is out
                of range
                * A NonTerminal without children is indexed at all
                * A Terminal is indexed with an int other than 0
                * A Terminal is indexed with a tuple of length greater than 1,
                even if the first item in the tuple is 0

        &gt;&gt;&gt; t1 = tree(&#34;([S]([N]sentence)([VP]([V]parses)([NP]([Det]a)([N]parser))))&#34;)
        &gt;&gt;&gt; print(t1[0])
        ([N]&#39;sentence&#39;)
        &gt;&gt;&gt; print(t1[0, 0])
        sentence
        &gt;&gt;&gt; print(t1[1, 0])
        ([V]&#39;parses&#39;)
        &gt;&gt;&gt; print(t1[1, 1])
        ([NP]([Det]&#39;a&#39;)([N]&#39;parser&#39;))
        &gt;&gt;&gt; print(t1[1, 1, 0])
        ([Det]&#39;a&#39;)
        &gt;&gt;&gt; print(t1[1, 1, 0, 0])
        a
        &gt;&gt;&gt; print(t1[1, 2]) # doctest: +IGNORE_EXCEPTION_DETAIL
        Traceback (most recent call last):
        IndexError: Index out of range. The Tree:
        ([VP]([V]&#39;parses&#39;)([NP]([Det]&#39;a&#39;)([N]&#39;parser&#39;)))
        was indexed with:
        (2,)
        but does not have a subtree at:
        (2,)
        Index out of range.
        &gt;&gt;&gt; tf = test_fragments()
        &gt;&gt;&gt; print(tf[0][1])
        ([VP])
        &gt;&gt;&gt; print(tf[0][1, 0, 0]) # doctest: +IGNORE_EXCEPTION_DETAIL
        Traceback (most recent call last):
        IndexError: Index out of range. The Tree:
        ([VP])
        was indexed with:
        (0, 0)
        but does not have a subtree at:
        (0,)
        NonTerminal leaf-nodes cannot be indexed
        &gt;&gt;&gt; print(tf[0][0, 1])
        ([N]&#39;cat&#39;)
        &gt;&gt;&gt; print(tf[1][1, 0])
        ([V]&#39;ate&#39;)
        &gt;&gt;&gt; print(tf[1][1])
        ([VP]([V]&#39;ate&#39;)([NP]))
        &gt;&gt;&gt; print(tf[1][1, 1])
        ([NP])
        &gt;&gt;&gt; t2 = tree(&#34;([S]([PN]&#39;we&#39;)([VP]([V]&#39;ate&#39;)([NP]([Det]&#39;a&#39;)([NN]([Adj])([N]&#39;pie&#39;)))))&#34;)
        &gt;&gt;&gt; print(t2[1][1,1,2]) # doctest: +IGNORE_EXCEPTION_DETAIL
        Traceback (most recent call last):
        IndexError: Index out of range. The Tree:
        ([VP]([V]&#39;ate&#39;)([NP]([Det]&#39;a&#39;)([NN]([Adj])([N]&#39;pie&#39;))))
        was indexed with:
        (1, 1, 2)
        but does not have a subtree at:
        (1, 1, 2)
        Index out of range.
        &gt;&gt;&gt; print(t2[1][1,1,2,99]) # doctest: +IGNORE_EXCEPTION_DETAIL
        Traceback (most recent call last):
        IndexError: Index out of range. The Tree:
        ([VP]([V]&#39;ate&#39;)([NP]([Det]&#39;a&#39;)([NN]([Adj])([N]&#39;pie&#39;))))
        was indexed with:
        (1, 1, 2, 99)
        but does not have a subtree at:
        (1, 1, 2)
        Index out of range.
        &gt;&gt;&gt; print(t2[1][1,1,0,0]) # doctest: +IGNORE_EXCEPTION_DETAIL
        Traceback (most recent call last):
        IndexError: Index out of range. The Tree:
        ([VP]([V]&#39;ate&#39;)([NP]([Det]&#39;a&#39;)([NN]([Adj])([N]&#39;pie&#39;))))
        was indexed with:
        (1, 1, 0, 0)
        but does not have a subtree at:
        (1, 1, 0, 0)
        NonTerminal leaf-nodes cannot be indexed
        &gt;&gt;&gt; print(t2[1][1,1,1,1,0,0,1,2,3]) # doctest: +IGNORE_EXCEPTION_DETAIL
        Traceback (most recent call last):
        IndexError: Index out of range. The Tree:
        ([VP]([V]&#39;ate&#39;)([NP]([Det]&#39;a&#39;)([NN]([Adj])([N]&#39;pie&#39;))))
        was indexed with:
        (1, 1, 1, 1, 0, 0, 1, 2, 3)
        but does not have a subtree at:
        (1, 1, 1, 1, 0, 0)
        Terminals do not have child nodes.
        &#34;&#34;&#34;
        # If an int is given as index i, make it a singleton tuple
        if isinstance(position, int):
            position = (position,)
        # If the node has no children, or the index at the head of position is
        # out of range for the list self._children, the index points to a node
        # that doesn&#39;t exist, and an IndexError should be raised
        if position[0] &gt;= len(self) or position[0] &lt; -len(self):
            # if `position` is an `int`, convert it to a singleton `tuple`
            if type(position) == int:
                position = (position, )
            # `wrong` represents the tuple index up to the first point at which
            # it went wrong, which here means just the head of the tuple
            wrong = position[:1]
            # define an extra message to explain exactly how it went wrong...
            if self:
                # ... if self has children, but the index is out of range
                err = &#34;Index out of range.&#34;
            else:
                # ... or if self is a NonTerminal leaf-node, and hence
                # unindexible
                err = &#34;NonTerminal leaf-nodes cannot be indexed&#34;
            # Newlines are used to separate the elements of the error message,
            # so if this is a recursive call, the call above it can easily
            # modify the error message to show the tree the erroneous index was
            # originally called on, the complete index, and the complete &#39;wrong&#39;
            # path
            raise IndexError(
                f&#34;Index out of range. The Tree:\n{self}\nwas indexed with:\n&#34; +
                f&#34;{position}\nbut does not have a subtree at:\n{wrong}\n{err}&#34;
            )
        # This try block does the actual work of accessing children and
        # recursing down the tree if needed, but it needs the error-handling in
        # case the recursive call runs into an IndexError. The error message
        # will have, in the call at which the error was first raised, the string
        # representation of the node at which the error was raised, and values
        # of position and wrong based on the index used int *that* call.
        # However, the error message shown in the end should show the node the
        # original call was made on and the index-tuples called on that node -
        # the complete &#39;position&#39; and the tuple up to the error site, &#39;wrong&#39;
        try:
            # If a tuple of length 1, use the int in the tuple to index self&#39;s
            # list of children
            if len(position) == 1:
                return self._children[position[0]]
            # For all other lengths, use the head of the list to get the correct
            # child, then a recursive call using the tail as the index
            # Note that this:
            #     return self[position[0]][position[1:]]
            # would also work, but would make the call stack almost twice as
            # deep, so I decided against it
            else:
                return self._children[position[0]][position[1:]]
        except IndexError as e:
            # If a downstream call raises an IndexError, modify it to show the
            # error from the viewpoint of the current node, not the downstream
            # node that raised the error
            e_lines = str(e).split(&#34;\n&#34;)
            e_lines[1] = str(self)
            # e_lines[3] is the tuple index *up to* the point where it goes
            # wrong - including the *first* incorrect index but no more. It&#39;s
            # necessary here to just slip the head of the current index onto
            # the front here
            e_lines[3] = f&#34;({position[0]}, {e_lines[3][1:]}&#34;.replace(&#39;,)&#39;, &#39;)&#39;)
            e_lines[5] = f&#34;{position}&#34;
            # The `from None` here prevents the error being shown as a chain of
            # &#34;During handling of the above exception, another exception
            # occurred:&#34; messages
            raise IndexError(&#34;\n&#34;.join(e_lines)) from None



    def __setitem__(self, key, value):
        &#34;&#34;&#34;The children of a Tree can be set using `int` indices, with the i^th
        index setting the i^th child, except with Terminals, where the zeroth
        and only index sets the leaf value. Multiple indices can be provided,
        comma separated, to set a grandchild, great-grandchild, etc. However,
        the path from `self` to site at which `value` is to be inserted must
        go through existing tree-nodes only, otherwise an IndexError is raised.
        If the i^th child slot is not empty, the existing child will be
        replaced and deleted from the `Label`.

        Parameters
        ----------
        key : int
            The index at which the new child is to be placed
        value : Tree or None
            The new child of `self` at index `key`

        Raises
        ------
        IndexError:
            If key is not an int or tuple of ints, or is out of range
        AttributeError:
            If value is not a Tree

        &gt;&gt;&gt; tb = Treebank()
        &gt;&gt;&gt; t0 = tree(&#34;([S]([NP]([Det]&#39;the&#39;)([N]&#39;dog&#39;))([VP]))&#34;, treebank = tb)
        &gt;&gt;&gt; t1 = tree(&#34;([VP]([V]&#39;eats&#39;)([NP]))&#34;, treebank = tb)
        &gt;&gt;&gt; t2 = tree(&#34;([NP]([Det]&#39;the&#39;)([N]&#39;pie&#39;))&#34;, treebank = tb)
        &gt;&gt;&gt; t0[1] = t1
        &gt;&gt;&gt; t0
        tree(&#34;([S]([NP]([Det]&#39;the&#39;)([N]&#39;dog&#39;))([VP]([V]&#39;eats&#39;)([NP])))&#34;)
        &gt;&gt;&gt; t0[1].parent
        tree(&#34;([S]([NP]([Det]&#39;the&#39;)([N]&#39;dog&#39;))([VP]([V]&#39;eats&#39;)([NP])))&#34;)
        &gt;&gt;&gt; t0[1, 1] = t2
        &gt;&gt;&gt; t0
        tree(&#34;([S]([NP]([Det]&#39;the&#39;)([N]&#39;dog&#39;))([VP]([V]&#39;eats&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;pie&#39;))))&#34;)
        &gt;&gt;&gt; t0[1, 1].parent
        tree(&#34;([VP]([V]&#39;eats&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;pie&#39;)))&#34;)
        &#34;&#34;&#34;
        # First, make sure
        if type(key) != int and (type(key) != tuple or (type(key) == tuple and type(key[0]) != int)):
            raise IndexError(&#34;indices for Trees can only be ints or tuples of&#34; +
                f&#34; ints: you used a {type(key).__name__}&#34;)
        elif not isinstance(value, Tree) and not value is None:
            raise AttributeError(&#34;only Trees or None may be set as children &#34; +
                f&#34;of Trees: you used a {type(value).__name__}&#34;)
        elif type(key) == int or len(key) == 1:
            k = key if type(key) == int else key[0]
            try:
                if not self[k] is None:
                    self[k].delete(False)
                self.children[k] = value
                self.children[k].parent = self
            except IndexError:
                raise IndexError
        elif sum(type(k) != int for k in key):
            raise IndexError(
                f&#34;A tuple index must be a tuple of ints only.&#34;
            )
        else:
            try:
                # Uses the head of the key to identify the correct child, then
                # recursively call __setitem__ on the child using the tail.
                # Note that this:
                #     self[key[0]][key[1:]] = value
                # would also work, but would require almost twice many recursive
                # calls, so I decided against it
                self._children[key[0]][key[1:]] = value
            except IndexError as e:
                raise IndexError


    def copy_out(self, treebank = None):
        &#34;&#34;&#34;Generates a deep copy of a tree: the same structure, same Labels, and
        for the Terminals, same content: but each node a distinct object in
        memory from the corresponding node in the original. If a Treebank is
        passed to `treebank`, the new NonTerminal and its children will belong
        to `treebank`.

        If `treebank` is `None`, a new empty Treebank will be created, and the
        new NonTerminal will belong to that instead. This acts as a &#39;dummy
        treebank&#39;, in the case where trees are needed temporarily for some
        computation, without the overhead of storing them in an existing
        treebank.
        &#34;&#34;&#34;
        # If `treebank` is None...
        if not treebank:
            # create a dummy treebank, and then it won&#39;t be None
            treebank = Treebank()
        # Then create the copied NonTerminal, and recursively copy its children,
        # also to `treebank`: this means, if the function is called with
        # `treebank == None`, the whole tree-fragment will be copied to the same
        # dummy treebank.
        return NonTerminal(
            treebank,
            self.label if treebank == self.treebank else treebank.get_label(self.label.classname),
            *[c.copy_out(treebank) for c in self]
        )

    def get_leftmost_substition_site(self):
        &#34;&#34;&#34;
        Returns a SubstitutionSite object pointing to the leftmost non-terminal
        leaf-node: a non-terminal leaf node being a node that is capable of
        having children, but has none.

        Note that this has no counterpart in Terminal: it only makes sense to
        look for NonTerminal leaf nodes at or under NonTerminals

        Returns
        -------
        SubstitutionSite:
            An object containing the parent node of the leftmost nonterminal
            leafnode, the index in the parent at which the substitution site
            occurs, and the label at the substitution site

        &gt;&gt;&gt; t0 = tree(&#34;([S]([NP]([Det])([N]sentence))([VP]([V]parses)([NP]([Det]the)([N]parser))))&#34;)
        &gt;&gt;&gt; t1 = tree(&#34;([S]([NP]([Det])([N]sentence))([VP]([V]parses)([NP]([Det]the)([N]))))&#34;)
        &gt;&gt;&gt; t2 = tree(&#34;([S]([NP]([Det]the)([N]))([VP]([V]parses)([NP])))&#34;)
        &gt;&gt;&gt; t3 = tree(&#34;([S]([NP]([Det])([N]))([VP]([V])([NP]([Det])([N]))))&#34;)
        &gt;&gt;&gt; t4 = tree(&#34;([S]([NP])([VP]))&#34;)
        &gt;&gt;&gt; t5 = tree(&#34;([S]([NP]([Det]the)([N]sentence))([VP]([V]parses)([NP]([Det]the)([N]parser))))&#34;)
        &gt;&gt;&gt; for t in (t0, t1, t2, t3, t4, t5):
        ...     ss = t.get_leftmost_substition_site()
        ...     print(ss.site if ss else ss)
        ...
        ([Det])
        ([Det])
        ([N])
        ([Det])
        ([NP])
        None
        &#34;&#34;&#34;
        # It is assumed that this is not called directly on zero-depth
        # NonTerminals, but more usually on the root node of a tree
        for i, c in enumerate(self):
            # Don&#39;t bother checking any child that is a Terminal, we are only
            # interested in childless NonTerminals
            if not hasattr(c, &#39;leaf&#39;):
                if not hasattr(c, &#39;children&#39;) or not len(c.children):
                    # If the child is childless, it is a nonterminal leafnode,
                    # which we return immediately as the first one we find is
                    # the leftmost. The object returned, however, is not the
                    # node itself, but a dataclass object containing `self` (the
                    # parent of the substitution site), i, the index of the
                    # substitution site in self, and the label at the
                    # substitution site, as this determines what can be
                    # substituted there. SubstitutionSite also has a method
                    # which takes a subtree as an argument, and performs the
                    # substitution if the label matches
                    return SubstitutionSite(self, i, c.label)
                # otherwise, recursively call this function
                ss = c.get_leftmost_substition_site()
                # If a ss is found, return it. This function doesn&#39;t reach a
                # `return` line if no nonterminal leaf is found, so will return
                # `None`, meaning lnl will be None if no ss is found my the
                # recursive call, so the conditional won&#39;t be triggered
                if ss:
                    return ss

    def get_all_substitition_sites(self):
        &#34;&#34;&#34;
        Returns the all non-terminal leaf-node: a non-terminal leaf node
        being a node that is capable of having children, but has none.

        Note that this has no counterpart in Terminal: it only makes sense to
        look for NonTerminal leaf nodes at or under NonTerminals

        Returns
        -------
        list of SubstitutionSites:
            A list of dataclass objects containing the parent nodes of each
            nonterminal leafnode, its index in its parent, and its label.

        &gt;&gt;&gt; t0 = tree(&#34;([S]([NP]([Det])([N]sentence))([VP]([V]parses)([NP]([Det]the)([N]parser))))&#34;)
        &gt;&gt;&gt; t1 = tree(&#34;([S]([NP]([Det])([N]sentence))([VP]([V]parses)([NP]([Det]the)([N]))))&#34;)
        &gt;&gt;&gt; t2 = tree(&#34;([S]([NP]([Det]the)([N]))([VP]([V]parses)([NP])))&#34;)
        &gt;&gt;&gt; t3 = tree(&#34;([S]([NP]([Det])([N]))([VP]([V])([NP]([Det])([N]))))&#34;)
        &gt;&gt;&gt; t4 = tree(&#34;([S]([NP])([VP]))&#34;)
        &gt;&gt;&gt; t5 = tree(&#34;([S]([NP]([Det]the)([N]sentence))([VP]([V]parses)([NP]([Det]the)([N]parser))))&#34;)
        &gt;&gt;&gt; for t in (t0, t1, t2, t3, t4, t5):
        ...     print([s.site for s in t.get_all_substitition_sites()])
        ...
        [tree(&#34;([Det])&#34;)]
        [tree(&#34;([Det])&#34;), tree(&#34;([N])&#34;)]
        [tree(&#34;([N])&#34;), tree(&#34;([NP])&#34;)]
        [tree(&#34;([Det])&#34;), tree(&#34;([N])&#34;), tree(&#34;([V])&#34;), tree(&#34;([Det])&#34;), tree(&#34;([N])&#34;)]
        [tree(&#34;([NP])&#34;), tree(&#34;([VP])&#34;)]
        []
        &#34;&#34;&#34;
        # Initialise an empty list: try to put substitution sites in it, if
        # there are any, if not return it empty
        sites = []
        # It is assumed that this is not called directly on zero-depth
        # NonTerminals, but more usually on the root node of a tree.
        # Loop over the enumeration of self, as we will need the index of any
        # substitution site found
        for i, c in enumerate(self):
            # Ignore Terminals
            if not hasattr(c, &#39;leaf&#39;):
                # If a child is childess, it&#39;s a substitution site and can be
                # added to the list
                if not hasattr(c, &#39;children&#39;) or not len(c.children):
                    # The object returned, however, is not the
                    # node itself, but a dataclass object containing `self` (the
                    # parent of the substitution site), i, the index of the
                    # substitution site in self, and the label at the
                    # substitution site, as this determines what can be
                    # substituted there. SubstitutionSite also has a method
                    # which takes a subtree as an argument, and performs the
                    # substitution if the label matches
                    sites += [SubstitutionSite(self, i, c.label)]
                # Otherwise, recursively call on the child, and see if there are
                # any substitution sites further down the tree
                sites += c.get_all_substitition_sites()
        return sites

    def __iadd__(self, other):
        &#34;&#34;&#34;Magic method used for operator overloading on `+=`. Either an alias
        for strict_addition (substitution on the leftmost nonterminal leaf node
        only: throws error if Labels unmatched) if the `STRICT_ADDITION` class
        attribute is set to `True`; otherwise an alias for permissive_addition
        (substitution on leftmost Label-matched nonterminal leaf node: only
        throws an error if no matching nonterminal leaf node exists). `self`
        is modified in place, and the added children will belong to the same
        treebank as self.

        Returns
        -------
        Tree
            self

        Raises
        ------
        TypeError
            If the right operand is not a Tree

        &gt;&gt;&gt; dop3 = Treebank(operators = {&#34;&#34;: Operators.CONCAT})
        &gt;&gt;&gt; t0 = tree(&#34;([S]([PN]&#39;I&#39;)([VP]))&#34;, treebank = dop3)
        &gt;&gt;&gt; t1 = tree(&#34;([VP]([V]&#39;pet&#39;)([N]&#39;cats&#39;))&#34;, treebank = dop3)
        &gt;&gt;&gt; t0+=t1
        &gt;&gt;&gt; dop3.print_all_labels()
        ======================
        S:
        ([S]([PN]&#39;I&#39;)([VP]([V]&#39;pet&#39;)([N]&#39;cats&#39;)))
        ======================
        PN:
        ([PN]&#39;I&#39;)
        ======================
        VP:
        ([VP]([V]&#39;pet&#39;)([N]&#39;cats&#39;))
        ======================
        V:
        ([V]&#39;pet&#39;)
        ======================
        N:
        ([N]&#39;cats&#39;)
        ======================
        &#34;&#34;&#34;
        if not isinstance(other, Tree) :
            raise TypeError(
                f&#34;Cannot add a {type(other)} to a NonTerminal; you can &#34; +
                f&#34;only add another Tree.&#34;
            )
        return self.add_strict(other) if NonTerminal.STRICT_ADDITION else self.add_permissive(other)

    def __add__(self, other):
        &#34;&#34;&#34;Magic method used for operator overloading on `+`. Either an alias
        for strict_addition (substitution on the leftmost nonterminal leaf node
        only: throws error if Labels unmatched) if the `STRICT_ADDITION` class
        attribute is set to `True`; otherwise an alias for permissive_addition
        (substitution on leftmost Label-matched nonterminal leaf node: only
        throws an error if no matching nonterminal leaf node exists). `self`
        is copied into a dummy treebank, and the added children will belong to
        the same dummy treebank as `copy(self)`.

        Returns
        -------
        Tree :
            copy(self) with copy(other) substituted at leftmost (if STRICT) or
            leftmost matching (if PERMISSIVE) nonterminal leaf node.

        Raises
        ------
        TypeError
            If the right operand is not a Tree

        &gt;&gt;&gt; dop = Treebank(operators = {&#34;&#34;: Operators.CONCAT})
        &gt;&gt;&gt; t0 = tree(&#34;([S]([PN]&#39;I&#39;)([VP]))&#34;, treebank = dop)
        &gt;&gt;&gt; t1 = tree(&#34;([VP]([V]&#39;pet&#39;)([N]&#39;cats&#39;))&#34;, treebank = dop)
        &gt;&gt;&gt; dop.print_all_labels()
        ======================
        S:
        ([S]([PN]&#39;I&#39;)([VP]))
        ======================
        PN:
        ([PN]&#39;I&#39;)
        ======================
        VP:
        ([VP])
        ([VP]([V]&#39;pet&#39;)([N]&#39;cats&#39;))
        ======================
        V:
        ([V]&#39;pet&#39;)
        ======================
        N:
        ([N]&#39;cats&#39;)
        ======================
        &gt;&gt;&gt; t0 + t1
        tree(&#34;([S]([PN]&#39;I&#39;)([VP]([V]&#39;pet&#39;)([N]&#39;cats&#39;)))&#34;)
        &gt;&gt;&gt; dop.print_all_labels()
        ======================
        S:
        ([S]([PN]&#39;I&#39;)([VP]))
        ([S]([PN]&#39;I&#39;)([VP]([V]&#39;pet&#39;)([N]&#39;cats&#39;)))
        ======================
        PN:
        ([PN]&#39;I&#39;)
        ([PN]&#39;I&#39;)
        ======================
        VP:
        ([VP])
        ([VP]([V]&#39;pet&#39;)([N]&#39;cats&#39;))
        ([VP]([V]&#39;pet&#39;)([N]&#39;cats&#39;))
        ======================
        V:
        ([V]&#39;pet&#39;)
        ([V]&#39;pet&#39;)
        ======================
        N:
        ([N]&#39;cats&#39;)
        ([N]&#39;cats&#39;)
        ======================
        &#34;&#34;&#34;

        # copy self to dummy treebank
        cp = copy(self)
        # use __iadd__ to add `other`
        cp += copy(other)
        return cp

    def add_strict(self, other):
        &#34;&#34;&#34;Adds Trees t1 and t2 by substituting t2 for the leftmost non-terminal
        leaf-node of t1, iff they have the same label. Changes t1 in place, but
        copies children from t2; returns changed t1.

        Parameters
        ----------
        other : Tree
            `Terminal` or `Nonterminal` to be substituted.

        Returns
        -------
        self : `self`, changed in place.

        Raises
        ------
        ValueError
            If there is no nonterminal leafnode in `self`, or the leftmost
            nonterminal leafnode has a label that does not match the root label
            of `other`.

        &gt;&gt;&gt; tb = Treebank()
        &gt;&gt;&gt; t0 = tree(&#34;([S]([NP]([Det])([N]sentence))([VP]([V]parses)([NP]([Det]the)([N]parser))))&#34;, treebank = tb)
        &gt;&gt;&gt; t1 = tree(&#34;([S]([NP]([Det])([N]sentence))([VP]([V]parses)([NP]([Det]the)([N]))))&#34;, treebank = tb)
        &gt;&gt;&gt; t2 = tree(&#34;([S]([NP]([Det]the)([N]))([VP]([V]parses)([NP])))&#34;, treebank = tb)
        &gt;&gt;&gt; t3 = tree(&#34;([S]([NP]([Det])([N]))([VP]([V])([NP]([Det])([N]))))&#34;, treebank = tb)
        &gt;&gt;&gt; t4 = tree(&#34;([S]([NP])([VP]))&#34;, treebank = tb)
        &gt;&gt;&gt; t5 = tree(&#34;([S]([NP]([Det]the)([N]sentence))([VP]([V]parses)([NP]([Det]the)([N]parser))))&#34;, treebank = tb)
        &gt;&gt;&gt; det = tree(&#34;([Det]a)&#34;, treebank = tb)
        &gt;&gt;&gt; n = tree(&#34;([N]pudding)&#34;, treebank = tb)
        &gt;&gt;&gt; np = tree(&#34;([NP]([Det]the)([NN]([Adj]big)([N]banana)))&#34;, treebank = tb)
        &gt;&gt;&gt; v = tree(&#34;([V]badoinks)&#34;, treebank = tb)
        &gt;&gt;&gt; vp = tree(&#34;([VP]([VP]([V]is)([NP]([Det]your)([N]god)))([Adv]now))&#34;, treebank = tb)
        &gt;&gt;&gt; print(copy(t0+det))
        ([S]([NP]([Det]&#39;a&#39;)([N]&#39;sentence&#39;))([VP]([V]&#39;parses&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;parser&#39;))))
        &gt;&gt;&gt; print(copy(t1+det))
        ([S]([NP]([Det]&#39;a&#39;)([N]&#39;sentence&#39;))([VP]([V]&#39;parses&#39;)([NP]([Det]&#39;the&#39;)([N]))))
        &gt;&gt;&gt; print(copy(t1+n)) # doctest: +IGNORE_EXCEPTION_DETAIL
        Traceback (most recent call last):
        ValueError
        : Subtree ([N]pudding) with root label [N] cannot be substituted at index 1 of ([NP]([Det])([N]sentence)) due to a mismatch with substitution site label [Det].
        &gt;&gt;&gt; print(t1+det+n)
        ([S]([NP]([Det]&#39;a&#39;)([N]&#39;sentence&#39;))([VP]([V]&#39;parses&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;pudding&#39;))))
        &gt;&gt;&gt; print(t1+n+det) # doctest: +IGNORE_EXCEPTION_DETAIL
        Traceback (most recent call last):
        ValueError
        : &#34;Subtree ([N]pudding) with root label [N] cannot be substituted at index 0 of ([NP]([Det])([N]sentence)) due to a mismatch with substitution site label [Det].
        &gt;&gt;&gt; print(t2+n)
        ([S]([NP]([Det]&#39;the&#39;)([N]&#39;pudding&#39;))([VP]([V]&#39;parses&#39;)([NP])))
        &gt;&gt;&gt; print(t2+n+np)
        ([S]([NP]([Det]&#39;the&#39;)([N]&#39;pudding&#39;))([VP]([V]&#39;parses&#39;)([NP]([Det]&#39;the&#39;)([NN]([Adj]&#39;big&#39;)([N]&#39;banana&#39;)))))
        &gt;&gt;&gt; print(t3+det+n+v+det+n)
        ([S]([NP]([Det]&#39;a&#39;)([N]&#39;pudding&#39;))([VP]([V]&#39;badoinks&#39;)([NP]([Det]&#39;a&#39;)([N]&#39;pudding&#39;))))
        &gt;&gt;&gt; print(t4+np+vp)
        ([S]([NP]([Det]&#39;the&#39;)([NN]([Adj]&#39;big&#39;)([N]&#39;banana&#39;)))([VP]([VP]([V]&#39;is&#39;)([NP]([Det]&#39;your&#39;)([N]&#39;god&#39;)))([Adv]&#39;now&#39;)))
        &gt;&gt;&gt; print((t4+np+vp)())
        ((&#39;the&#39;, (&#39;big&#39;, &#39;banana&#39;)), ((&#39;is&#39;, (&#39;your&#39;, &#39;god&#39;)), &#39;now&#39;))
        &gt;&gt;&gt; print(t5+n) # doctest: +IGNORE_EXCEPTION_DETAIL
        Traceback (most recent call last):
        ValueError
        : Cannot add Trees t1 and t2; t1 has no non-terminal leaf-nodes
        &#34;&#34;&#34;
        # get leftmost nonterminal leaf node, if it exists. Note, the object
        # returned by get_leftmost_substition_site, however, is not the node
        # itself, but a dataclass object containing `self` (the parent of the
        # substitution site), i, the index of the substitution site in self, and
        # the label at the substitution site, as this determines what can be
        # substituted there.
        ss = self.get_leftmost_substition_site()
        if ss:
            # call method at SubstitutionSite which takes a subtree as an
            # argument, and performs the substitution if the label matches, or
            # raises an exception if it doesn&#39;t
            ss.perform_substitution(other)
            return self
        else:
            # If no substitution site found, raise error
            raise ValueError(
                f&#34;Cannot add Trees t1 and t2; t1 has no non-terminal leaf-nodes&#34;
            )

    def add_permissive(self, other):
        &#34;&#34;&#34;Adds Trees t1 and t2 by substituting t2 for the leftmost non-terminal
        leaf-node of t1, iff they have the same label. Changes t1 in place, but
        copies children from t2; returns changed t1.

        Parameters
        ----------
        other : Tree
            `Terminal` or `Nonterminal` to be substituted.

        Returns
        -------
        NonTerminal: `self`, changed in place.

        Raises
        ------
        ValueError
            If there is no nonterminal leafnode in `self` with a label that
            matches the root label of `other`.

        &gt;&gt;&gt; NonTerminal.STRICT_ADDITION = False
        &gt;&gt;&gt; t0 = tree(&#34;([S]([NP]([Det])([N]sentence))([VP]([V]parses)([NP]([Det]the)([N]parser))))&#34;)
        &gt;&gt;&gt; t1 = tree(&#34;([S]([NP]([Det])([N]sentence))([VP]([V]parses)([NP]([Det]the)([N]))))&#34;)
        &gt;&gt;&gt; t2 = tree(&#34;([S]([NP]([Det]the)([N]))([VP]([V]parses)([NP])))&#34;)
        &gt;&gt;&gt; t3 = tree(&#34;([S]([NP]([Det])([N]))([VP]([V])([NP]([Det])([N]))))&#34;)
        &gt;&gt;&gt; t4 = tree(&#34;([S]([NP])([VP]))&#34;)
        &gt;&gt;&gt; t5 = tree(&#34;([S]([NP]([Det]the)([N]sentence))([VP]([V]parses)([NP]([Det]the)([N]parser))))&#34;)
        &gt;&gt;&gt; det = tree(&#34;([Det]a)&#34;)
        &gt;&gt;&gt; n = tree(&#34;([N]pudding)&#34;)
        &gt;&gt;&gt; np = tree(&#34;([NP]([Det]the)([NN]([Adj]big)([N]banana)))&#34;)
        &gt;&gt;&gt; v = tree(&#34;([V]badoinks)&#34;)
        &gt;&gt;&gt; vp = tree(&#34;([VP]([VP]([V]is)([NP]([Det]your)([N]god)))([Adv]now))&#34;)
        &gt;&gt;&gt; print(copy(t0+det))
        ([S]([NP]([Det]&#39;a&#39;)([N]&#39;sentence&#39;))([VP]([V]&#39;parses&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;parser&#39;))))
        &gt;&gt;&gt; print(copy(t1+det))
        ([S]([NP]([Det]&#39;a&#39;)([N]&#39;sentence&#39;))([VP]([V]&#39;parses&#39;)([NP]([Det]&#39;the&#39;)([N]))))
        &gt;&gt;&gt; print(copy(t1)+copy(n))
        ([S]([NP]([Det])([N]&#39;sentence&#39;))([VP]([V]&#39;parses&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;pudding&#39;))))
        &gt;&gt;&gt; print(copy(t1)+copy(det)+copy(n))
        ([S]([NP]([Det]&#39;a&#39;)([N]&#39;sentence&#39;))([VP]([V]&#39;parses&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;pudding&#39;))))
        &gt;&gt;&gt; print(copy(t1)+copy(n)+copy(det))
        ([S]([NP]([Det]&#39;a&#39;)([N]&#39;sentence&#39;))([VP]([V]&#39;parses&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;pudding&#39;))))
        &gt;&gt;&gt; print(copy(t2)+copy(n))
        ([S]([NP]([Det]&#39;the&#39;)([N]&#39;pudding&#39;))([VP]([V]&#39;parses&#39;)([NP])))
        &gt;&gt;&gt; print(copy(t2)+copy(n)+copy(np))
        ([S]([NP]([Det]&#39;the&#39;)([N]&#39;pudding&#39;))([VP]([V]&#39;parses&#39;)([NP]([Det]&#39;the&#39;)([NN]([Adj]&#39;big&#39;)([N]&#39;banana&#39;)))))
        &gt;&gt;&gt; print(copy(t3)+copy(det)+copy(n)+copy(v)+copy(det)+copy(n))
        ([S]([NP]([Det]&#39;a&#39;)([N]&#39;pudding&#39;))([VP]([V]&#39;badoinks&#39;)([NP]([Det]&#39;a&#39;)([N]&#39;pudding&#39;))))
        &gt;&gt;&gt; print(copy(t4)+copy(np)+copy(vp))
        ([S]([NP]([Det]&#39;the&#39;)([NN]([Adj]&#39;big&#39;)([N]&#39;banana&#39;)))([VP]([VP]([V]&#39;is&#39;)([NP]([Det]&#39;your&#39;)([N]&#39;god&#39;)))([Adv]&#39;now&#39;)))
        &gt;&gt;&gt; print((copy(t4)+copy(np)+copy(vp))())
        ((&#39;the&#39;, (&#39;big&#39;, &#39;banana&#39;)), ((&#39;is&#39;, (&#39;your&#39;, &#39;god&#39;)), &#39;now&#39;))
        &gt;&gt;&gt; print(copy(t5)+copy(n)) # doctest: +IGNORE_EXCEPTION_DETAIL
        Traceback (most recent call last):
        ValueError
        : Cannot add Trees t1 &lt;([S]([NP]([Det]&#39;the&#39;)([N]&#39;sentence&#39;))([VP]([V]&#39;parses&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;parser&#39;))))&gt; and t2 &lt;([N]&#39;pudding&#39;)&gt;; Cannot add Trees t1 &amp; t2; t1 has no nonterminal leafnodes
        &gt;&gt;&gt; print(copy(t0)+tree(&#34;([IDEK]asdfg)&#34;)) # doctest: +IGNORE_EXCEPTION_DETAIL
        Traceback (most recent call last):
        ValueError
        : Cannot add Trees t1 &lt;([S]([NP]([Det])([N]&#39;sentence&#39;))([VP]([V]&#39;parses&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;parser&#39;))))&gt; and t2 &lt;([IDEK]&#39;asdfg&#39;)&gt;; no nonterminal leafnode of t1 matches the root label of t2
        &gt;&gt;&gt; NonTerminal.STRICT_ADDITION = True # Put these back where I found them, or other tests get broken
        &#34;&#34;&#34;
        # Get list of all substitution sites. Note, the objects
        # returned by get_all_substitition_sites, however, are not the nodes
        # themselve, but dataclass objects containing the parent of the
        # substitution site, i, the index of the substitution site in the
        # parent, and the label at the substitution site, as this determines
        # what can be substituted there.
        subsites = self.get_all_substitition_sites()
        # Search the list for the first site matching the label of the subtree
        for ss in subsites:
            # If/when found ...
            if ss.label.classname == other.label.classname:
                # call method at SubstitutionSite which takes a subtree as an
                # argument, and performs the substitution if the label matches.
                # Go on to the next is it doesn&#39;t and...
                ss.perform_substitution(other.copy_out(self.treebank))
                return self
        else:
            # ...if no suitable node is found, raise error:
            raise ValueError(
                f&#34;Cannot add Trees t1 ({self}) and t2 ({other}); &#34; +
                (
                    &#34;no nonterminal leafnode of t1 matches the root label of t2&#34;
                    if subsites else
                    &#34;Cannot add Trees t1 &amp; t2; t1 has no nonterminal leafnodes&#34;
                )
            )

    def __call__(self):
        &#34;&#34;&#34;Magic method that makes NonTerminals Callable: but really it&#39;s just
        calling label (Labels are also callable), which is just calling an
        Operator (also also callable).
        &#34;&#34;&#34;
        return self.label(*[c() for c in self])

    def index_of(self, child: Tree, descendants=False, strict=True) -&gt; (int, Tuple[int]):
        &#34;&#34;&#34;Takes a child node and returns its position in the `NonTerminal`&#39;s
        children, or, if `descendants` is True, it&#39;s descendants. If a `Tree`
        is passed to `child` that is not a child/descendant of `self`, returns
        the empty `tuple` if not `strict`, otherwise raises a `ValueError`.

        Parameters
        ----------
        child : Tree
            The `Tree` we are looking for.
        descendants : bool
            If `True`, search all the descendants of `self`, otherwise, just
            search its children. False by default.
        strict : bool
            If `True`, raises a ValueError if the child is not found: otherwise
            returns `()`.

        Returns
        -------
        int or tuple of ints
            Index. If `descendants` is `False` and `strict` is `True`, returns
            the index of `child` in `self` as an `int`: otherwise, it returns a
            tuple, giving the path from `self` to `child` - which is empty if
            there is no path and `strict` is false.

        Raises
        ------
        ValueError
            If `child` is not found and `strict` is `True`.

        &gt;&gt;&gt; tb = Treebank()
        &gt;&gt;&gt; tree0 = tree(&#34;([S]([NP]([PN]&#39;she&#39;))([VP]([V]&#39;saw&#39;)([S]([NP]([NP]([Det]&#39;the&#39;)([N]&#39;dog&#39;))([PP]([Prep]&#39;with&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;telescope&#39;))))([VP]([V]&#39;observing&#39;)([NP]([PN]&#39;neptune&#39;))))))&#34;, treebank = tb)
        &gt;&gt;&gt; tree1 = tree(&#34;([NP]([Det]&#39;the&#39;)([N]&#39;dog&#39;))&#34;, treebank = tb)
        &gt;&gt;&gt; tree2 = tree0[1,1,0,0]
        &gt;&gt;&gt; for i, t in enumerate(tree0):
        ...     print(i == tree0.index_of(t))
        True
        True
        &gt;&gt;&gt; tree0.index_of(tree2, True, False)
        (1, 1, 0, 0)
        &gt;&gt;&gt; tree0.index_of(tree1, True, False)
        ()
        &gt;&gt;&gt; tree0.index_of(tree2, False, False)
        ()
        &gt;&gt;&gt; tree0.index_of(tree1, False, False)
        ()
        &gt;&gt;&gt; tree0.index_of(tree2, True, True)
        (1, 1, 0, 0)
        &gt;&gt;&gt; tree0.index_of(tree1, True, True) # doctest: +IGNORE_EXCEPTION_DETAIL
        Traceback (most recent call last):
        ValueError: Descendant not found
        &gt;&gt;&gt; tree0.index_of(tree2, False, True) # doctest: +IGNORE_EXCEPTION_DETAIL
        Traceback (most recent call last):
        ValueError: Child not found
        &gt;&gt;&gt; tree0.index_of(tree1, False, True) # doctest: +IGNORE_EXCEPTION_DETAIL
        Traceback (most recent call last):
        ValueError: Child not found
        &#34;&#34;&#34;
        # if we are looking through the entire tree...
        # (note that in this condition all our indices are tuples, indicating a
        # path through the tree.
        if descendants:
            # ...then first, consider the case where the child we&#39;re looking for
            # is the direct child of self. In this case we can avoid code
            # duplication by calling index_of again, but this time taking the
            # !descendants branch. strict is false in the index_of call below,
            # even if the originating call is strict, because if we don&#39;t find
            # child in the children of self, we don&#39;t want to raise an
            # exception until we know it&#39;s not in the grandchildren, great-
            # grandchildren, etc. Because strict is false, we know that if child
            # is found by this call, it will return a tuple, which is what we
            # want
            idx = self.index_of(child, strict=False)
            # idx is either a singleton tuple (child is a child of self) or
            # empty. If singleton...
            if len(idx):
                # ...return it: otherwise...
                return idx
            else:
                # ...we need to look further down the tree. Loop with enumerate
                # because we need the index, in case the child is found. Since
                # we&#39;re using &#39;child&#39; for the Tree we&#39;re looking for, we&#39;ll use
                # &#39;kid&#39; for the actual children of self
                for i, kid in enumerate(self):
                    # Terminals don&#39;t have children, so the search is only
                    # continued if kid is a NonTerminal...
                    if isinstance(kid, NonTerminal):
                        # ...again, a recursive call is wanted here, but this
                        # time with `descendants` set to true: strict is still
                        # set to false in the recursive call: if the originating
                        # call is strict, this loop will complete without
                        # returning, in which case the following code will
                        # either return empty or raise ValueError.
                        idx = kid.index_of(child, True, False)
                        # If idx is not empty, child was found in the
                        # descendants of &#39;kid&#39; at the tuple index at kid[*idx]:
                        # e.g., if (2,0,1) is returned, child == kid[2,0,1], so
                        # ...
                        if len(idx):
                            # given that kid == self[i], child == self[i, *idx],
                            # e.g., if kid = self[1] and child == kid[2,0,1],
                            # then child = self[1,2,0,1]
                            return (i,) + idx
                # If the function call is still running here, no child was found
                # and the proper behaviour is determined by whether `strict`.
                if not strict:
                    return ()
                else:
                    # The error specifies descendant since the function searched
                    # the descendants, not just thie children of self
                    raise ValueError(&#34;Descendant not found&#34;)
        # If not `descendants`, things are simpler. However, note that this is
        # the only branch of the function code that searches directly in the
        # children of a NonTerminal for a child: the descendant-searching
        # branch uses a call to this branch to check for immediate children.
        else:
            # Note that we are looking specifically for a child that is
            # *identical* to `child`, not just equal: however, the list.index()
            # function uses equality. Therefore, we convert `child`...
            ch_id = id(child)
            # ...and the list of children to ids
            k_ids = [id(k) for k in self._children]
            # if child&#39;s id is found in the list of the kids ids...
            if ch_id in k_ids:
                # ...then get the index it was found at...
                idx = k_ids.index(ch_id)
                # ...so return it, either as an int or a singleton tuple.
                return idx if strict else (idx,)
            # Otherwise, the child isn&#39;t found, and the appropriate response is
            # determined by `strict`.
            elif not strict:
                return ()
            else:
                raise ValueError(&#34;Child not found&#34;)

    def delete(self, _top = True):
        &#34;&#34;&#34;Completely removes the NonTerminal from the treebank, along with all
        its descendants. Just to make sure the GC gets what needs to be got, as
        well as deleting all references to the tree in the Labels, it also
        typically (_fill_leaf = False) removes all references held by the nodes
        of the tree to each other. However, the default behaviour of the
        function

        Parameters
        ----------
        _fill_leaf : bool
            If `True`, will cause the parent node of `self` to fill `self&#39;s`
            position in the list of children with an non-terminal leaf node (a
            `NonTerminal` with no children). This is the default value, but is
            set to false when `delete` recursively calls itself on the chidren
            of `self`

        &gt;&gt;&gt; tb = Treebank()
        &gt;&gt;&gt; tb.print_all_labels()
        ======================
        &gt;&gt;&gt; tree0 = tree(&#34;([S]([NP]([PN]&#39;she&#39;))([VP]([V]&#39;saw&#39;)([S]([NP]([NP]([Det]&#39;the&#39;)([N]&#39;dog&#39;))([PP]([Prep]&#39;with&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;telescope&#39;))))([VP]([V]&#39;observing&#39;)([NP]([PN]&#39;neptune&#39;))))))&#34;, treebank = tb)
        &gt;&gt;&gt; tb.print_all_labels()
        ======================
        S:
        ([S]([NP]([NP]([Det]&#39;the&#39;)([N]&#39;dog&#39;))([PP]([Prep]&#39;with&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;telescope&#39;))))([VP]([V]&#39;observing&#39;)([NP]([PN]&#39;neptune&#39;))))
        ([S]([NP]([PN]&#39;she&#39;))([VP]([V]&#39;saw&#39;)([S]([NP]([NP]([Det]&#39;the&#39;)([N]&#39;dog&#39;))([PP]([Prep]&#39;with&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;telescope&#39;))))([VP]([V]&#39;observing&#39;)([NP]([PN]&#39;neptune&#39;))))))
        ======================
        NP:
        ([NP]([PN]&#39;she&#39;))
        ([NP]([Det]&#39;the&#39;)([N]&#39;dog&#39;))
        ([NP]([Det]&#39;the&#39;)([N]&#39;telescope&#39;))
        ([NP]([NP]([Det]&#39;the&#39;)([N]&#39;dog&#39;))([PP]([Prep]&#39;with&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;telescope&#39;))))
        ([NP]([PN]&#39;neptune&#39;))
        ======================
        PN:
        ([PN]&#39;she&#39;)
        ([PN]&#39;neptune&#39;)
        ======================
        VP:
        ([VP]([V]&#39;observing&#39;)([NP]([PN]&#39;neptune&#39;)))
        ([VP]([V]&#39;saw&#39;)([S]([NP]([NP]([Det]&#39;the&#39;)([N]&#39;dog&#39;))([PP]([Prep]&#39;with&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;telescope&#39;))))([VP]([V]&#39;observing&#39;)([NP]([PN]&#39;neptune&#39;)))))
        ======================
        V:
        ([V]&#39;saw&#39;)
        ([V]&#39;observing&#39;)
        ======================
        Det:
        ([Det]&#39;the&#39;)
        ([Det]&#39;the&#39;)
        ======================
        N:
        ([N]&#39;dog&#39;)
        ([N]&#39;telescope&#39;)
        ======================
        PP:
        ([PP]([Prep]&#39;with&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;telescope&#39;)))
        ======================
        Prep:
        ([Prep]&#39;with&#39;)
        ======================
        &gt;&gt;&gt; tree0[0].delete()
        &gt;&gt;&gt; tree0
        tree(&#34;([S]([NP])([VP]([V]&#39;saw&#39;)([S]([NP]([NP]([Det]&#39;the&#39;)([N]&#39;dog&#39;))([PP]([Prep]&#39;with&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;telescope&#39;))))([VP]([V]&#39;observing&#39;)([NP]([PN]&#39;neptune&#39;))))))&#34;)
        &gt;&gt;&gt; tb.print_all_labels()
        ======================
        S:
        ([S]([NP]([NP]([Det]&#39;the&#39;)([N]&#39;dog&#39;))([PP]([Prep]&#39;with&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;telescope&#39;))))([VP]([V]&#39;observing&#39;)([NP]([PN]&#39;neptune&#39;))))
        ([S]([NP])([VP]([V]&#39;saw&#39;)([S]([NP]([NP]([Det]&#39;the&#39;)([N]&#39;dog&#39;))([PP]([Prep]&#39;with&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;telescope&#39;))))([VP]([V]&#39;observing&#39;)([NP]([PN]&#39;neptune&#39;))))))
        ======================
        NP:
        ([NP]([Det]&#39;the&#39;)([N]&#39;dog&#39;))
        ([NP]([Det]&#39;the&#39;)([N]&#39;telescope&#39;))
        ([NP]([NP]([Det]&#39;the&#39;)([N]&#39;dog&#39;))([PP]([Prep]&#39;with&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;telescope&#39;))))
        ([NP]([PN]&#39;neptune&#39;))
        ([NP])
        ======================
        PN:
        ([PN]&#39;neptune&#39;)
        ======================
        VP:
        ([VP]([V]&#39;observing&#39;)([NP]([PN]&#39;neptune&#39;)))
        ([VP]([V]&#39;saw&#39;)([S]([NP]([NP]([Det]&#39;the&#39;)([N]&#39;dog&#39;))([PP]([Prep]&#39;with&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;telescope&#39;))))([VP]([V]&#39;observing&#39;)([NP]([PN]&#39;neptune&#39;)))))
        ======================
        V:
        ([V]&#39;saw&#39;)
        ([V]&#39;observing&#39;)
        ======================
        Det:
        ([Det]&#39;the&#39;)
        ([Det]&#39;the&#39;)
        ======================
        N:
        ([N]&#39;dog&#39;)
        ([N]&#39;telescope&#39;)
        ======================
        PP:
        ([PP]([Prep]&#39;with&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;telescope&#39;)))
        ======================
        Prep:
        ([Prep]&#39;with&#39;)
        ======================
        &gt;&gt;&gt; tree0[1,1,1].delete()
        &gt;&gt;&gt; tree0
        tree(&#34;([S]([NP])([VP]([V]&#39;saw&#39;)([S]([NP]([NP]([Det]&#39;the&#39;)([N]&#39;dog&#39;))([PP]([Prep]&#39;with&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;telescope&#39;))))([VP]))))&#34;)
        &gt;&gt;&gt; tb.print_all_labels()
        ======================
        S:
        ([S]([NP]([NP]([Det]&#39;the&#39;)([N]&#39;dog&#39;))([PP]([Prep]&#39;with&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;telescope&#39;))))([VP]))
        ([S]([NP])([VP]([V]&#39;saw&#39;)([S]([NP]([NP]([Det]&#39;the&#39;)([N]&#39;dog&#39;))([PP]([Prep]&#39;with&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;telescope&#39;))))([VP]))))
        ======================
        NP:
        ([NP]([Det]&#39;the&#39;)([N]&#39;dog&#39;))
        ([NP]([Det]&#39;the&#39;)([N]&#39;telescope&#39;))
        ([NP]([NP]([Det]&#39;the&#39;)([N]&#39;dog&#39;))([PP]([Prep]&#39;with&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;telescope&#39;))))
        ([NP])
        ======================
        PN:
        ======================
        VP:
        ([VP]([V]&#39;saw&#39;)([S]([NP]([NP]([Det]&#39;the&#39;)([N]&#39;dog&#39;))([PP]([Prep]&#39;with&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;telescope&#39;))))([VP])))
        ([VP])
        ======================
        V:
        ([V]&#39;saw&#39;)
        ======================
        Det:
        ([Det]&#39;the&#39;)
        ([Det]&#39;the&#39;)
        ======================
        N:
        ([N]&#39;dog&#39;)
        ([N]&#39;telescope&#39;)
        ======================
        PP:
        ([PP]([Prep]&#39;with&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;telescope&#39;)))
        ======================
        Prep:
        ([Prep]&#39;with&#39;)
        ======================
        &gt;&gt;&gt; tree0[1,1].delete()
        &gt;&gt;&gt; tree0
        tree(&#34;([S]([NP])([VP]([V]&#39;saw&#39;)([S])))&#34;)
        &gt;&gt;&gt; tb.print_all_labels()
        ======================
        S:
        ([S]([NP])([VP]([V]&#39;saw&#39;)([S])))
        ([S])
        ======================
        NP:
        ([NP])
        ======================
        PN:
        ======================
        VP:
        ([VP]([V]&#39;saw&#39;)([S]))
        ======================
        V:
        ([V]&#39;saw&#39;)
        ======================
        Det:
        ======================
        N:
        ======================
        PP:
        ======================
        Prep:
        ======================
        &gt;&gt;&gt; tree0.delete()
        &gt;&gt;&gt; tb.print_all_labels()
        ======================
        S:
        ======================
        NP:
        ======================
        PN:
        ======================
        VP:
        ======================
        V:
        ======================
        Det:
        ======================
        N:
        ======================
        PP:
        ======================
        Prep:
        ======================
        &#34;&#34;&#34;
        for child in self:
            child.delete(False)
        if self.parent:
            if _top:
                self.parent.children[self.parent.index_of(self)] = NonTerminal(
                    self.treebank, self.label
                )
            else:
                self.parent.children[self.parent.index_of(self)] = None
            self.parent = None
        # Note that Label.remove_node() also removes the Label from the node,
        # so no need to do that here
        self.label.remove_node(self)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="trees.Tree" href="#trees.Tree">Tree</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="trees.NonTerminal.STRICT_ADDITION"><code class="name">var <span class="ident">STRICT_ADDITION</span></code></dt>
<dd>
<div class="desc"><p>bool: If True, the <code>+</code> operator does leftmost nonterminal substitution,
which throws an error if the liftmost nonterminal leaf node label of the
left operand does not match the root label of the right operand; if False it
substitutes the right operand into the leftmost matching nonterminal
leafnode, and raises an error only if there is no match.</p></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="trees.NonTerminal.children"><code class="name">var <span class="ident">children</span></code></dt>
<dd>
<div class="desc"><p>Getter for the children attribute</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def children(self):
    &#34;&#34;&#34;Getter for the children attribute&#34;&#34;&#34;
    return self._children</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="trees.NonTerminal.add_permissive"><code class="name flex">
<span>def <span class="ident">add_permissive</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds Trees t1 and t2 by substituting t2 for the leftmost non-terminal
leaf-node of t1, iff they have the same label. Changes t1 in place, but
copies children from t2; returns changed t1.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>other</code></strong> :&ensp;<code><a title="trees.Tree" href="#trees.Tree">Tree</a></code></dt>
<dd><code><a title="trees.Terminal" href="#trees.Terminal">Terminal</a></code> or <code>Nonterminal</code> to be substituted.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>NonTerminal: <code>self</code>, changed in place.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If there is no nonterminal leafnode in <code>self</code> with a label that
matches the root label of <code>other</code>.</dd>
</dl>
<pre><code class="language-python-repl">&gt;&gt;&gt; NonTerminal.STRICT_ADDITION = False
&gt;&gt;&gt; t0 = tree(&quot;([S]([NP]([Det])([N]sentence))([VP]([V]parses)([NP]([Det]the)([N]parser))))&quot;)
&gt;&gt;&gt; t1 = tree(&quot;([S]([NP]([Det])([N]sentence))([VP]([V]parses)([NP]([Det]the)([N]))))&quot;)
&gt;&gt;&gt; t2 = tree(&quot;([S]([NP]([Det]the)([N]))([VP]([V]parses)([NP])))&quot;)
&gt;&gt;&gt; t3 = tree(&quot;([S]([NP]([Det])([N]))([VP]([V])([NP]([Det])([N]))))&quot;)
&gt;&gt;&gt; t4 = tree(&quot;([S]([NP])([VP]))&quot;)
&gt;&gt;&gt; t5 = tree(&quot;([S]([NP]([Det]the)([N]sentence))([VP]([V]parses)([NP]([Det]the)([N]parser))))&quot;)
&gt;&gt;&gt; det = tree(&quot;([Det]a)&quot;)
&gt;&gt;&gt; n = tree(&quot;([N]pudding)&quot;)
&gt;&gt;&gt; np = tree(&quot;([NP]([Det]the)([NN]([Adj]big)([N]banana)))&quot;)
&gt;&gt;&gt; v = tree(&quot;([V]badoinks)&quot;)
&gt;&gt;&gt; vp = tree(&quot;([VP]([VP]([V]is)([NP]([Det]your)([N]god)))([Adv]now))&quot;)
&gt;&gt;&gt; print(copy(t0+det))
([S]([NP]([Det]'a')([N]'sentence'))([VP]([V]'parses')([NP]([Det]'the')([N]'parser'))))
&gt;&gt;&gt; print(copy(t1+det))
([S]([NP]([Det]'a')([N]'sentence'))([VP]([V]'parses')([NP]([Det]'the')([N]))))
&gt;&gt;&gt; print(copy(t1)+copy(n))
([S]([NP]([Det])([N]'sentence'))([VP]([V]'parses')([NP]([Det]'the')([N]'pudding'))))
&gt;&gt;&gt; print(copy(t1)+copy(det)+copy(n))
([S]([NP]([Det]'a')([N]'sentence'))([VP]([V]'parses')([NP]([Det]'the')([N]'pudding'))))
&gt;&gt;&gt; print(copy(t1)+copy(n)+copy(det))
([S]([NP]([Det]'a')([N]'sentence'))([VP]([V]'parses')([NP]([Det]'the')([N]'pudding'))))
&gt;&gt;&gt; print(copy(t2)+copy(n))
([S]([NP]([Det]'the')([N]'pudding'))([VP]([V]'parses')([NP])))
&gt;&gt;&gt; print(copy(t2)+copy(n)+copy(np))
([S]([NP]([Det]'the')([N]'pudding'))([VP]([V]'parses')([NP]([Det]'the')([NN]([Adj]'big')([N]'banana')))))
&gt;&gt;&gt; print(copy(t3)+copy(det)+copy(n)+copy(v)+copy(det)+copy(n))
([S]([NP]([Det]'a')([N]'pudding'))([VP]([V]'badoinks')([NP]([Det]'a')([N]'pudding'))))
&gt;&gt;&gt; print(copy(t4)+copy(np)+copy(vp))
([S]([NP]([Det]'the')([NN]([Adj]'big')([N]'banana')))([VP]([VP]([V]'is')([NP]([Det]'your')([N]'god')))([Adv]'now')))
&gt;&gt;&gt; print((copy(t4)+copy(np)+copy(vp))())
(('the', ('big', 'banana')), (('is', ('your', 'god')), 'now'))
&gt;&gt;&gt; print(copy(t5)+copy(n)) # doctest: +IGNORE_EXCEPTION_DETAIL
`Traceback (most recent call last):`
:   &amp;nbsp;


&lt;code&gt;ValueError&lt;/code&gt;
:   &amp;nbsp;


: Cannot add Trees t1 &lt;([S]([NP]([Det]'the')([N]'sentence'))([VP]([V]'parses')([NP]([Det]'the')([N]'parser'))))&gt; and t2 &lt;([N]'pudding')&gt;; Cannot add Trees t1 &amp; t2; t1 has no nonterminal leafnodes
&gt;&gt;&gt; print(copy(t0)+tree(&quot;([IDEK]asdfg)&quot;)) # doctest: +IGNORE_EXCEPTION_DETAIL
`Traceback (most recent call last):`
:   &amp;nbsp;


&lt;code&gt;ValueError&lt;/code&gt;
:   &amp;nbsp;


: Cannot add Trees t1 &lt;([S]([NP]([Det])([N]'sentence'))([VP]([V]'parses')([NP]([Det]'the')([N]'parser'))))&gt; and t2 &lt;([IDEK]'asdfg')&gt;; no nonterminal leafnode of t1 matches the root label of t2
&gt;&gt;&gt; NonTerminal.STRICT_ADDITION = True # Put these back where I found them, or other tests get broken
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_permissive(self, other):
    &#34;&#34;&#34;Adds Trees t1 and t2 by substituting t2 for the leftmost non-terminal
    leaf-node of t1, iff they have the same label. Changes t1 in place, but
    copies children from t2; returns changed t1.

    Parameters
    ----------
    other : Tree
        `Terminal` or `Nonterminal` to be substituted.

    Returns
    -------
    NonTerminal: `self`, changed in place.

    Raises
    ------
    ValueError
        If there is no nonterminal leafnode in `self` with a label that
        matches the root label of `other`.

    &gt;&gt;&gt; NonTerminal.STRICT_ADDITION = False
    &gt;&gt;&gt; t0 = tree(&#34;([S]([NP]([Det])([N]sentence))([VP]([V]parses)([NP]([Det]the)([N]parser))))&#34;)
    &gt;&gt;&gt; t1 = tree(&#34;([S]([NP]([Det])([N]sentence))([VP]([V]parses)([NP]([Det]the)([N]))))&#34;)
    &gt;&gt;&gt; t2 = tree(&#34;([S]([NP]([Det]the)([N]))([VP]([V]parses)([NP])))&#34;)
    &gt;&gt;&gt; t3 = tree(&#34;([S]([NP]([Det])([N]))([VP]([V])([NP]([Det])([N]))))&#34;)
    &gt;&gt;&gt; t4 = tree(&#34;([S]([NP])([VP]))&#34;)
    &gt;&gt;&gt; t5 = tree(&#34;([S]([NP]([Det]the)([N]sentence))([VP]([V]parses)([NP]([Det]the)([N]parser))))&#34;)
    &gt;&gt;&gt; det = tree(&#34;([Det]a)&#34;)
    &gt;&gt;&gt; n = tree(&#34;([N]pudding)&#34;)
    &gt;&gt;&gt; np = tree(&#34;([NP]([Det]the)([NN]([Adj]big)([N]banana)))&#34;)
    &gt;&gt;&gt; v = tree(&#34;([V]badoinks)&#34;)
    &gt;&gt;&gt; vp = tree(&#34;([VP]([VP]([V]is)([NP]([Det]your)([N]god)))([Adv]now))&#34;)
    &gt;&gt;&gt; print(copy(t0+det))
    ([S]([NP]([Det]&#39;a&#39;)([N]&#39;sentence&#39;))([VP]([V]&#39;parses&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;parser&#39;))))
    &gt;&gt;&gt; print(copy(t1+det))
    ([S]([NP]([Det]&#39;a&#39;)([N]&#39;sentence&#39;))([VP]([V]&#39;parses&#39;)([NP]([Det]&#39;the&#39;)([N]))))
    &gt;&gt;&gt; print(copy(t1)+copy(n))
    ([S]([NP]([Det])([N]&#39;sentence&#39;))([VP]([V]&#39;parses&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;pudding&#39;))))
    &gt;&gt;&gt; print(copy(t1)+copy(det)+copy(n))
    ([S]([NP]([Det]&#39;a&#39;)([N]&#39;sentence&#39;))([VP]([V]&#39;parses&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;pudding&#39;))))
    &gt;&gt;&gt; print(copy(t1)+copy(n)+copy(det))
    ([S]([NP]([Det]&#39;a&#39;)([N]&#39;sentence&#39;))([VP]([V]&#39;parses&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;pudding&#39;))))
    &gt;&gt;&gt; print(copy(t2)+copy(n))
    ([S]([NP]([Det]&#39;the&#39;)([N]&#39;pudding&#39;))([VP]([V]&#39;parses&#39;)([NP])))
    &gt;&gt;&gt; print(copy(t2)+copy(n)+copy(np))
    ([S]([NP]([Det]&#39;the&#39;)([N]&#39;pudding&#39;))([VP]([V]&#39;parses&#39;)([NP]([Det]&#39;the&#39;)([NN]([Adj]&#39;big&#39;)([N]&#39;banana&#39;)))))
    &gt;&gt;&gt; print(copy(t3)+copy(det)+copy(n)+copy(v)+copy(det)+copy(n))
    ([S]([NP]([Det]&#39;a&#39;)([N]&#39;pudding&#39;))([VP]([V]&#39;badoinks&#39;)([NP]([Det]&#39;a&#39;)([N]&#39;pudding&#39;))))
    &gt;&gt;&gt; print(copy(t4)+copy(np)+copy(vp))
    ([S]([NP]([Det]&#39;the&#39;)([NN]([Adj]&#39;big&#39;)([N]&#39;banana&#39;)))([VP]([VP]([V]&#39;is&#39;)([NP]([Det]&#39;your&#39;)([N]&#39;god&#39;)))([Adv]&#39;now&#39;)))
    &gt;&gt;&gt; print((copy(t4)+copy(np)+copy(vp))())
    ((&#39;the&#39;, (&#39;big&#39;, &#39;banana&#39;)), ((&#39;is&#39;, (&#39;your&#39;, &#39;god&#39;)), &#39;now&#39;))
    &gt;&gt;&gt; print(copy(t5)+copy(n)) # doctest: +IGNORE_EXCEPTION_DETAIL
    Traceback (most recent call last):
    ValueError
    : Cannot add Trees t1 &lt;([S]([NP]([Det]&#39;the&#39;)([N]&#39;sentence&#39;))([VP]([V]&#39;parses&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;parser&#39;))))&gt; and t2 &lt;([N]&#39;pudding&#39;)&gt;; Cannot add Trees t1 &amp; t2; t1 has no nonterminal leafnodes
    &gt;&gt;&gt; print(copy(t0)+tree(&#34;([IDEK]asdfg)&#34;)) # doctest: +IGNORE_EXCEPTION_DETAIL
    Traceback (most recent call last):
    ValueError
    : Cannot add Trees t1 &lt;([S]([NP]([Det])([N]&#39;sentence&#39;))([VP]([V]&#39;parses&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;parser&#39;))))&gt; and t2 &lt;([IDEK]&#39;asdfg&#39;)&gt;; no nonterminal leafnode of t1 matches the root label of t2
    &gt;&gt;&gt; NonTerminal.STRICT_ADDITION = True # Put these back where I found them, or other tests get broken
    &#34;&#34;&#34;
    # Get list of all substitution sites. Note, the objects
    # returned by get_all_substitition_sites, however, are not the nodes
    # themselve, but dataclass objects containing the parent of the
    # substitution site, i, the index of the substitution site in the
    # parent, and the label at the substitution site, as this determines
    # what can be substituted there.
    subsites = self.get_all_substitition_sites()
    # Search the list for the first site matching the label of the subtree
    for ss in subsites:
        # If/when found ...
        if ss.label.classname == other.label.classname:
            # call method at SubstitutionSite which takes a subtree as an
            # argument, and performs the substitution if the label matches.
            # Go on to the next is it doesn&#39;t and...
            ss.perform_substitution(other.copy_out(self.treebank))
            return self
    else:
        # ...if no suitable node is found, raise error:
        raise ValueError(
            f&#34;Cannot add Trees t1 ({self}) and t2 ({other}); &#34; +
            (
                &#34;no nonterminal leafnode of t1 matches the root label of t2&#34;
                if subsites else
                &#34;Cannot add Trees t1 &amp; t2; t1 has no nonterminal leafnodes&#34;
            )
        )</code></pre>
</details>
</dd>
<dt id="trees.NonTerminal.add_strict"><code class="name flex">
<span>def <span class="ident">add_strict</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds Trees t1 and t2 by substituting t2 for the leftmost non-terminal
leaf-node of t1, iff they have the same label. Changes t1 in place, but
copies children from t2; returns changed t1.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>other</code></strong> :&ensp;<code><a title="trees.Tree" href="#trees.Tree">Tree</a></code></dt>
<dd><code><a title="trees.Terminal" href="#trees.Terminal">Terminal</a></code> or <code>Nonterminal</code> to be substituted.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>self : <code>self</code>, changed in place.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If there is no nonterminal leafnode in <code>self</code>, or the leftmost
nonterminal leafnode has a label that does not match the root label
of <code>other</code>.</dd>
</dl>
<pre><code class="language-python-repl">&gt;&gt;&gt; tb = Treebank()
&gt;&gt;&gt; t0 = tree(&quot;([S]([NP]([Det])([N]sentence))([VP]([V]parses)([NP]([Det]the)([N]parser))))&quot;, treebank = tb)
&gt;&gt;&gt; t1 = tree(&quot;([S]([NP]([Det])([N]sentence))([VP]([V]parses)([NP]([Det]the)([N]))))&quot;, treebank = tb)
&gt;&gt;&gt; t2 = tree(&quot;([S]([NP]([Det]the)([N]))([VP]([V]parses)([NP])))&quot;, treebank = tb)
&gt;&gt;&gt; t3 = tree(&quot;([S]([NP]([Det])([N]))([VP]([V])([NP]([Det])([N]))))&quot;, treebank = tb)
&gt;&gt;&gt; t4 = tree(&quot;([S]([NP])([VP]))&quot;, treebank = tb)
&gt;&gt;&gt; t5 = tree(&quot;([S]([NP]([Det]the)([N]sentence))([VP]([V]parses)([NP]([Det]the)([N]parser))))&quot;, treebank = tb)
&gt;&gt;&gt; det = tree(&quot;([Det]a)&quot;, treebank = tb)
&gt;&gt;&gt; n = tree(&quot;([N]pudding)&quot;, treebank = tb)
&gt;&gt;&gt; np = tree(&quot;([NP]([Det]the)([NN]([Adj]big)([N]banana)))&quot;, treebank = tb)
&gt;&gt;&gt; v = tree(&quot;([V]badoinks)&quot;, treebank = tb)
&gt;&gt;&gt; vp = tree(&quot;([VP]([VP]([V]is)([NP]([Det]your)([N]god)))([Adv]now))&quot;, treebank = tb)
&gt;&gt;&gt; print(copy(t0+det))
([S]([NP]([Det]'a')([N]'sentence'))([VP]([V]'parses')([NP]([Det]'the')([N]'parser'))))
&gt;&gt;&gt; print(copy(t1+det))
([S]([NP]([Det]'a')([N]'sentence'))([VP]([V]'parses')([NP]([Det]'the')([N]))))
&gt;&gt;&gt; print(copy(t1+n)) # doctest: +IGNORE_EXCEPTION_DETAIL
`Traceback (most recent call last):`
:   &amp;nbsp;


&lt;code&gt;ValueError&lt;/code&gt;
:   &amp;nbsp;


: Subtree ([N]pudding) with root label [N] cannot be substituted at index 1 of ([NP]([Det])([N]sentence)) due to a mismatch with substitution site label [Det].
&gt;&gt;&gt; print(t1+det+n)
([S]([NP]([Det]'a')([N]'sentence'))([VP]([V]'parses')([NP]([Det]'the')([N]'pudding'))))
&gt;&gt;&gt; print(t1+n+det) # doctest: +IGNORE_EXCEPTION_DETAIL
`Traceback (most recent call last):`
:   &amp;nbsp;


&lt;code&gt;ValueError&lt;/code&gt;
:   &amp;nbsp;


: &quot;Subtree ([N]pudding) with root label [N] cannot be substituted at index 0 of ([NP]([Det])([N]sentence)) due to a mismatch with substitution site label [Det].
&gt;&gt;&gt; print(t2+n)
([S]([NP]([Det]'the')([N]'pudding'))([VP]([V]'parses')([NP])))
&gt;&gt;&gt; print(t2+n+np)
([S]([NP]([Det]'the')([N]'pudding'))([VP]([V]'parses')([NP]([Det]'the')([NN]([Adj]'big')([N]'banana')))))
&gt;&gt;&gt; print(t3+det+n+v+det+n)
([S]([NP]([Det]'a')([N]'pudding'))([VP]([V]'badoinks')([NP]([Det]'a')([N]'pudding'))))
&gt;&gt;&gt; print(t4+np+vp)
([S]([NP]([Det]'the')([NN]([Adj]'big')([N]'banana')))([VP]([VP]([V]'is')([NP]([Det]'your')([N]'god')))([Adv]'now')))
&gt;&gt;&gt; print((t4+np+vp)())
(('the', ('big', 'banana')), (('is', ('your', 'god')), 'now'))
&gt;&gt;&gt; print(t5+n) # doctest: +IGNORE_EXCEPTION_DETAIL
`Traceback (most recent call last):`
:   &amp;nbsp;


&lt;code&gt;ValueError&lt;/code&gt;
:   &amp;nbsp;


: Cannot add Trees t1 and t2; t1 has no non-terminal leaf-nodes
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_strict(self, other):
    &#34;&#34;&#34;Adds Trees t1 and t2 by substituting t2 for the leftmost non-terminal
    leaf-node of t1, iff they have the same label. Changes t1 in place, but
    copies children from t2; returns changed t1.

    Parameters
    ----------
    other : Tree
        `Terminal` or `Nonterminal` to be substituted.

    Returns
    -------
    self : `self`, changed in place.

    Raises
    ------
    ValueError
        If there is no nonterminal leafnode in `self`, or the leftmost
        nonterminal leafnode has a label that does not match the root label
        of `other`.

    &gt;&gt;&gt; tb = Treebank()
    &gt;&gt;&gt; t0 = tree(&#34;([S]([NP]([Det])([N]sentence))([VP]([V]parses)([NP]([Det]the)([N]parser))))&#34;, treebank = tb)
    &gt;&gt;&gt; t1 = tree(&#34;([S]([NP]([Det])([N]sentence))([VP]([V]parses)([NP]([Det]the)([N]))))&#34;, treebank = tb)
    &gt;&gt;&gt; t2 = tree(&#34;([S]([NP]([Det]the)([N]))([VP]([V]parses)([NP])))&#34;, treebank = tb)
    &gt;&gt;&gt; t3 = tree(&#34;([S]([NP]([Det])([N]))([VP]([V])([NP]([Det])([N]))))&#34;, treebank = tb)
    &gt;&gt;&gt; t4 = tree(&#34;([S]([NP])([VP]))&#34;, treebank = tb)
    &gt;&gt;&gt; t5 = tree(&#34;([S]([NP]([Det]the)([N]sentence))([VP]([V]parses)([NP]([Det]the)([N]parser))))&#34;, treebank = tb)
    &gt;&gt;&gt; det = tree(&#34;([Det]a)&#34;, treebank = tb)
    &gt;&gt;&gt; n = tree(&#34;([N]pudding)&#34;, treebank = tb)
    &gt;&gt;&gt; np = tree(&#34;([NP]([Det]the)([NN]([Adj]big)([N]banana)))&#34;, treebank = tb)
    &gt;&gt;&gt; v = tree(&#34;([V]badoinks)&#34;, treebank = tb)
    &gt;&gt;&gt; vp = tree(&#34;([VP]([VP]([V]is)([NP]([Det]your)([N]god)))([Adv]now))&#34;, treebank = tb)
    &gt;&gt;&gt; print(copy(t0+det))
    ([S]([NP]([Det]&#39;a&#39;)([N]&#39;sentence&#39;))([VP]([V]&#39;parses&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;parser&#39;))))
    &gt;&gt;&gt; print(copy(t1+det))
    ([S]([NP]([Det]&#39;a&#39;)([N]&#39;sentence&#39;))([VP]([V]&#39;parses&#39;)([NP]([Det]&#39;the&#39;)([N]))))
    &gt;&gt;&gt; print(copy(t1+n)) # doctest: +IGNORE_EXCEPTION_DETAIL
    Traceback (most recent call last):
    ValueError
    : Subtree ([N]pudding) with root label [N] cannot be substituted at index 1 of ([NP]([Det])([N]sentence)) due to a mismatch with substitution site label [Det].
    &gt;&gt;&gt; print(t1+det+n)
    ([S]([NP]([Det]&#39;a&#39;)([N]&#39;sentence&#39;))([VP]([V]&#39;parses&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;pudding&#39;))))
    &gt;&gt;&gt; print(t1+n+det) # doctest: +IGNORE_EXCEPTION_DETAIL
    Traceback (most recent call last):
    ValueError
    : &#34;Subtree ([N]pudding) with root label [N] cannot be substituted at index 0 of ([NP]([Det])([N]sentence)) due to a mismatch with substitution site label [Det].
    &gt;&gt;&gt; print(t2+n)
    ([S]([NP]([Det]&#39;the&#39;)([N]&#39;pudding&#39;))([VP]([V]&#39;parses&#39;)([NP])))
    &gt;&gt;&gt; print(t2+n+np)
    ([S]([NP]([Det]&#39;the&#39;)([N]&#39;pudding&#39;))([VP]([V]&#39;parses&#39;)([NP]([Det]&#39;the&#39;)([NN]([Adj]&#39;big&#39;)([N]&#39;banana&#39;)))))
    &gt;&gt;&gt; print(t3+det+n+v+det+n)
    ([S]([NP]([Det]&#39;a&#39;)([N]&#39;pudding&#39;))([VP]([V]&#39;badoinks&#39;)([NP]([Det]&#39;a&#39;)([N]&#39;pudding&#39;))))
    &gt;&gt;&gt; print(t4+np+vp)
    ([S]([NP]([Det]&#39;the&#39;)([NN]([Adj]&#39;big&#39;)([N]&#39;banana&#39;)))([VP]([VP]([V]&#39;is&#39;)([NP]([Det]&#39;your&#39;)([N]&#39;god&#39;)))([Adv]&#39;now&#39;)))
    &gt;&gt;&gt; print((t4+np+vp)())
    ((&#39;the&#39;, (&#39;big&#39;, &#39;banana&#39;)), ((&#39;is&#39;, (&#39;your&#39;, &#39;god&#39;)), &#39;now&#39;))
    &gt;&gt;&gt; print(t5+n) # doctest: +IGNORE_EXCEPTION_DETAIL
    Traceback (most recent call last):
    ValueError
    : Cannot add Trees t1 and t2; t1 has no non-terminal leaf-nodes
    &#34;&#34;&#34;
    # get leftmost nonterminal leaf node, if it exists. Note, the object
    # returned by get_leftmost_substition_site, however, is not the node
    # itself, but a dataclass object containing `self` (the parent of the
    # substitution site), i, the index of the substitution site in self, and
    # the label at the substitution site, as this determines what can be
    # substituted there.
    ss = self.get_leftmost_substition_site()
    if ss:
        # call method at SubstitutionSite which takes a subtree as an
        # argument, and performs the substitution if the label matches, or
        # raises an exception if it doesn&#39;t
        ss.perform_substitution(other)
        return self
    else:
        # If no substitution site found, raise error
        raise ValueError(
            f&#34;Cannot add Trees t1 and t2; t1 has no non-terminal leaf-nodes&#34;
        )</code></pre>
</details>
</dd>
<dt id="trees.NonTerminal.copy_out"><code class="name flex">
<span>def <span class="ident">copy_out</span></span>(<span>self, treebank=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates a deep copy of a tree: the same structure, same Labels, and
for the Terminals, same content: but each node a distinct object in
memory from the corresponding node in the original. If a Treebank is
passed to <code>treebank</code>, the new NonTerminal and its children will belong
to <code>treebank</code>.</p>
<p>If <code>treebank</code> is <code>None</code>, a new empty Treebank will be created, and the
new NonTerminal will belong to that instead. This acts as a 'dummy
treebank', in the case where trees are needed temporarily for some
computation, without the overhead of storing them in an existing
treebank.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy_out(self, treebank = None):
    &#34;&#34;&#34;Generates a deep copy of a tree: the same structure, same Labels, and
    for the Terminals, same content: but each node a distinct object in
    memory from the corresponding node in the original. If a Treebank is
    passed to `treebank`, the new NonTerminal and its children will belong
    to `treebank`.

    If `treebank` is `None`, a new empty Treebank will be created, and the
    new NonTerminal will belong to that instead. This acts as a &#39;dummy
    treebank&#39;, in the case where trees are needed temporarily for some
    computation, without the overhead of storing them in an existing
    treebank.
    &#34;&#34;&#34;
    # If `treebank` is None...
    if not treebank:
        # create a dummy treebank, and then it won&#39;t be None
        treebank = Treebank()
    # Then create the copied NonTerminal, and recursively copy its children,
    # also to `treebank`: this means, if the function is called with
    # `treebank == None`, the whole tree-fragment will be copied to the same
    # dummy treebank.
    return NonTerminal(
        treebank,
        self.label if treebank == self.treebank else treebank.get_label(self.label.classname),
        *[c.copy_out(treebank) for c in self]
    )</code></pre>
</details>
</dd>
<dt id="trees.NonTerminal.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Completely removes the NonTerminal from the treebank, along with all
its descendants. Just to make sure the GC gets what needs to be got, as
well as deleting all references to the tree in the Labels, it also
typically (_fill_leaf = False) removes all references held by the nodes
of the tree to each other. However, the default behaviour of the
function</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>_fill_leaf</code></strong> :&ensp;<code>bool</code></dt>
<dd>If <code>True</code>, will cause the parent node of <code>self</code> to fill <code>self's</code>
position in the list of children with an non-terminal leaf node (a
<code><a title="trees.NonTerminal" href="#trees.NonTerminal">NonTerminal</a></code> with no children). This is the default value, but is
set to false when <code>delete</code> recursively calls itself on the chidren
of <code>self</code></dd>
</dl>
<pre><code class="language-python-repl">&gt;&gt;&gt; tb = Treebank()
&gt;&gt;&gt; tb.print_all_labels()
======================
&gt;&gt;&gt; tree0 = tree(&quot;([S]([NP]([PN]'she'))([VP]([V]'saw')([S]([NP]([NP]([Det]'the')([N]'dog'))([PP]([Prep]'with')([NP]([Det]'the')([N]'telescope'))))([VP]([V]'observing')([NP]([PN]'neptune'))))))&quot;, treebank = tb)
&gt;&gt;&gt; tb.print_all_labels()
======================
S:
([S]([NP]([NP]([Det]'the')([N]'dog'))([PP]([Prep]'with')([NP]([Det]'the')([N]'telescope'))))([VP]([V]'observing')([NP]([PN]'neptune'))))
([S]([NP]([PN]'she'))([VP]([V]'saw')([S]([NP]([NP]([Det]'the')([N]'dog'))([PP]([Prep]'with')([NP]([Det]'the')([N]'telescope'))))([VP]([V]'observing')([NP]([PN]'neptune'))))))
======================
NP:
([NP]([PN]'she'))
([NP]([Det]'the')([N]'dog'))
([NP]([Det]'the')([N]'telescope'))
([NP]([NP]([Det]'the')([N]'dog'))([PP]([Prep]'with')([NP]([Det]'the')([N]'telescope'))))
([NP]([PN]'neptune'))
======================
PN:
([PN]'she')
([PN]'neptune')
======================
VP:
([VP]([V]'observing')([NP]([PN]'neptune')))
([VP]([V]'saw')([S]([NP]([NP]([Det]'the')([N]'dog'))([PP]([Prep]'with')([NP]([Det]'the')([N]'telescope'))))([VP]([V]'observing')([NP]([PN]'neptune')))))
======================
V:
([V]'saw')
([V]'observing')
======================
Det:
([Det]'the')
([Det]'the')
======================
N:
([N]'dog')
([N]'telescope')
======================
PP:
([PP]([Prep]'with')([NP]([Det]'the')([N]'telescope')))
======================
Prep:
([Prep]'with')
======================
&gt;&gt;&gt; tree0[0].delete()
&gt;&gt;&gt; tree0
tree(&quot;([S]([NP])([VP]([V]'saw')([S]([NP]([NP]([Det]'the')([N]'dog'))([PP]([Prep]'with')([NP]([Det]'the')([N]'telescope'))))([VP]([V]'observing')([NP]([PN]'neptune'))))))&quot;)
&gt;&gt;&gt; tb.print_all_labels()
======================
S:
([S]([NP]([NP]([Det]'the')([N]'dog'))([PP]([Prep]'with')([NP]([Det]'the')([N]'telescope'))))([VP]([V]'observing')([NP]([PN]'neptune'))))
([S]([NP])([VP]([V]'saw')([S]([NP]([NP]([Det]'the')([N]'dog'))([PP]([Prep]'with')([NP]([Det]'the')([N]'telescope'))))([VP]([V]'observing')([NP]([PN]'neptune'))))))
======================
NP:
([NP]([Det]'the')([N]'dog'))
([NP]([Det]'the')([N]'telescope'))
([NP]([NP]([Det]'the')([N]'dog'))([PP]([Prep]'with')([NP]([Det]'the')([N]'telescope'))))
([NP]([PN]'neptune'))
([NP])
======================
PN:
([PN]'neptune')
======================
VP:
([VP]([V]'observing')([NP]([PN]'neptune')))
([VP]([V]'saw')([S]([NP]([NP]([Det]'the')([N]'dog'))([PP]([Prep]'with')([NP]([Det]'the')([N]'telescope'))))([VP]([V]'observing')([NP]([PN]'neptune')))))
======================
V:
([V]'saw')
([V]'observing')
======================
Det:
([Det]'the')
([Det]'the')
======================
N:
([N]'dog')
([N]'telescope')
======================
PP:
([PP]([Prep]'with')([NP]([Det]'the')([N]'telescope')))
======================
Prep:
([Prep]'with')
======================
&gt;&gt;&gt; tree0[1,1,1].delete()
&gt;&gt;&gt; tree0
tree(&quot;([S]([NP])([VP]([V]'saw')([S]([NP]([NP]([Det]'the')([N]'dog'))([PP]([Prep]'with')([NP]([Det]'the')([N]'telescope'))))([VP]))))&quot;)
&gt;&gt;&gt; tb.print_all_labels()
======================
S:
([S]([NP]([NP]([Det]'the')([N]'dog'))([PP]([Prep]'with')([NP]([Det]'the')([N]'telescope'))))([VP]))
([S]([NP])([VP]([V]'saw')([S]([NP]([NP]([Det]'the')([N]'dog'))([PP]([Prep]'with')([NP]([Det]'the')([N]'telescope'))))([VP]))))
======================
NP:
([NP]([Det]'the')([N]'dog'))
([NP]([Det]'the')([N]'telescope'))
([NP]([NP]([Det]'the')([N]'dog'))([PP]([Prep]'with')([NP]([Det]'the')([N]'telescope'))))
([NP])
======================
PN:
======================
VP:
([VP]([V]'saw')([S]([NP]([NP]([Det]'the')([N]'dog'))([PP]([Prep]'with')([NP]([Det]'the')([N]'telescope'))))([VP])))
([VP])
======================
V:
([V]'saw')
======================
Det:
([Det]'the')
([Det]'the')
======================
N:
([N]'dog')
([N]'telescope')
======================
PP:
([PP]([Prep]'with')([NP]([Det]'the')([N]'telescope')))
======================
Prep:
([Prep]'with')
======================
&gt;&gt;&gt; tree0[1,1].delete()
&gt;&gt;&gt; tree0
tree(&quot;([S]([NP])([VP]([V]'saw')([S])))&quot;)
&gt;&gt;&gt; tb.print_all_labels()
======================
S:
([S]([NP])([VP]([V]'saw')([S])))
([S])
======================
NP:
([NP])
======================
PN:
======================
VP:
([VP]([V]'saw')([S]))
======================
V:
([V]'saw')
======================
Det:
======================
N:
======================
PP:
======================
Prep:
======================
&gt;&gt;&gt; tree0.delete()
&gt;&gt;&gt; tb.print_all_labels()
======================
S:
======================
NP:
======================
PN:
======================
VP:
======================
V:
======================
Det:
======================
N:
======================
PP:
======================
Prep:
======================
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete(self, _top = True):
    &#34;&#34;&#34;Completely removes the NonTerminal from the treebank, along with all
    its descendants. Just to make sure the GC gets what needs to be got, as
    well as deleting all references to the tree in the Labels, it also
    typically (_fill_leaf = False) removes all references held by the nodes
    of the tree to each other. However, the default behaviour of the
    function

    Parameters
    ----------
    _fill_leaf : bool
        If `True`, will cause the parent node of `self` to fill `self&#39;s`
        position in the list of children with an non-terminal leaf node (a
        `NonTerminal` with no children). This is the default value, but is
        set to false when `delete` recursively calls itself on the chidren
        of `self`

    &gt;&gt;&gt; tb = Treebank()
    &gt;&gt;&gt; tb.print_all_labels()
    ======================
    &gt;&gt;&gt; tree0 = tree(&#34;([S]([NP]([PN]&#39;she&#39;))([VP]([V]&#39;saw&#39;)([S]([NP]([NP]([Det]&#39;the&#39;)([N]&#39;dog&#39;))([PP]([Prep]&#39;with&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;telescope&#39;))))([VP]([V]&#39;observing&#39;)([NP]([PN]&#39;neptune&#39;))))))&#34;, treebank = tb)
    &gt;&gt;&gt; tb.print_all_labels()
    ======================
    S:
    ([S]([NP]([NP]([Det]&#39;the&#39;)([N]&#39;dog&#39;))([PP]([Prep]&#39;with&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;telescope&#39;))))([VP]([V]&#39;observing&#39;)([NP]([PN]&#39;neptune&#39;))))
    ([S]([NP]([PN]&#39;she&#39;))([VP]([V]&#39;saw&#39;)([S]([NP]([NP]([Det]&#39;the&#39;)([N]&#39;dog&#39;))([PP]([Prep]&#39;with&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;telescope&#39;))))([VP]([V]&#39;observing&#39;)([NP]([PN]&#39;neptune&#39;))))))
    ======================
    NP:
    ([NP]([PN]&#39;she&#39;))
    ([NP]([Det]&#39;the&#39;)([N]&#39;dog&#39;))
    ([NP]([Det]&#39;the&#39;)([N]&#39;telescope&#39;))
    ([NP]([NP]([Det]&#39;the&#39;)([N]&#39;dog&#39;))([PP]([Prep]&#39;with&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;telescope&#39;))))
    ([NP]([PN]&#39;neptune&#39;))
    ======================
    PN:
    ([PN]&#39;she&#39;)
    ([PN]&#39;neptune&#39;)
    ======================
    VP:
    ([VP]([V]&#39;observing&#39;)([NP]([PN]&#39;neptune&#39;)))
    ([VP]([V]&#39;saw&#39;)([S]([NP]([NP]([Det]&#39;the&#39;)([N]&#39;dog&#39;))([PP]([Prep]&#39;with&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;telescope&#39;))))([VP]([V]&#39;observing&#39;)([NP]([PN]&#39;neptune&#39;)))))
    ======================
    V:
    ([V]&#39;saw&#39;)
    ([V]&#39;observing&#39;)
    ======================
    Det:
    ([Det]&#39;the&#39;)
    ([Det]&#39;the&#39;)
    ======================
    N:
    ([N]&#39;dog&#39;)
    ([N]&#39;telescope&#39;)
    ======================
    PP:
    ([PP]([Prep]&#39;with&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;telescope&#39;)))
    ======================
    Prep:
    ([Prep]&#39;with&#39;)
    ======================
    &gt;&gt;&gt; tree0[0].delete()
    &gt;&gt;&gt; tree0
    tree(&#34;([S]([NP])([VP]([V]&#39;saw&#39;)([S]([NP]([NP]([Det]&#39;the&#39;)([N]&#39;dog&#39;))([PP]([Prep]&#39;with&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;telescope&#39;))))([VP]([V]&#39;observing&#39;)([NP]([PN]&#39;neptune&#39;))))))&#34;)
    &gt;&gt;&gt; tb.print_all_labels()
    ======================
    S:
    ([S]([NP]([NP]([Det]&#39;the&#39;)([N]&#39;dog&#39;))([PP]([Prep]&#39;with&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;telescope&#39;))))([VP]([V]&#39;observing&#39;)([NP]([PN]&#39;neptune&#39;))))
    ([S]([NP])([VP]([V]&#39;saw&#39;)([S]([NP]([NP]([Det]&#39;the&#39;)([N]&#39;dog&#39;))([PP]([Prep]&#39;with&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;telescope&#39;))))([VP]([V]&#39;observing&#39;)([NP]([PN]&#39;neptune&#39;))))))
    ======================
    NP:
    ([NP]([Det]&#39;the&#39;)([N]&#39;dog&#39;))
    ([NP]([Det]&#39;the&#39;)([N]&#39;telescope&#39;))
    ([NP]([NP]([Det]&#39;the&#39;)([N]&#39;dog&#39;))([PP]([Prep]&#39;with&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;telescope&#39;))))
    ([NP]([PN]&#39;neptune&#39;))
    ([NP])
    ======================
    PN:
    ([PN]&#39;neptune&#39;)
    ======================
    VP:
    ([VP]([V]&#39;observing&#39;)([NP]([PN]&#39;neptune&#39;)))
    ([VP]([V]&#39;saw&#39;)([S]([NP]([NP]([Det]&#39;the&#39;)([N]&#39;dog&#39;))([PP]([Prep]&#39;with&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;telescope&#39;))))([VP]([V]&#39;observing&#39;)([NP]([PN]&#39;neptune&#39;)))))
    ======================
    V:
    ([V]&#39;saw&#39;)
    ([V]&#39;observing&#39;)
    ======================
    Det:
    ([Det]&#39;the&#39;)
    ([Det]&#39;the&#39;)
    ======================
    N:
    ([N]&#39;dog&#39;)
    ([N]&#39;telescope&#39;)
    ======================
    PP:
    ([PP]([Prep]&#39;with&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;telescope&#39;)))
    ======================
    Prep:
    ([Prep]&#39;with&#39;)
    ======================
    &gt;&gt;&gt; tree0[1,1,1].delete()
    &gt;&gt;&gt; tree0
    tree(&#34;([S]([NP])([VP]([V]&#39;saw&#39;)([S]([NP]([NP]([Det]&#39;the&#39;)([N]&#39;dog&#39;))([PP]([Prep]&#39;with&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;telescope&#39;))))([VP]))))&#34;)
    &gt;&gt;&gt; tb.print_all_labels()
    ======================
    S:
    ([S]([NP]([NP]([Det]&#39;the&#39;)([N]&#39;dog&#39;))([PP]([Prep]&#39;with&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;telescope&#39;))))([VP]))
    ([S]([NP])([VP]([V]&#39;saw&#39;)([S]([NP]([NP]([Det]&#39;the&#39;)([N]&#39;dog&#39;))([PP]([Prep]&#39;with&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;telescope&#39;))))([VP]))))
    ======================
    NP:
    ([NP]([Det]&#39;the&#39;)([N]&#39;dog&#39;))
    ([NP]([Det]&#39;the&#39;)([N]&#39;telescope&#39;))
    ([NP]([NP]([Det]&#39;the&#39;)([N]&#39;dog&#39;))([PP]([Prep]&#39;with&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;telescope&#39;))))
    ([NP])
    ======================
    PN:
    ======================
    VP:
    ([VP]([V]&#39;saw&#39;)([S]([NP]([NP]([Det]&#39;the&#39;)([N]&#39;dog&#39;))([PP]([Prep]&#39;with&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;telescope&#39;))))([VP])))
    ([VP])
    ======================
    V:
    ([V]&#39;saw&#39;)
    ======================
    Det:
    ([Det]&#39;the&#39;)
    ([Det]&#39;the&#39;)
    ======================
    N:
    ([N]&#39;dog&#39;)
    ([N]&#39;telescope&#39;)
    ======================
    PP:
    ([PP]([Prep]&#39;with&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;telescope&#39;)))
    ======================
    Prep:
    ([Prep]&#39;with&#39;)
    ======================
    &gt;&gt;&gt; tree0[1,1].delete()
    &gt;&gt;&gt; tree0
    tree(&#34;([S]([NP])([VP]([V]&#39;saw&#39;)([S])))&#34;)
    &gt;&gt;&gt; tb.print_all_labels()
    ======================
    S:
    ([S]([NP])([VP]([V]&#39;saw&#39;)([S])))
    ([S])
    ======================
    NP:
    ([NP])
    ======================
    PN:
    ======================
    VP:
    ([VP]([V]&#39;saw&#39;)([S]))
    ======================
    V:
    ([V]&#39;saw&#39;)
    ======================
    Det:
    ======================
    N:
    ======================
    PP:
    ======================
    Prep:
    ======================
    &gt;&gt;&gt; tree0.delete()
    &gt;&gt;&gt; tb.print_all_labels()
    ======================
    S:
    ======================
    NP:
    ======================
    PN:
    ======================
    VP:
    ======================
    V:
    ======================
    Det:
    ======================
    N:
    ======================
    PP:
    ======================
    Prep:
    ======================
    &#34;&#34;&#34;
    for child in self:
        child.delete(False)
    if self.parent:
        if _top:
            self.parent.children[self.parent.index_of(self)] = NonTerminal(
                self.treebank, self.label
            )
        else:
            self.parent.children[self.parent.index_of(self)] = None
        self.parent = None
    # Note that Label.remove_node() also removes the Label from the node,
    # so no need to do that here
    self.label.remove_node(self)</code></pre>
</details>
</dd>
<dt id="trees.NonTerminal.depth"><code class="name flex">
<span>def <span class="ident">depth</span></span>(<span>self) â€‘>Â int</span>
</code></dt>
<dd>
<div class="desc"><p>All nodes have a depth: the depth of a leaf node is 1, and the depth
of any other node is the depth of its deepest child + 1</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int:</code></dt>
<dd>Tree depth</dd>
</dl>
<pre><code class="language-python-repl">&gt;&gt;&gt; t = test_trees()
&gt;&gt;&gt; print([tx.depth() for tx in t])
[1, 3, 3, 3, 4, 3, 3, 2]
&gt;&gt;&gt; tf = test_fragments()
&gt;&gt;&gt; print([tfx.depth() for tfx in tf])
[3, 3, 0]
&gt;&gt;&gt; blah_depths = []
&gt;&gt;&gt; blah = &quot;([S]'blah')&quot;
&gt;&gt;&gt; print(tree(blah).depth())
&lt;code&gt;1&lt;/code&gt;
:   &amp;nbsp;


&gt;&gt;&gt; for i in range(8):
...     blah = blah.replace(&quot;'blah'&quot;, blah)
...     blah_depths.append(tree(blah).depth())
...
&gt;&gt;&gt; print(blah_depths)
[2, 4, 8, 16, 32, 64, 128, 256]
&gt;&gt;&gt; tb = Treebank()
&gt;&gt;&gt; fragment = tree(&quot;([S]([PN]'I')([VP]))&quot;, treebank = tb)
&gt;&gt;&gt; fragment.depth()
&lt;code&gt;2&lt;/code&gt;
:   &amp;nbsp;


</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def depth(self) -&gt; int:
    &#34;&#34;&#34;All nodes have a depth: the depth of a leaf node is 1, and the depth
    of any other node is the depth of its deepest child + 1

    Returns
    -------
    int:
        Tree depth

    &gt;&gt;&gt; t = test_trees()
    &gt;&gt;&gt; print([tx.depth() for tx in t])
    [1, 3, 3, 3, 4, 3, 3, 2]
    &gt;&gt;&gt; tf = test_fragments()
    &gt;&gt;&gt; print([tfx.depth() for tfx in tf])
    [3, 3, 0]
    &gt;&gt;&gt; blah_depths = []
    &gt;&gt;&gt; blah = &#34;([S]&#39;blah&#39;)&#34;
    &gt;&gt;&gt; print(tree(blah).depth())
    1
    &gt;&gt;&gt; for i in range(8):
    ...     blah = blah.replace(&#34;&#39;blah&#39;&#34;, blah)
    ...     blah_depths.append(tree(blah).depth())
    ...
    &gt;&gt;&gt; print(blah_depths)
    [2, 4, 8, 16, 32, 64, 128, 256]
    &gt;&gt;&gt; tb = Treebank()
    &gt;&gt;&gt; fragment = tree(&#34;([S]([PN]&#39;I&#39;)([VP]))&#34;, treebank = tb)
    &gt;&gt;&gt; fragment.depth()
    2
    &#34;&#34;&#34;
    # Recursive function with two stopping cases: if called on a
    # NonTerminal leafnode, or in a Terminal. The `else` case below handles
    # the former, and for the latter, Terminal has its own version of the
    # function
    return (1 + max([c.depth() for c in self])) if self.children else 0</code></pre>
</details>
</dd>
<dt id="trees.NonTerminal.get_all_substitition_sites"><code class="name flex">
<span>def <span class="ident">get_all_substitition_sites</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the all non-terminal leaf-node: a non-terminal leaf node
being a node that is capable of having children, but has none.</p>
<p>Note that this has no counterpart in Terminal: it only makes sense to
look for NonTerminal leaf nodes at or under NonTerminals</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code> of <code>SubstitutionSites:</code></dt>
<dd>A list of dataclass objects containing the parent nodes of each
nonterminal leafnode, its index in its parent, and its label.</dd>
</dl>
<pre><code class="language-python-repl">&gt;&gt;&gt; t0 = tree(&quot;([S]([NP]([Det])([N]sentence))([VP]([V]parses)([NP]([Det]the)([N]parser))))&quot;)
&gt;&gt;&gt; t1 = tree(&quot;([S]([NP]([Det])([N]sentence))([VP]([V]parses)([NP]([Det]the)([N]))))&quot;)
&gt;&gt;&gt; t2 = tree(&quot;([S]([NP]([Det]the)([N]))([VP]([V]parses)([NP])))&quot;)
&gt;&gt;&gt; t3 = tree(&quot;([S]([NP]([Det])([N]))([VP]([V])([NP]([Det])([N]))))&quot;)
&gt;&gt;&gt; t4 = tree(&quot;([S]([NP])([VP]))&quot;)
&gt;&gt;&gt; t5 = tree(&quot;([S]([NP]([Det]the)([N]sentence))([VP]([V]parses)([NP]([Det]the)([N]parser))))&quot;)
&gt;&gt;&gt; for t in (t0, t1, t2, t3, t4, t5):
...     print([s.site for s in t.get_all_substitition_sites()])
...
[tree(&quot;([Det])&quot;)]
[tree(&quot;([Det])&quot;), tree(&quot;([N])&quot;)]
[tree(&quot;([N])&quot;), tree(&quot;([NP])&quot;)]
[tree(&quot;([Det])&quot;), tree(&quot;([N])&quot;), tree(&quot;([V])&quot;), tree(&quot;([Det])&quot;), tree(&quot;([N])&quot;)]
[tree(&quot;([NP])&quot;), tree(&quot;([VP])&quot;)]
[]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_all_substitition_sites(self):
    &#34;&#34;&#34;
    Returns the all non-terminal leaf-node: a non-terminal leaf node
    being a node that is capable of having children, but has none.

    Note that this has no counterpart in Terminal: it only makes sense to
    look for NonTerminal leaf nodes at or under NonTerminals

    Returns
    -------
    list of SubstitutionSites:
        A list of dataclass objects containing the parent nodes of each
        nonterminal leafnode, its index in its parent, and its label.

    &gt;&gt;&gt; t0 = tree(&#34;([S]([NP]([Det])([N]sentence))([VP]([V]parses)([NP]([Det]the)([N]parser))))&#34;)
    &gt;&gt;&gt; t1 = tree(&#34;([S]([NP]([Det])([N]sentence))([VP]([V]parses)([NP]([Det]the)([N]))))&#34;)
    &gt;&gt;&gt; t2 = tree(&#34;([S]([NP]([Det]the)([N]))([VP]([V]parses)([NP])))&#34;)
    &gt;&gt;&gt; t3 = tree(&#34;([S]([NP]([Det])([N]))([VP]([V])([NP]([Det])([N]))))&#34;)
    &gt;&gt;&gt; t4 = tree(&#34;([S]([NP])([VP]))&#34;)
    &gt;&gt;&gt; t5 = tree(&#34;([S]([NP]([Det]the)([N]sentence))([VP]([V]parses)([NP]([Det]the)([N]parser))))&#34;)
    &gt;&gt;&gt; for t in (t0, t1, t2, t3, t4, t5):
    ...     print([s.site for s in t.get_all_substitition_sites()])
    ...
    [tree(&#34;([Det])&#34;)]
    [tree(&#34;([Det])&#34;), tree(&#34;([N])&#34;)]
    [tree(&#34;([N])&#34;), tree(&#34;([NP])&#34;)]
    [tree(&#34;([Det])&#34;), tree(&#34;([N])&#34;), tree(&#34;([V])&#34;), tree(&#34;([Det])&#34;), tree(&#34;([N])&#34;)]
    [tree(&#34;([NP])&#34;), tree(&#34;([VP])&#34;)]
    []
    &#34;&#34;&#34;
    # Initialise an empty list: try to put substitution sites in it, if
    # there are any, if not return it empty
    sites = []
    # It is assumed that this is not called directly on zero-depth
    # NonTerminals, but more usually on the root node of a tree.
    # Loop over the enumeration of self, as we will need the index of any
    # substitution site found
    for i, c in enumerate(self):
        # Ignore Terminals
        if not hasattr(c, &#39;leaf&#39;):
            # If a child is childess, it&#39;s a substitution site and can be
            # added to the list
            if not hasattr(c, &#39;children&#39;) or not len(c.children):
                # The object returned, however, is not the
                # node itself, but a dataclass object containing `self` (the
                # parent of the substitution site), i, the index of the
                # substitution site in self, and the label at the
                # substitution site, as this determines what can be
                # substituted there. SubstitutionSite also has a method
                # which takes a subtree as an argument, and performs the
                # substitution if the label matches
                sites += [SubstitutionSite(self, i, c.label)]
            # Otherwise, recursively call on the child, and see if there are
            # any substitution sites further down the tree
            sites += c.get_all_substitition_sites()
    return sites</code></pre>
</details>
</dd>
<dt id="trees.NonTerminal.get_leftmost_substition_site"><code class="name flex">
<span>def <span class="ident">get_leftmost_substition_site</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a SubstitutionSite object pointing to the leftmost non-terminal
leaf-node: a non-terminal leaf node being a node that is capable of
having children, but has none.</p>
<p>Note that this has no counterpart in Terminal: it only makes sense to
look for NonTerminal leaf nodes at or under NonTerminals</p>
<h2 id="returns">Returns</h2>
<h2 id="substitutionsite">Substitutionsite</h2>
<p>An object containing the parent node of the leftmost nonterminal
leafnode, the index in the parent at which the substitution site
occurs, and the label at the substitution site</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; t0 = tree(&quot;([S]([NP]([Det])([N]sentence))([VP]([V]parses)([NP]([Det]the)([N]parser))))&quot;)
&gt;&gt;&gt; t1 = tree(&quot;([S]([NP]([Det])([N]sentence))([VP]([V]parses)([NP]([Det]the)([N]))))&quot;)
&gt;&gt;&gt; t2 = tree(&quot;([S]([NP]([Det]the)([N]))([VP]([V]parses)([NP])))&quot;)
&gt;&gt;&gt; t3 = tree(&quot;([S]([NP]([Det])([N]))([VP]([V])([NP]([Det])([N]))))&quot;)
&gt;&gt;&gt; t4 = tree(&quot;([S]([NP])([VP]))&quot;)
&gt;&gt;&gt; t5 = tree(&quot;([S]([NP]([Det]the)([N]sentence))([VP]([V]parses)([NP]([Det]the)([N]parser))))&quot;)
&gt;&gt;&gt; for t in (t0, t1, t2, t3, t4, t5):
...     ss = t.get_leftmost_substition_site()
...     print(ss.site if ss else ss)
...
([Det])
([Det])
([N])
([Det])
([NP])
None
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_leftmost_substition_site(self):
    &#34;&#34;&#34;
    Returns a SubstitutionSite object pointing to the leftmost non-terminal
    leaf-node: a non-terminal leaf node being a node that is capable of
    having children, but has none.

    Note that this has no counterpart in Terminal: it only makes sense to
    look for NonTerminal leaf nodes at or under NonTerminals

    Returns
    -------
    SubstitutionSite:
        An object containing the parent node of the leftmost nonterminal
        leafnode, the index in the parent at which the substitution site
        occurs, and the label at the substitution site

    &gt;&gt;&gt; t0 = tree(&#34;([S]([NP]([Det])([N]sentence))([VP]([V]parses)([NP]([Det]the)([N]parser))))&#34;)
    &gt;&gt;&gt; t1 = tree(&#34;([S]([NP]([Det])([N]sentence))([VP]([V]parses)([NP]([Det]the)([N]))))&#34;)
    &gt;&gt;&gt; t2 = tree(&#34;([S]([NP]([Det]the)([N]))([VP]([V]parses)([NP])))&#34;)
    &gt;&gt;&gt; t3 = tree(&#34;([S]([NP]([Det])([N]))([VP]([V])([NP]([Det])([N]))))&#34;)
    &gt;&gt;&gt; t4 = tree(&#34;([S]([NP])([VP]))&#34;)
    &gt;&gt;&gt; t5 = tree(&#34;([S]([NP]([Det]the)([N]sentence))([VP]([V]parses)([NP]([Det]the)([N]parser))))&#34;)
    &gt;&gt;&gt; for t in (t0, t1, t2, t3, t4, t5):
    ...     ss = t.get_leftmost_substition_site()
    ...     print(ss.site if ss else ss)
    ...
    ([Det])
    ([Det])
    ([N])
    ([Det])
    ([NP])
    None
    &#34;&#34;&#34;
    # It is assumed that this is not called directly on zero-depth
    # NonTerminals, but more usually on the root node of a tree
    for i, c in enumerate(self):
        # Don&#39;t bother checking any child that is a Terminal, we are only
        # interested in childless NonTerminals
        if not hasattr(c, &#39;leaf&#39;):
            if not hasattr(c, &#39;children&#39;) or not len(c.children):
                # If the child is childless, it is a nonterminal leafnode,
                # which we return immediately as the first one we find is
                # the leftmost. The object returned, however, is not the
                # node itself, but a dataclass object containing `self` (the
                # parent of the substitution site), i, the index of the
                # substitution site in self, and the label at the
                # substitution site, as this determines what can be
                # substituted there. SubstitutionSite also has a method
                # which takes a subtree as an argument, and performs the
                # substitution if the label matches
                return SubstitutionSite(self, i, c.label)
            # otherwise, recursively call this function
            ss = c.get_leftmost_substition_site()
            # If a ss is found, return it. This function doesn&#39;t reach a
            # `return` line if no nonterminal leaf is found, so will return
            # `None`, meaning lnl will be None if no ss is found my the
            # recursive call, so the conditional won&#39;t be triggered
            if ss:
                return ss</code></pre>
</details>
</dd>
<dt id="trees.NonTerminal.index_of"><code class="name flex">
<span>def <span class="ident">index_of</span></span>(<span>self, child:Â <a title="trees.Tree" href="#trees.Tree">Tree</a>, descendants=False, strict=True) â€‘>Â (<classÂ 'int'>,Â typing.Tuple[int])</span>
</code></dt>
<dd>
<div class="desc"><p>Takes a child node and returns its position in the <code><a title="trees.NonTerminal" href="#trees.NonTerminal">NonTerminal</a></code>'s
children, or, if <code>descendants</code> is True, it's descendants. If a <code><a title="trees.Tree" href="#trees.Tree">Tree</a></code>
is passed to <code>child</code> that is not a child/descendant of <code>self</code>, returns
the empty <code>tuple</code> if not <code>strict</code>, otherwise raises a <code>ValueError</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>child</code></strong> :&ensp;<code><a title="trees.Tree" href="#trees.Tree">Tree</a></code></dt>
<dd>The <code><a title="trees.Tree" href="#trees.Tree">Tree</a></code> we are looking for.</dd>
<dt><strong><code>descendants</code></strong> :&ensp;<code>bool</code></dt>
<dd>If <code>True</code>, search all the descendants of <code>self</code>, otherwise, just
search its children. False by default.</dd>
<dt><strong><code>strict</code></strong> :&ensp;<code>bool</code></dt>
<dd>If <code>True</code>, raises a ValueError if the child is not found: otherwise
returns <code>()</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code> or <code>tuple</code> of <code>ints</code></dt>
<dd>Index. If <code>descendants</code> is <code>False</code> and <code>strict</code> is <code>True</code>, returns
the index of <code>child</code> in <code>self</code> as an <code>int</code>: otherwise, it returns a
tuple, giving the path from <code>self</code> to <code>child</code> - which is empty if
there is no path and <code>strict</code> is false.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If <code>child</code> is not found and <code>strict</code> is <code>True</code>.</dd>
</dl>
<pre><code class="language-python-repl">&gt;&gt;&gt; tb = Treebank()
&gt;&gt;&gt; tree0 = tree(&quot;([S]([NP]([PN]'she'))([VP]([V]'saw')([S]([NP]([NP]([Det]'the')([N]'dog'))([PP]([Prep]'with')([NP]([Det]'the')([N]'telescope'))))([VP]([V]'observing')([NP]([PN]'neptune'))))))&quot;, treebank = tb)
&gt;&gt;&gt; tree1 = tree(&quot;([NP]([Det]'the')([N]'dog'))&quot;, treebank = tb)
&gt;&gt;&gt; tree2 = tree0[1,1,0,0]
&gt;&gt;&gt; for i, t in enumerate(tree0):
...     print(i == tree0.index_of(t))
&lt;code&gt;True&lt;/code&gt;
:   &amp;nbsp;


&lt;code&gt;True&lt;/code&gt;
:   &amp;nbsp;


&gt;&gt;&gt; tree0.index_of(tree2, True, False)
(1, 1, 0, 0)
&gt;&gt;&gt; tree0.index_of(tree1, True, False)
()
&gt;&gt;&gt; tree0.index_of(tree2, False, False)
()
&gt;&gt;&gt; tree0.index_of(tree1, False, False)
()
&gt;&gt;&gt; tree0.index_of(tree2, True, True)
(1, 1, 0, 0)
&gt;&gt;&gt; tree0.index_of(tree1, True, True) # doctest: +IGNORE_EXCEPTION_DETAIL
`Traceback (most recent call last):`
:   &amp;nbsp;


**```ValueError```** :&amp;ensp;&lt;code&gt;Descendant not found&lt;/code&gt;
:   &amp;nbsp;


&gt;&gt;&gt; tree0.index_of(tree2, False, True) # doctest: +IGNORE_EXCEPTION_DETAIL
`Traceback (most recent call last):`
:   &amp;nbsp;


**```ValueError```** :&amp;ensp;&lt;code&gt;Child not found&lt;/code&gt;
:   &amp;nbsp;


&gt;&gt;&gt; tree0.index_of(tree1, False, True) # doctest: +IGNORE_EXCEPTION_DETAIL
`Traceback (most recent call last):`
:   &amp;nbsp;


**```ValueError```** :&amp;ensp;&lt;code&gt;Child not found&lt;/code&gt;
:   &amp;nbsp;


</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def index_of(self, child: Tree, descendants=False, strict=True) -&gt; (int, Tuple[int]):
    &#34;&#34;&#34;Takes a child node and returns its position in the `NonTerminal`&#39;s
    children, or, if `descendants` is True, it&#39;s descendants. If a `Tree`
    is passed to `child` that is not a child/descendant of `self`, returns
    the empty `tuple` if not `strict`, otherwise raises a `ValueError`.

    Parameters
    ----------
    child : Tree
        The `Tree` we are looking for.
    descendants : bool
        If `True`, search all the descendants of `self`, otherwise, just
        search its children. False by default.
    strict : bool
        If `True`, raises a ValueError if the child is not found: otherwise
        returns `()`.

    Returns
    -------
    int or tuple of ints
        Index. If `descendants` is `False` and `strict` is `True`, returns
        the index of `child` in `self` as an `int`: otherwise, it returns a
        tuple, giving the path from `self` to `child` - which is empty if
        there is no path and `strict` is false.

    Raises
    ------
    ValueError
        If `child` is not found and `strict` is `True`.

    &gt;&gt;&gt; tb = Treebank()
    &gt;&gt;&gt; tree0 = tree(&#34;([S]([NP]([PN]&#39;she&#39;))([VP]([V]&#39;saw&#39;)([S]([NP]([NP]([Det]&#39;the&#39;)([N]&#39;dog&#39;))([PP]([Prep]&#39;with&#39;)([NP]([Det]&#39;the&#39;)([N]&#39;telescope&#39;))))([VP]([V]&#39;observing&#39;)([NP]([PN]&#39;neptune&#39;))))))&#34;, treebank = tb)
    &gt;&gt;&gt; tree1 = tree(&#34;([NP]([Det]&#39;the&#39;)([N]&#39;dog&#39;))&#34;, treebank = tb)
    &gt;&gt;&gt; tree2 = tree0[1,1,0,0]
    &gt;&gt;&gt; for i, t in enumerate(tree0):
    ...     print(i == tree0.index_of(t))
    True
    True
    &gt;&gt;&gt; tree0.index_of(tree2, True, False)
    (1, 1, 0, 0)
    &gt;&gt;&gt; tree0.index_of(tree1, True, False)
    ()
    &gt;&gt;&gt; tree0.index_of(tree2, False, False)
    ()
    &gt;&gt;&gt; tree0.index_of(tree1, False, False)
    ()
    &gt;&gt;&gt; tree0.index_of(tree2, True, True)
    (1, 1, 0, 0)
    &gt;&gt;&gt; tree0.index_of(tree1, True, True) # doctest: +IGNORE_EXCEPTION_DETAIL
    Traceback (most recent call last):
    ValueError: Descendant not found
    &gt;&gt;&gt; tree0.index_of(tree2, False, True) # doctest: +IGNORE_EXCEPTION_DETAIL
    Traceback (most recent call last):
    ValueError: Child not found
    &gt;&gt;&gt; tree0.index_of(tree1, False, True) # doctest: +IGNORE_EXCEPTION_DETAIL
    Traceback (most recent call last):
    ValueError: Child not found
    &#34;&#34;&#34;
    # if we are looking through the entire tree...
    # (note that in this condition all our indices are tuples, indicating a
    # path through the tree.
    if descendants:
        # ...then first, consider the case where the child we&#39;re looking for
        # is the direct child of self. In this case we can avoid code
        # duplication by calling index_of again, but this time taking the
        # !descendants branch. strict is false in the index_of call below,
        # even if the originating call is strict, because if we don&#39;t find
        # child in the children of self, we don&#39;t want to raise an
        # exception until we know it&#39;s not in the grandchildren, great-
        # grandchildren, etc. Because strict is false, we know that if child
        # is found by this call, it will return a tuple, which is what we
        # want
        idx = self.index_of(child, strict=False)
        # idx is either a singleton tuple (child is a child of self) or
        # empty. If singleton...
        if len(idx):
            # ...return it: otherwise...
            return idx
        else:
            # ...we need to look further down the tree. Loop with enumerate
            # because we need the index, in case the child is found. Since
            # we&#39;re using &#39;child&#39; for the Tree we&#39;re looking for, we&#39;ll use
            # &#39;kid&#39; for the actual children of self
            for i, kid in enumerate(self):
                # Terminals don&#39;t have children, so the search is only
                # continued if kid is a NonTerminal...
                if isinstance(kid, NonTerminal):
                    # ...again, a recursive call is wanted here, but this
                    # time with `descendants` set to true: strict is still
                    # set to false in the recursive call: if the originating
                    # call is strict, this loop will complete without
                    # returning, in which case the following code will
                    # either return empty or raise ValueError.
                    idx = kid.index_of(child, True, False)
                    # If idx is not empty, child was found in the
                    # descendants of &#39;kid&#39; at the tuple index at kid[*idx]:
                    # e.g., if (2,0,1) is returned, child == kid[2,0,1], so
                    # ...
                    if len(idx):
                        # given that kid == self[i], child == self[i, *idx],
                        # e.g., if kid = self[1] and child == kid[2,0,1],
                        # then child = self[1,2,0,1]
                        return (i,) + idx
            # If the function call is still running here, no child was found
            # and the proper behaviour is determined by whether `strict`.
            if not strict:
                return ()
            else:
                # The error specifies descendant since the function searched
                # the descendants, not just thie children of self
                raise ValueError(&#34;Descendant not found&#34;)
    # If not `descendants`, things are simpler. However, note that this is
    # the only branch of the function code that searches directly in the
    # children of a NonTerminal for a child: the descendant-searching
    # branch uses a call to this branch to check for immediate children.
    else:
        # Note that we are looking specifically for a child that is
        # *identical* to `child`, not just equal: however, the list.index()
        # function uses equality. Therefore, we convert `child`...
        ch_id = id(child)
        # ...and the list of children to ids
        k_ids = [id(k) for k in self._children]
        # if child&#39;s id is found in the list of the kids ids...
        if ch_id in k_ids:
            # ...then get the index it was found at...
            idx = k_ids.index(ch_id)
            # ...so return it, either as an int or a singleton tuple.
            return idx if strict else (idx,)
        # Otherwise, the child isn&#39;t found, and the appropriate response is
        # determined by `strict`.
        elif not strict:
            return ()
        else:
            raise ValueError(&#34;Child not found&#34;)</code></pre>
</details>
</dd>
<dt id="trees.NonTerminal.size"><code class="name flex">
<span>def <span class="ident">size</span></span>(<span>self) â€‘>Â int</span>
</code></dt>
<dd>
<div class="desc"><p>All nodes have a size: the size of a leaf node is 1, and the size
of any other node is the sum of its children's sizes, plus 1. This is
the total number of nodes in the tree.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int:</code></dt>
<dd>total number of nodes in the tree</dd>
</dl>
<pre><code class="language-python-repl">&gt;&gt;&gt; t = test_trees()
&gt;&gt;&gt; print([tx.size() for tx in t])
[1, 5, 5, 5, 9, 5, 5, 3]
&gt;&gt;&gt; tf = test_fragments()
&gt;&gt;&gt; print([tfx.size() for tfx in tf])
[5, 7, 1]
&gt;&gt;&gt; blah_sizes = []
&gt;&gt;&gt; blah = &quot;([N]'blah')&quot;
&gt;&gt;&gt; print(tree(blah).size())
&lt;code&gt;1&lt;/code&gt;
:   &amp;nbsp;


&gt;&gt;&gt; for i in range(1,4):
...     blah_top = &quot;([S]'blah')&quot;
...     for j in range(8):
...         blah_top = blah_top.replace(&quot;'blah'&quot;, blah*i)
...         blah_sizes.append(tree(blah_top).size())
...
&gt;&gt;&gt; print(blah_sizes)
[2, 3, 4, 5, 6, 7, 8, 9, 3, 7, 15, 31, 63, 127, 255, 511, 4, 13, 40, 121, 364, 1093, 3280, 9841]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def size(self) -&gt; int:
    &#34;&#34;&#34;All nodes have a size: the size of a leaf node is 1, and the size
    of any other node is the sum of its children&#39;s sizes, plus 1. This is
    the total number of nodes in the tree.

    Returns
    -------
    int:
        total number of nodes in the tree

    &gt;&gt;&gt; t = test_trees()
    &gt;&gt;&gt; print([tx.size() for tx in t])
    [1, 5, 5, 5, 9, 5, 5, 3]
    &gt;&gt;&gt; tf = test_fragments()
    &gt;&gt;&gt; print([tfx.size() for tfx in tf])
    [5, 7, 1]
    &gt;&gt;&gt; blah_sizes = []
    &gt;&gt;&gt; blah = &#34;([N]&#39;blah&#39;)&#34;
    &gt;&gt;&gt; print(tree(blah).size())
    1
    &gt;&gt;&gt; for i in range(1,4):
    ...     blah_top = &#34;([S]&#39;blah&#39;)&#34;
    ...     for j in range(8):
    ...         blah_top = blah_top.replace(&#34;&#39;blah&#39;&#34;, blah*i)
    ...         blah_sizes.append(tree(blah_top).size())
    ...
    &gt;&gt;&gt; print(blah_sizes)
    [2, 3, 4, 5, 6, 7, 8, 9, 3, 7, 15, 31, 63, 127, 255, 511, 4, 13, 40, 121, 364, 1093, 3280, 9841]
    &#34;&#34;&#34;
    return 1 + sum([c.size() for c in self])</code></pre>
</details>
</dd>
<dt id="trees.NonTerminal.to_LaTeX"><code class="name flex">
<span>def <span class="ident">to_LaTeX</span></span>(<span>self, top=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Converts trees to LaTeX expressions using the <code>qtree</code> package.
Remember to include <code>\usepackage{qtree}</code> in the document header. For
NonTerminals, the format is <code>[.$label $child* ]</code>. The label expression
is provided by a similar function in Label. The $child expressions are
recursively in the same format again (if they are also NonTerminals), or
<code>[.$label $leaf]</code> for Terminals, which have a separate <code>to_LaTeX</code>
method.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>top</code></strong> :&ensp;<code>bool</code></dt>
<dd>qtrees expressions must be prefixed with <code>\Tree</code>, but this only
applies to the whole tree: you don't put it in front of every node.
However, this function uses recursive calls to make the LaTeX of
child nodes, so making sure only the top node has this prefix takes
a bit of extra logic. If the node has no parent, the <code>\Tree</code> prefix
is automaticaly applied, otherwise by default it isn't. However, if
LaTeX is wanted for a partial tree, <code>top</code> may be set to <code>True</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>LaTeX expression representing the tree.</dd>
</dl>
<pre><code class="language-python-repl">&gt;&gt;&gt; t = test_trees()
&gt;&gt;&gt; for x in t[1:]:
...     print(x.to_LaTeX())
...
\Tree [.S [.N sentence ] [.VP [.V parses ] [.N parser ] ] ]
\Tree [.S [.N sentence ] [.VP [.V parses ] [.N parser ] ] ]
\Tree [.S [.N sentence ] [.VP [.V parses ] [.N parser ] ] ]
\Tree [.S [.NP [.Det the ] [.N sentence ] ] [.VP [.V parses ] [.NP [.Det the ] [.N parser ] ] ] ]
\Tree [.S [.N word ] [.VP [.V parses ] [.N parser ] ] ]
\Tree [.S [.N sentence ] [.VP [.V parses ] [.V parser ] ] ]
\Tree [.S [.X x ] [.Y y ] ]
&gt;&gt;&gt; tf = test_fragments()
&gt;&gt;&gt; for tfx in tf:
...     print(tfx.to_LaTeX())
...
\Tree [.S [.NP [.Det the ] [.N cat ] ] [.VP ] ]
\Tree [.S [.NP [.Det the ] [.N cat ] ] [.VP [.V ate ] [.NP ] ] ]
\Tree [.NP ]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_LaTeX(self, top = True):
    &#34;&#34;&#34;Converts trees to LaTeX expressions using the `qtree` package.
    Remember to include `\\usepackage{qtree}` in the document header. For
    NonTerminals, the format is `[.$label $child* ]`. The label expression
    is provided by a similar function in Label. The $child expressions are
    recursively in the same format again (if they are also NonTerminals), or
    `[.$label $leaf]` for Terminals, which have a separate `to_LaTeX`
    method.

    Parameters
    ----------
    top : bool
        qtrees expressions must be prefixed with `\\Tree`, but this only
        applies to the whole tree: you don&#39;t put it in front of every node.
        However, this function uses recursive calls to make the LaTeX of
        child nodes, so making sure only the top node has this prefix takes
        a bit of extra logic. If the node has no parent, the `\\Tree` prefix
        is automaticaly applied, otherwise by default it isn&#39;t. However, if
        LaTeX is wanted for a partial tree, `top` may be set to `True`

    Returns
    -------
    str
        LaTeX expression representing the tree.

    &gt;&gt;&gt; t = test_trees()
    &gt;&gt;&gt; for x in t[1:]:
    ...     print(x.to_LaTeX())
    ...
    \Tree [.S [.N sentence ] [.VP [.V parses ] [.N parser ] ] ]
    \Tree [.S [.N sentence ] [.VP [.V parses ] [.N parser ] ] ]
    \Tree [.S [.N sentence ] [.VP [.V parses ] [.N parser ] ] ]
    \Tree [.S [.NP [.Det the ] [.N sentence ] ] [.VP [.V parses ] [.NP [.Det the ] [.N parser ] ] ] ]
    \Tree [.S [.N word ] [.VP [.V parses ] [.N parser ] ] ]
    \Tree [.S [.N sentence ] [.VP [.V parses ] [.V parser ] ] ]
    \Tree [.S [.X x ] [.Y y ] ]
    &gt;&gt;&gt; tf = test_fragments()
    &gt;&gt;&gt; for tfx in tf:
    ...     print(tfx.to_LaTeX())
    ...
    \Tree [.S [.NP [.Det the ] [.N cat ] ] [.VP ] ]
    \Tree [.S [.NP [.Det the ] [.N cat ] ] [.VP [.V ate ] [.NP ] ] ]
    \Tree [.NP ]
    &#34;&#34;&#34;
    # prepends \Tree if needed
    LaTeX = r&#34;\Tree &#34; if not (hasattr(self, &#39;parent&#39;) and self.parent) or top else &#34;&#34;
    LaTeX += f&#34;[{self.label.to_LaTeX()} {&#39;&#39;.join([c.to_LaTeX(top = False) for c in self])}] &#34;
    return LaTeX.strip() if top else LaTeX</code></pre>
</details>
</dd>
<dt id="trees.NonTerminal.width"><code class="name flex">
<span>def <span class="ident">width</span></span>(<span>self) â€‘>Â int</span>
</code></dt>
<dd>
<div class="desc"><p>All nodes have a width: the width of a leaf node is 1, and the width
of any other node is the sum of its children's widths. This is
equivalent to the total number of leaf nodes in the tree</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int:</code></dt>
<dd>Tree width</dd>
</dl>
<pre><code class="language-python-repl">&gt;&gt;&gt; t = test_trees()
&gt;&gt;&gt; print([tx.width() for tx in t])
[1, 3, 3, 3, 5, 3, 3, 2]
&gt;&gt;&gt; tf = test_fragments()
&gt;&gt;&gt; print([tfx.width() for tfx in tf])
[3, 4, 1]
&gt;&gt;&gt; blah_widths = []
&gt;&gt;&gt; blah = &quot;([N]'blah')&quot;
&gt;&gt;&gt; print(tree(blah).width())
&lt;code&gt;1&lt;/code&gt;
:   &amp;nbsp;


&gt;&gt;&gt; for i in range(1,4):
...     blah_top = &quot;([S]'blah')&quot;
...     for j in range(8):
...         blah_top = blah_top.replace(&quot;'blah'&quot;, blah*i)
...         blah_widths.append(tree(blah_top).width())
...
&gt;&gt;&gt; print(blah_widths)
[1, 1, 1, 1, 1, 1, 1, 1, 2, 4, 8, 16, 32, 64, 128, 256, 3, 9, 27, 81, 243, 729, 2187, 6561]
&gt;&gt;&gt; tb = Treebank()
&gt;&gt;&gt; fragment = tree(&quot;([S]([PN]'I')([VP]))&quot;, treebank = tb)
&gt;&gt;&gt; fragment.width()
&lt;code&gt;2&lt;/code&gt;
:   &amp;nbsp;


</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def width(self) -&gt; int:
    &#34;&#34;&#34;All nodes have a width: the width of a leaf node is 1, and the width
    of any other node is the sum of its children&#39;s widths. This is
    equivalent to the total number of leaf nodes in the tree

    Returns
    -------
    int:
        Tree width

    &gt;&gt;&gt; t = test_trees()
    &gt;&gt;&gt; print([tx.width() for tx in t])
    [1, 3, 3, 3, 5, 3, 3, 2]
    &gt;&gt;&gt; tf = test_fragments()
    &gt;&gt;&gt; print([tfx.width() for tfx in tf])
    [3, 4, 1]
    &gt;&gt;&gt; blah_widths = []
    &gt;&gt;&gt; blah = &#34;([N]&#39;blah&#39;)&#34;
    &gt;&gt;&gt; print(tree(blah).width())
    1
    &gt;&gt;&gt; for i in range(1,4):
    ...     blah_top = &#34;([S]&#39;blah&#39;)&#34;
    ...     for j in range(8):
    ...         blah_top = blah_top.replace(&#34;&#39;blah&#39;&#34;, blah*i)
    ...         blah_widths.append(tree(blah_top).width())
    ...
    &gt;&gt;&gt; print(blah_widths)
    [1, 1, 1, 1, 1, 1, 1, 1, 2, 4, 8, 16, 32, 64, 128, 256, 3, 9, 27, 81, 243, 729, 2187, 6561]
    &gt;&gt;&gt; tb = Treebank()
    &gt;&gt;&gt; fragment = tree(&#34;([S]([PN]&#39;I&#39;)([VP]))&#34;, treebank = tb)
    &gt;&gt;&gt; fragment.width()
    2
    &#34;&#34;&#34;
    return max(sum([c.width() for c in self]), 1)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="trees.Tree" href="#trees.Tree">Tree</a></b></code>:
<ul class="hlist">
<li><code><a title="trees.Tree.label" href="#trees.Tree.label">label</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="trees.Operators"><code class="flex name class">
<span>class <span class="ident">Operators</span></span>
</code></dt>
<dd>
<div class="desc"><p>Class to contain operators to which perform computations
on the values of the child nodes of trees, such that the value
of a nonterminal is <code>parent_operator(*[children_values])</code> and
the value of a terminal is its content.</p>
<p>In a DOP implementation for NLP, this means that the terminal
contents will be (typically) words, and only one operator will
be used, the concatenation operator CONCAT, and the value of
any complete parse tree will be the sentence it parses, and the
value of any node will be the constituent underneath it.</p>
<p>In genetic programming, multiple operators will be used, for
arithmetic and boolean operations - possibly more besides.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Operators:
    &#34;&#34;&#34;Class to contain operators to which perform computations
    on the values of the child nodes of trees, such that the value
    of a nonterminal is `parent_operator(*[children_values])` and
    the value of a terminal is its content.

    In a DOP implementation for NLP, this means that the terminal
    contents will be (typically) words, and only one operator will
    be used, the concatenation operator CONCAT, and the value of
    any complete parse tree will be the sentence it parses, and the
    value of any node will be the constituent underneath it.

    In genetic programming, multiple operators will be used, for
    arithmetic and boolean operations - possibly more besides.
    &#34;&#34;&#34;

    def ID(*args):
        &#34;&#34;&#34;Returns a tuple of the node&#39;s children. The basic-ass default
        operator. Mistakes ability to remember funny lines from telly for being
        funny. Listens to local radio. Has one significant ambition in life,
        which is to win the lottery.
        &#34;&#34;&#34;
        return args

    def CONCAT(*args):
        &#34;&#34;&#34;Concatenates the string representations of child node with a space
        as a separator. Useful for Data Oriented Parsing, as it returns the
        original sentence that the tree parses. `ID`&#39;s hipster cousin who moved
        to the Netherlands. Sighs loudly at tipexed-on bike lanes when back in
        the UK. Doesn&#39;t go to coffeeshops cause they&#39;re for tourists. Would love
        to have a good excuse to justify the cost of a bakfiets.
        &#34;&#34;&#34;
        return &#34; &#34;.join(args)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="trees.Operators.CONCAT"><code class="name flex">
<span>def <span class="ident">CONCAT</span></span>(<span>*args)</span>
</code></dt>
<dd>
<div class="desc"><p>Concatenates the string representations of child node with a space
as a separator. Useful for Data Oriented Parsing, as it returns the
original sentence that the tree parses. <code>ID</code>'s hipster cousin who moved
to the Netherlands. Sighs loudly at tipexed-on bike lanes when back in
the UK. Doesn't go to coffeeshops cause they're for tourists. Would love
to have a good excuse to justify the cost of a bakfiets.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def CONCAT(*args):
    &#34;&#34;&#34;Concatenates the string representations of child node with a space
    as a separator. Useful for Data Oriented Parsing, as it returns the
    original sentence that the tree parses. `ID`&#39;s hipster cousin who moved
    to the Netherlands. Sighs loudly at tipexed-on bike lanes when back in
    the UK. Doesn&#39;t go to coffeeshops cause they&#39;re for tourists. Would love
    to have a good excuse to justify the cost of a bakfiets.
    &#34;&#34;&#34;
    return &#34; &#34;.join(args)</code></pre>
</details>
</dd>
<dt id="trees.Operators.ID"><code class="name flex">
<span>def <span class="ident">ID</span></span>(<span>*args)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a tuple of the node's children. The basic-ass default
operator. Mistakes ability to remember funny lines from telly for being
funny. Listens to local radio. Has one significant ambition in life,
which is to win the lottery.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ID(*args):
    &#34;&#34;&#34;Returns a tuple of the node&#39;s children. The basic-ass default
    operator. Mistakes ability to remember funny lines from telly for being
    funny. Listens to local radio. Has one significant ambition in life,
    which is to win the lottery.
    &#34;&#34;&#34;
    return args</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="trees.SubstitutionSite"><code class="flex name class">
<span>class <span class="ident">SubstitutionSite</span></span>
<span>(</span><span>parent:Â <a title="trees.NonTerminal" href="#trees.NonTerminal">NonTerminal</a>, index:Â int, label:Â <a title="trees.Label" href="#trees.Label">Label</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Dataclass containing all the information about a nonterminal leaf node
needed to do a node substitution at that location: its label (so we can
check the substitution is valid), its parent, and its index in its parent
(so the substitution can be performed).</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>parent</code></strong> :&ensp;<code><a title="trees.NonTerminal" href="#trees.NonTerminal">NonTerminal</a></code></dt>
<dd>parent node of the nonterminal leaf node, needed
to perform substitution.</dd>
<dt><strong><code>index</code></strong> :&ensp;<code>int</code></dt>
<dd>index of nonterminal leaf node, needed to perform
substitution.</dd>
<dt><strong><code>label</code></strong> :&ensp;<code><a title="trees.Label" href="#trees.Label">Label</a></code></dt>
<dd>Label of nonterminal leaf node, needed to ensure
substitution if valid.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class SubstitutionSite:
    &#34;&#34;&#34;Dataclass containing all the information about a nonterminal leaf node
    needed to do a node substitution at that location: its label (so we can
    check the substitution is valid), its parent, and its index in its parent
    (so the substitution can be performed).

    Attributes:
        parent (NonTerminal): parent node of the nonterminal leaf node, needed
            to perform substitution.
        index (int): index of nonterminal leaf node, needed to perform
            substitution.
        label (Label): Label of nonterminal leaf node, needed to ensure
            substitution if valid.
    &#34;&#34;&#34;
    parent: NonTerminal
    index: int
    label: Label

    def perform_substitution(self, subtree: Tree):
        &#34;&#34;&#34;Takes a subtree and, if it has the same node label, swaps it for the
        nonterminal leafnode at the substitution site

        Parameters
        ----------
            subtree (Tree): The subtree to be swapped into place.
        Raises:
            ValueError: if the Label at the substitution site does not match the
                root label of the subtree to be substituted
        &#34;&#34;&#34;
        # If substitution is legit...
        if subtree.label == self.label:
            # ...then, do it. ...
            self.parent[self.index] = subtree
            subtree.parent = self.parent
        else:
            # ... otherwise, noep.
            raise ValueError(
                f&#34;Subtree {subtree} with root label {subtree.label} &#34; +
                f&#34;(id = {id(subtree.label)}) cannot be substituted at index &#34; +
                f&#34;{self.index} of {self.parent} due to a mismatch with &#34; +
                f&#34;substitution site label {self.label} (id = {id(self.label)}).&#34;
            )

    @property
    def site(self) -&gt; NonTerminal:
        &#34;&#34;&#34;(NonTerminal) The actual nonterminal leafnode.&#34;&#34;&#34;
        return self.parent[self.index]</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="trees.SubstitutionSite.index"><code class="name">var <span class="ident">index</span> :Â int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="trees.SubstitutionSite.label"><code class="name">var <span class="ident">label</span> :Â <a title="trees.Label" href="#trees.Label">Label</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="trees.SubstitutionSite.parent"><code class="name">var <span class="ident">parent</span> :Â <a title="trees.NonTerminal" href="#trees.NonTerminal">NonTerminal</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="trees.SubstitutionSite.site"><code class="name">var <span class="ident">site</span> :Â <a title="trees.NonTerminal" href="#trees.NonTerminal">NonTerminal</a></code></dt>
<dd>
<div class="desc"><p>(NonTerminal) The actual nonterminal leafnode.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def site(self) -&gt; NonTerminal:
    &#34;&#34;&#34;(NonTerminal) The actual nonterminal leafnode.&#34;&#34;&#34;
    return self.parent[self.index]</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="trees.SubstitutionSite.perform_substitution"><code class="name flex">
<span>def <span class="ident">perform_substitution</span></span>(<span>self, subtree:Â <a title="trees.Tree" href="#trees.Tree">Tree</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Takes a subtree and, if it has the same node label, swaps it for the
nonterminal leafnode at the substitution site</p>
<h2 id="parameters">Parameters</h2>
<pre><code>subtree (Tree): The subtree to be swapped into place.
</code></pre>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>if the Label at the substitution site does not match the
root label of the subtree to be substituted</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def perform_substitution(self, subtree: Tree):
    &#34;&#34;&#34;Takes a subtree and, if it has the same node label, swaps it for the
    nonterminal leafnode at the substitution site

    Parameters
    ----------
        subtree (Tree): The subtree to be swapped into place.
    Raises:
        ValueError: if the Label at the substitution site does not match the
            root label of the subtree to be substituted
    &#34;&#34;&#34;
    # If substitution is legit...
    if subtree.label == self.label:
        # ...then, do it. ...
        self.parent[self.index] = subtree
        subtree.parent = self.parent
    else:
        # ... otherwise, noep.
        raise ValueError(
            f&#34;Subtree {subtree} with root label {subtree.label} &#34; +
            f&#34;(id = {id(subtree.label)}) cannot be substituted at index &#34; +
            f&#34;{self.index} of {self.parent} due to a mismatch with &#34; +
            f&#34;substitution site label {self.label} (id = {id(self.label)}).&#34;
        )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="trees.Terminal"><code class="flex name class">
<span>class <span class="ident">Terminal</span></span>
<span>(</span><span>treebank, label, leaf)</span>
</code></dt>
<dd>
<div class="desc"><p>A general class of terminal node, agnostic as to whether we are using
Trees to represent strings, functions, music, visual images, motor scores,
etc.</p>
<p>TODO: add a metadata attribute</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>_label</code></strong> :&ensp;<code><a title="trees.Label" href="#trees.Label">Label</a></code></dt>
<dd>Inherited from Tree. Node label determining
which subtrees can be substituted where. Set and got by the <code>label</code>
@property</dd>
<dt><strong><code>parent</code></strong> :&ensp;<code><a title="trees.NonTerminal" href="#trees.NonTerminal">NonTerminal</a></code> or <code>None</code></dt>
<dd>Inherited from Tree. The node
dirctly above the present in the tree. Each child has a reference to
its parent, and each parent has references to all its children.</dd>
<dt><strong><code>treebank</code></strong> :&ensp;<code><a title="trees.Treebank" href="#trees.Treebank">Treebank</a></code></dt>
<dd>Every Tree belongs to a Treebank, which defines the
set of Labels that <code><a title="trees.Tree" href="#trees.Tree">Tree</a></code>, its parents, and its children can take.</dd>
<dt><strong><code>leaf</code></strong></dt>
<dd>The terminal content of this branch of the tree, like a word in
syntactic parsing, or a constant or variable in Genetic Programming</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Terminal(Tree):
    &#34;&#34;&#34;A general class of terminal node, agnostic as to whether we are using
    Trees to represent strings, functions, music, visual images, motor scores,
    etc.

    TODO: add a metadata attribute

    Attributes:
        _label (Label): Inherited from Tree. Node label determining
            which subtrees can be substituted where. Set and got by the `label`
            @property
        parent (NonTerminal or None): Inherited from Tree. The node
            dirctly above the present in the tree. Each child has a reference to
            its parent, and each parent has references to all its children.
        treebank (Treebank): Every Tree belongs to a Treebank, which defines the
            set of Labels that `Tree`, its parents, and its children can take.
        leaf: The terminal content of this branch of the tree, like a word in
            syntactic parsing, or a constant or variable in Genetic Programming
    &#34;&#34;&#34;
    def __init__(self, treebank, label, leaf):
        try:
            self.leaf = eval(leaf)
        except Exception:
            self.leaf = leaf
        super().__init__(treebank, label)

    def __str__(self):
        &#34;&#34;&#34;Readable string representation of a Terminal. This consists of a pair
        of parentheses containing a representation of the node&#39;s label (label
        name in square brackets), followed by the leaf value, e.g.:

        ([N]&#39;telescope&#39;).
        &#34;&#34;&#34;
        return f&#34;({self.label if hasattr(self, &#39;_label&#39;) else &#39;&#39;}{repr(self.leaf)})&#34;

    def __eq__(self, other):
        &#34;&#34;&#34;Magic method to operator-overload `==` and `!=`

        Returns
        -------
            bool: True if class, label and leaf are the same, else False.

        &gt;&gt;&gt; # The tests on NonTerminal.__eq__ also test this
        &gt;&gt;&gt; tb = Treebank()
        &gt;&gt;&gt; tree(&#39;([N]bridge)&#39;, tb) == tree(&#39;([N]bridge)&#39;, tb)
        True
        &gt;&gt;&gt; tree(&#39;([N]bridge)&#39;, tb) == tree(&#39;([V]bridge)&#39;, tb)
        False
        &gt;&gt;&gt; tree(&#39;([N]bridge)&#39;, tb) == tree(&#39;([N]man)&#39;, tb)
        False
        &gt;&gt;&gt; tree(&#39;([N]bridge)&#39;) == tree(&#39;([N]bridge)&#39;)
        False
        &gt;&gt;&gt; tree(&#39;([N]bridge)&#39;) == tree(&#39;([V]bridge)&#39;)
        False
        &gt;&gt;&gt; tree(&#39;([N]bridge)&#39;) == tree(&#39;([N]man)&#39;)
        False
        &#34;&#34;&#34;
        return self.__class__ == other.__class__ and self.leaf == other.leaf and self.label == other.label

    def __len__(self) -&gt; int:
        &#34;&#34;&#34;All nodes have a length: Terminals have length 1, while NonTerminals
        have a length equal to the number of children

        Returns
        -------
        int:  1
        &#34;&#34;&#34;
        return 1

    def depth(self) -&gt; int:
        &#34;&#34;&#34;All terminals have depth 1&#34;&#34;&#34;
        return 1

    def width(self) -&gt; int:
        &#34;&#34;&#34;All terminals have width 1&#34;&#34;&#34;
        return 1

    def size(self) -&gt; int:
        &#34;&#34;&#34;All terminals have size 1&#34;&#34;&#34;
        return 1

    def to_LaTeX(self, top = True):
        &#34;&#34;&#34;Converts trees to LaTeX expressions using the `qtree` package.
        Remember to include `\\usepackage{qtree}` in the document header. For
        Terminals, the format is `[.$label $leaf]`. The label expression is
        provided by a similar function in Label.

        Parameters
        ----------:
            top (bool): qtrees expressions must be prefixed with `\\Tree`, but
                this only applies to the whole tree: you don&#39;t put it in front
                of every node. However, this function uses recursive calls to
                make the LaTeX of child nodes, so making sure only the top node
                has this prefix takes a bit of extra logic. If the node has no
                parent, the `\\Tree` prefix is automaticaly applied, otherwise
                by default it isn&#39;t. However, if LaTeX is wanted for a partial
                tree, `top` may be set to `True`

        &gt;&gt;&gt; t = test_trees()
        &gt;&gt;&gt; for x in t:
        ...     print(x.to_LaTeX())
        ...
        \Tree [.N poo ]
        \Tree [.S [.N sentence ] [.VP [.V parses ] [.N parser ] ] ]
        \Tree [.S [.N sentence ] [.VP [.V parses ] [.N parser ] ] ]
        \Tree [.S [.N sentence ] [.VP [.V parses ] [.N parser ] ] ]
        \Tree [.S [.NP [.Det the ] [.N sentence ] ] [.VP [.V parses ] [.NP [.Det the ] [.N parser ] ] ] ]
        \Tree [.S [.N word ] [.VP [.V parses ] [.N parser ] ] ]
        \Tree [.S [.N sentence ] [.VP [.V parses ] [.V parser ] ] ]
        \Tree [.S [.X x ] [.Y y ] ]
        &#34;&#34;&#34;
        # prepends \Tree if needed
        LaTeX = r&#34;\Tree &#34; if not (hasattr(self, &#39;parent&#39;) and self.parent) or top else &#34;&#34;
        # LaTeX of the Label is . followed by the label name
        LaTeX += f&#34;[{self.label.to_LaTeX()} {self.leaf} ] &#34;
        return LaTeX.strip() if top else LaTeX

    def __call__(self):
        &#34;&#34;&#34;All nodes are callable, but on Terminals it just returns the leaf.

        Returns
        -------
            The leaf value.

        &gt;&gt;&gt; t = test_trees()[0]
        &gt;&gt;&gt; print(t())
        poo
        &#34;&#34;&#34;
        return self.leaf

    def __getitem__(self, position):
        &#34;&#34;&#34;Returns leaf if index is 0, throws error otherwise.

        Returns
        -------
            leaf

        Raises:
            IndexError: If index is not 0

        &gt;&gt;&gt; t = tree(&#34;([N]&#39;sentence&#39;)&#34;)
        &gt;&gt;&gt; print(t[0])
        sentence
        &gt;&gt;&gt; print(t[0, 0]) # doctest: +IGNORE_EXCEPTION_DETAIL
        Traceback (most recent call last):
        IndexError: Index out of range. The Tree:
        ([N]&#39;sentence&#39;)
        was indexed with:
        (0, 0)
        but does not have a subtree at:
        (0, 0)
        Terminals do not have child nodes.
        &#34;&#34;&#34;
        # If the index at this point is anything other than 0 or (0,), it points
        # to a node that isn&#39;t there, and a custom IndexError should be raised.
        # This shows the string representation of the tree where the error was
        # raised (`self`), the erroneous index (`position`), the index up to and
        # incuding its first erroneous element (`wrong`), and a message
        # indicating what went wrong (`err`)
        if not position in (0, (0,)):
            if type(position) == int:
                position = (position, )
            if position[0] == 0:
                wrong = position[:2]
                err = &#34;Terminals do not have child nodes.&#34;
            else:
                wrong = position[:1]
                err = &#34;Terminals can only be indexed with 0, which returns the terminal content.&#34;
            raise IndexError(
                f&#34;Index out of range. The Tree:\n{self}\nwas indexed with:\n&#34; +
                f&#34;{position}\nbut does not have a subtree at:\n{wrong}\n{err}&#34;
            )
        return self.leaf


    def copy_out(self, treebank = None):
        &#34;&#34;&#34;Generates a deep copy of a Terminal: same Labels, and  same content:
        but a distinct object in memory from the original. If `treebank` is a
        Treebank, The new Terminal will be copied into `treebank`. If `treebank`
        is `None`, a dummy treebank will be created, and the Terminal will be
        copied into that.

        Returns
        -------
            Terminal: copy of original tree

        &#34;&#34;&#34;
        # If `treebank` is not provided...
        if not treebank:
            # ...make a dummy treebank for the copied Terminal to live in
            treebank = Treebank()
        # return the copy Terminal, with `treebank=treebank`
        return Terminal(
            treebank,
            self.label if treebank == self.treebank else treebank.get_label(self.label.classname),
            copy(self.leaf)
        )

    def delete(self, _top = True):
        if _top:
            self.parent.children[self.parent.index_of(self)] = NonTerminal(
                self.treebank, self.label
            )
        else:
            self.parent.children[self.parent.index_of(self)] = None
        self.label.remove_node(self)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="trees.Tree" href="#trees.Tree">Tree</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="trees.Terminal.copy_out"><code class="name flex">
<span>def <span class="ident">copy_out</span></span>(<span>self, treebank=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates a deep copy of a Terminal: same Labels, and
same content:
but a distinct object in memory from the original. If <code>treebank</code> is a
Treebank, The new Terminal will be copied into <code>treebank</code>. If <code>treebank</code>
is <code>None</code>, a dummy treebank will be created, and the Terminal will be
copied into that.</p>
<h2 id="returns">Returns</h2>
<pre><code>Terminal: copy of original tree
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy_out(self, treebank = None):
    &#34;&#34;&#34;Generates a deep copy of a Terminal: same Labels, and  same content:
    but a distinct object in memory from the original. If `treebank` is a
    Treebank, The new Terminal will be copied into `treebank`. If `treebank`
    is `None`, a dummy treebank will be created, and the Terminal will be
    copied into that.

    Returns
    -------
        Terminal: copy of original tree

    &#34;&#34;&#34;
    # If `treebank` is not provided...
    if not treebank:
        # ...make a dummy treebank for the copied Terminal to live in
        treebank = Treebank()
    # return the copy Terminal, with `treebank=treebank`
    return Terminal(
        treebank,
        self.label if treebank == self.treebank else treebank.get_label(self.label.classname),
        copy(self.leaf)
    )</code></pre>
</details>
</dd>
<dt id="trees.Terminal.depth"><code class="name flex">
<span>def <span class="ident">depth</span></span>(<span>self) â€‘>Â int</span>
</code></dt>
<dd>
<div class="desc"><p>All terminals have depth 1</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def depth(self) -&gt; int:
    &#34;&#34;&#34;All terminals have depth 1&#34;&#34;&#34;
    return 1</code></pre>
</details>
</dd>
<dt id="trees.Terminal.size"><code class="name flex">
<span>def <span class="ident">size</span></span>(<span>self) â€‘>Â int</span>
</code></dt>
<dd>
<div class="desc"><p>All terminals have size 1</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def size(self) -&gt; int:
    &#34;&#34;&#34;All terminals have size 1&#34;&#34;&#34;
    return 1</code></pre>
</details>
</dd>
<dt id="trees.Terminal.to_LaTeX"><code class="name flex">
<span>def <span class="ident">to_LaTeX</span></span>(<span>self, top=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Converts trees to LaTeX expressions using the <code>qtree</code> package.
Remember to include <code>\usepackage{qtree}</code> in the document header. For
Terminals, the format is <code>[.$label $leaf]</code>. The label expression is
provided by a similar function in Label.</p>
<p>Parameters
----------:
top (bool): qtrees expressions must be prefixed with <code>\Tree</code>, but
this only applies to the whole tree: you don't put it in front
of every node. However, this function uses recursive calls to
make the LaTeX of child nodes, so making sure only the top node
has this prefix takes a bit of extra logic. If the node has no
parent, the <code>\Tree</code> prefix is automaticaly applied, otherwise
by default it isn't. However, if LaTeX is wanted for a partial
tree, <code>top</code> may be set to <code>True</code></p>
<pre><code class="language-python-repl">&gt;&gt;&gt; t = test_trees()
&gt;&gt;&gt; for x in t:
...     print(x.to_LaTeX())
...
\Tree [.N poo ]
\Tree [.S [.N sentence ] [.VP [.V parses ] [.N parser ] ] ]
\Tree [.S [.N sentence ] [.VP [.V parses ] [.N parser ] ] ]
\Tree [.S [.N sentence ] [.VP [.V parses ] [.N parser ] ] ]
\Tree [.S [.NP [.Det the ] [.N sentence ] ] [.VP [.V parses ] [.NP [.Det the ] [.N parser ] ] ] ]
\Tree [.S [.N word ] [.VP [.V parses ] [.N parser ] ] ]
\Tree [.S [.N sentence ] [.VP [.V parses ] [.V parser ] ] ]
\Tree [.S [.X x ] [.Y y ] ]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_LaTeX(self, top = True):
    &#34;&#34;&#34;Converts trees to LaTeX expressions using the `qtree` package.
    Remember to include `\\usepackage{qtree}` in the document header. For
    Terminals, the format is `[.$label $leaf]`. The label expression is
    provided by a similar function in Label.

    Parameters
    ----------:
        top (bool): qtrees expressions must be prefixed with `\\Tree`, but
            this only applies to the whole tree: you don&#39;t put it in front
            of every node. However, this function uses recursive calls to
            make the LaTeX of child nodes, so making sure only the top node
            has this prefix takes a bit of extra logic. If the node has no
            parent, the `\\Tree` prefix is automaticaly applied, otherwise
            by default it isn&#39;t. However, if LaTeX is wanted for a partial
            tree, `top` may be set to `True`

    &gt;&gt;&gt; t = test_trees()
    &gt;&gt;&gt; for x in t:
    ...     print(x.to_LaTeX())
    ...
    \Tree [.N poo ]
    \Tree [.S [.N sentence ] [.VP [.V parses ] [.N parser ] ] ]
    \Tree [.S [.N sentence ] [.VP [.V parses ] [.N parser ] ] ]
    \Tree [.S [.N sentence ] [.VP [.V parses ] [.N parser ] ] ]
    \Tree [.S [.NP [.Det the ] [.N sentence ] ] [.VP [.V parses ] [.NP [.Det the ] [.N parser ] ] ] ]
    \Tree [.S [.N word ] [.VP [.V parses ] [.N parser ] ] ]
    \Tree [.S [.N sentence ] [.VP [.V parses ] [.V parser ] ] ]
    \Tree [.S [.X x ] [.Y y ] ]
    &#34;&#34;&#34;
    # prepends \Tree if needed
    LaTeX = r&#34;\Tree &#34; if not (hasattr(self, &#39;parent&#39;) and self.parent) or top else &#34;&#34;
    # LaTeX of the Label is . followed by the label name
    LaTeX += f&#34;[{self.label.to_LaTeX()} {self.leaf} ] &#34;
    return LaTeX.strip() if top else LaTeX</code></pre>
</details>
</dd>
<dt id="trees.Terminal.width"><code class="name flex">
<span>def <span class="ident">width</span></span>(<span>self) â€‘>Â int</span>
</code></dt>
<dd>
<div class="desc"><p>All terminals have width 1</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def width(self) -&gt; int:
    &#34;&#34;&#34;All terminals have width 1&#34;&#34;&#34;
    return 1</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="trees.Tree" href="#trees.Tree">Tree</a></b></code>:
<ul class="hlist">
<li><code><a title="trees.Tree.delete" href="#trees.Tree.delete">delete</a></code></li>
<li><code><a title="trees.Tree.label" href="#trees.Tree.label">label</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="trees.Tree"><code class="flex name class">
<span>class <span class="ident">Tree</span></span>
<span>(</span><span>treebank, label)</span>
</code></dt>
<dd>
<div class="desc"><p>Abstract Base Class defining behaviour for all tree nodes.</p>
<p>All trees are labelled, but some have children (lists of tree nodes below
them in the tree structure), and others have leaves - concrete content like
words in syntactic parse trees or constants and variables in Genetic
Programming systems: so the abstract base class contains a constructor that
sets the label, but which the subclasses can extend to add leaves or
children.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>_label</code></strong> :&ensp;<code><a title="trees.Label" href="#trees.Label">Label</a></code></dt>
<dd>Node label determining which subtrees can be substituted
where. Set and got by the <code>label</code> @property</dd>
<dt><strong><code>parent</code></strong> :&ensp;<code><a title="trees.NonTerminal" href="#trees.NonTerminal">NonTerminal</a></code> or <code>None</code></dt>
<dd>The node dirctly above the present in the
tree. Each child has a reference to its parent, and each parent has
references to all its children.</dd>
<dt><strong><code>treebank</code></strong> :&ensp;<code><a title="trees.Treebank" href="#trees.Treebank">Treebank</a></code></dt>
<dd>Every tree belongs to a Treebank, which defines the
set of Labels that <code><a title="trees.Tree" href="#trees.Tree">Tree</a></code>, its parents, and its children can take.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>if the <code>label</code> passed to <code>__init__</code> is not a valid Label.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Tree(ABC):
    &#34;&#34;&#34;Abstract Base Class defining behaviour for all tree nodes.

    All trees are labelled, but some have children (lists of tree nodes below
    them in the tree structure), and others have leaves - concrete content like
    words in syntactic parse trees or constants and variables in Genetic
    Programming systems: so the abstract base class contains a constructor that
    sets the label, but which the subclasses can extend to add leaves or
    children.

    Attributes:
        _label (Label): Node label determining which subtrees can be substituted
            where. Set and got by the `label` @property
        parent (NonTerminal or None): The node dirctly above the present in the
            tree. Each child has a reference to its parent, and each parent has
            references to all its children.
        treebank (Treebank): Every tree belongs to a Treebank, which defines the
            set of Labels that `Tree`, its parents, and its children can take.

    Raises:
        TypeError: if the `label` passed to `__init__` is not a valid Label.
    &#34;&#34;&#34;

    def __init__(self, treebank, label):
        # Set parent to None: parent, if there is one, will set child&#39;s `parent`
        # param
        self.parent = None
        # TODO: Maybe treebank just needs to be in Label - make it a @property
        # here
        self.treebank = treebank
        # DOP uses strings as labels, GP uses types, so those are OK
        if isinstance(label, (str, type)):
            self.label = treebank.get_label(label)
        # Or if a Label is passed as label, that&#39;s fine too
        elif issubclass(type(label), Label):
            self.label = label;
        # Otherwise it can suck it
        else:
            raise TypeError(f&#34;Invalid label of type {type(label)}&#34;)

    @property
    def label(self):
        &#34;&#34;&#34;Label: Attribute storing a node label&#34;&#34;&#34;
        if hasattr(self, &#39;_label&#39;):
            return self._label

    @label.setter
    def label(self, label):
        &#34;&#34;&#34;Setter for label. Ensures that the tree node is registered with its
        label. Deletes label from node if called with `label=None`
        &#34;&#34;&#34;
        if isinstance(label, Label):
            self._label = label
            self.label.add_node(self)
        elif label is None:
            del(self._label)
        else:
            raise TypeError(
                &#34;You can set a label to be a Label, or None, but not &#34; +
                f&#34;{type(label)}.&#34;
            )

    @abstractmethod
    def __len__(self) -&gt; int:
        &#34;&#34;&#34;Number of children&#34;&#34;&#34;
        pass

    def __iter__(self):
        return TreeIter(self)

    def __copy__(self):
        &#34;&#34;&#34;Generates a deep copy of a tree: the same structure, same Labels, and
        for the Terminals, same content: but each node a distinct object in
        memory from the corresponding node in the original. The new NonTerminal
        and its children belong to the same treebank as the original.

        Returns
        -------
            NonTerminal: copy of original tree

        &gt;&gt;&gt; from functools import reduce
        &gt;&gt;&gt; t = test_trees() + test_fragments()
        &gt;&gt;&gt; tcopy = [copy(x) for x in t]
        &gt;&gt;&gt; idents = [id(cp) == id(og) for cp, og in zip(tcopy, t)]
        &gt;&gt;&gt; equals = [cp == og for cp, og in zip(tcopy, t)]
        &gt;&gt;&gt; print(reduce(lambda a, b: a and b, equals))
        True
        &gt;&gt;&gt; print(reduce(lambda a, b: a or b, idents))
        False
        &#34;&#34;&#34;
        return self.copy_out(self.treebank)

    @abstractmethod
    def depth(self) -&gt; int:
        &#34;&#34;&#34;Length of chain from self to it&#39;s most distant descendant-node&#34;&#34;&#34;
        pass

    @abstractmethod
    def width(self) -&gt; int:
        &#34;&#34;&#34;Number of leaf nodes below current&#34;&#34;&#34;
        pass

    @abstractmethod
    def size(self) -&gt; int:
        &#34;&#34;&#34;Number of nodes in tree overall&#34;&#34;&#34;
        pass

    @abstractmethod
    def to_LaTeX(self) -&gt; str:
        &#34;&#34;&#34;Outputs LaTeX representation of tree. Handy for putting in papers&#34;&#34;&#34;
        pass

    @abstractmethod
    def __call__(self):
        &#34;&#34;&#34;All nodes are callable: Terminals return their leaf, always:
        NonTerminals call an Operator that belongs to the Label
        &#34;&#34;&#34;
        pass

    @abstractmethod
    def __eq__(self, other):
        &#34;&#34;&#34;True if two trees are identical&#34;&#34;&#34;
        pass

    @abstractmethod
    def __str__(self):
        &#34;&#34;&#34;Readable printout&#34;&#34;&#34;
        pass

    @abstractmethod
    def __getitem__(self, position):
        &#34;So children can be indexed positionally&#34;
        pass

    @abstractmethod
    def copy_out(self, treebank):
        &#34;&#34;&#34;Copy self with all children. Copy exists in `treebank`.&#34;&#34;&#34;
        pass

    @abstractmethod
    def delete(self):
        &#34;&#34;&#34;Removes a tree and all its descendants from their treebank.&#34;&#34;&#34;
        pass

    def __repr__(self) -&gt; str:
        &#34;&#34;&#34;Returns a string such that tree == eval(tree.__repr__())&#34;&#34;&#34;
        return f&#39;tree(&#34;{str(self)}&#34;)&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="trees.NonTerminal" href="#trees.NonTerminal">NonTerminal</a></li>
<li><a title="trees.Terminal" href="#trees.Terminal">Terminal</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="trees.Tree.label"><code class="name">var <span class="ident">label</span></code></dt>
<dd>
<div class="desc"><p>Label: Attribute storing a node label</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def label(self):
    &#34;&#34;&#34;Label: Attribute storing a node label&#34;&#34;&#34;
    if hasattr(self, &#39;_label&#39;):
        return self._label</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="trees.Tree.copy_out"><code class="name flex">
<span>def <span class="ident">copy_out</span></span>(<span>self, treebank)</span>
</code></dt>
<dd>
<div class="desc"><p>Copy self with all children. Copy exists in <code>treebank</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def copy_out(self, treebank):
    &#34;&#34;&#34;Copy self with all children. Copy exists in `treebank`.&#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="trees.Tree.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Removes a tree and all its descendants from their treebank.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def delete(self):
    &#34;&#34;&#34;Removes a tree and all its descendants from their treebank.&#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="trees.Tree.depth"><code class="name flex">
<span>def <span class="ident">depth</span></span>(<span>self) â€‘>Â int</span>
</code></dt>
<dd>
<div class="desc"><p>Length of chain from self to it's most distant descendant-node</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def depth(self) -&gt; int:
    &#34;&#34;&#34;Length of chain from self to it&#39;s most distant descendant-node&#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="trees.Tree.size"><code class="name flex">
<span>def <span class="ident">size</span></span>(<span>self) â€‘>Â int</span>
</code></dt>
<dd>
<div class="desc"><p>Number of nodes in tree overall</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def size(self) -&gt; int:
    &#34;&#34;&#34;Number of nodes in tree overall&#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="trees.Tree.to_LaTeX"><code class="name flex">
<span>def <span class="ident">to_LaTeX</span></span>(<span>self) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Outputs LaTeX representation of tree. Handy for putting in papers</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def to_LaTeX(self) -&gt; str:
    &#34;&#34;&#34;Outputs LaTeX representation of tree. Handy for putting in papers&#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="trees.Tree.width"><code class="name flex">
<span>def <span class="ident">width</span></span>(<span>self) â€‘>Â int</span>
</code></dt>
<dd>
<div class="desc"><p>Number of leaf nodes below current</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def width(self) -&gt; int:
    &#34;&#34;&#34;Number of leaf nodes below current&#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="trees.TreeIter"><code class="flex name class">
<span>class <span class="ident">TreeIter</span></span>
<span>(</span><span>tree)</span>
</code></dt>
<dd>
<div class="desc"><p>Iterator that iterates over a Tree. This was needed because I wanted to
include informative IndexError messages in the custom <strong>getitem</strong> methods in
Tree, but the default <strong>iter</strong> used catching IndexErrors to tell when the
iteraton was done, which meant that the code used to generate these
informative error messages was running a <em>lot</em>, mostly to no purpose, and
sometimes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TreeIter:
    &#34;&#34;&#34;Iterator that iterates over a Tree. This was needed because I wanted to
    include informative IndexError messages in the custom __getitem__ methods in
    Tree, but the default __iter__ used catching IndexErrors to tell when the
    iteraton was done, which meant that the code used to generate these
    informative error messages was running a *lot*, mostly to no purpose, and
    sometimes
    &#34;&#34;&#34;
    def __init__(self, tree):
        self._pos = 0
        self._tree = tree

    def __iter__(self):
        return self

    def __next__(self):
        if self._pos &lt; len(self._tree):
            self._pos += 1
            return self._tree[self._pos - 1]
        else:
            raise StopIteration</code></pre>
</details>
</dd>
<dt id="trees.Treebank"><code class="flex name class">
<span>class <span class="ident">Treebank</span></span>
<span>(</span><span>operators={&#x27;&#x27;: &lt;function Operators.ID&gt;})</span>
</code></dt>
<dd>
<div class="desc"><p>A <code><a title="trees.Treebank" href="#trees.Treebank">Treebank</a></code> represents a collection of trees as a collection of
node-labels (class <code><a title="trees.Label" href="#trees.Label">Label</a></code>), each of which defines a substitutability class
within the set of <code>Terminals</code> and <code>NonTerminals</code> in the collection of trees,
such that all <code>Terminals</code> and <code>NonTerminals</code> belong to exactly one <code><a title="trees.Label" href="#trees.Label">Label</a></code>
of the <code><a title="trees.Treebank" href="#trees.Treebank">Treebank</a></code>. Implementing an algorithm such as DOP or GP takes only
one <code><a title="trees.Treebank" href="#trees.Treebank">Treebank</a></code>, but using DOP or GP to define agents within a multi-agent
algorithm, multiple <code>Treebanks</code> will be needed - one for each agent. In this
case, each <code><a title="trees.Treebank" href="#trees.Treebank">Treebank</a></code> will be complete and self-contained, with no
<code><a title="trees.Treebank" href="#trees.Treebank">Treebank</a></code> having access to any other <code><a title="trees.Treebank" href="#trees.Treebank">Treebank</a></code>'s <code>Labels</code> or trees.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>classnames</code></strong> :&ensp;<code>dict</code></dt>
<dd><code>dict</code> mapping from each label name to the unique
<code><a title="trees.Label" href="#trees.Label">Label</a></code> with that name.</dd>
<dt><strong><code>operators</code></strong> :&ensp;<code>dict</code> of <code>functions</code></dt>
<dd>A dictionary of functions which define
how the content of a node is generated by combining the contents of
its children. For DOP and other NLP uses, a single default operator
is recommended: <code><a title="trees.Operators.CONCAT" href="#trees.Operators.CONCAT">Operators.CONCAT()</a></code>, which concatenates child strings
with spaces as separators - with the result that the content of a
tree that parses a sentence is the original sentence. However, it is
possible to have a variety of Operators accessed with string keys -
useful for Genetic Programming.</dd>
<dt><strong><code>_default_label</code></strong> :&ensp;<code><a title="trees.Label" href="#trees.Label">Label</a></code></dt>
<dd>Default label to be supplied if a request for a
label is made without specifying which Label is needed.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Treebank:
    &#34;&#34;&#34;
    A `Treebank` represents a collection of trees as a collection of
    node-labels (class `Label`), each of which defines a substitutability class
    within the set of `Terminals` and `NonTerminals` in the collection of trees,
    such that all `Terminals` and `NonTerminals` belong to exactly one `Label`
    of the `Treebank`. Implementing an algorithm such as DOP or GP takes only
    one `Treebank`, but using DOP or GP to define agents within a multi-agent
    algorithm, multiple `Treebanks` will be needed - one for each agent. In this
    case, each `Treebank` will be complete and self-contained, with no
    `Treebank` having access to any other `Treebank`&#39;s `Labels` or trees.

    Attributes:
        classnames (dict): `dict` mapping from each label name to the unique
            `Label` with that name.
        operators (dict of functions): A dictionary of functions which define
            how the content of a node is generated by combining the contents of
            its children. For DOP and other NLP uses, a single default operator
            is recommended: `Operators.CONCAT`, which concatenates child strings
            with spaces as separators - with the result that the content of a
            tree that parses a sentence is the original sentence. However, it is
            possible to have a variety of Operators accessed with string keys -
            useful for Genetic Programming.
        _default_label (Label): Default label to be supplied if a request for a
            label is made without specifying which Label is needed.
    &#34;&#34;&#34;

    def __init__(self, operators = {&#34;&#34;: Operators.ID}):
        self.classnames = {}
        self.operators = operators
        self._default_label = None

    def get_label(self, classname = None):
        &#34;&#34;&#34;Returns the `Label` with the provided `classname`, retrieving the
        existing label if one exists, creating a new one otherwise. If
        `classname == None`, returns the `_default_label` if one exists, raises
        an `AttributeError` otherwise.

        Parameters
        ----------
            classname (str): Name for a category of Trees

        Raises:
            AttributeError: If `classname == None` and no `_default_label` is
                set.

        &gt;&gt;&gt; tb = Treebank()
        &gt;&gt;&gt; tb.get_label() # doctest: +IGNORE_EXCEPTION_DETAIL
        Traceback (most recent call last):
        AttributeError: You cannot create unlabelled trees unless Label._default_label has been set
        &gt;&gt;&gt; print(tb.classnames)
        {}
        &gt;&gt;&gt; x = tb.get_label(&#39;X&#39;)
        &gt;&gt;&gt; print(tb.classnames)
        {&#39;X&#39;: Label(&#39;X&#39;)}
        &gt;&gt;&gt; x1 = tb.get_label(&#39;X&#39;)
        &gt;&gt;&gt; print(tb.classnames)
        {&#39;X&#39;: Label(&#39;X&#39;)}
        &gt;&gt;&gt; y = tb.get_label(&#39;Y&#39;)
        &gt;&gt;&gt; print(tb.classnames)
        {&#39;X&#39;: Label(&#39;X&#39;), &#39;Y&#39;: Label(&#39;Y&#39;)}
        &gt;&gt;&gt; id(x) == id(x1)
        True
        &gt;&gt;&gt; id(x) != id(y)
        True
        &#34;&#34;&#34;
        # If classname is None...
        if not classname:
            # ... return the default label, if it exists...
            if isinstance(self.default_label, Label):
                return self.default_label
            else:
                # ... if it doesn&#39;t, that&#39;s bad.
                raise AttributeError(
                    &#34;You cannot create unlabelled trees unless &#34; +
                    &#34;a default_label has been set&#34;
                )
        # If classname is *not* None, &amp; a label with that name already exists...
        elif classname in self.classnames:
            # ...get that label from the dict and return it...
            return self.classnames[classname]
        else:
            #...or, if it doesn&#39;t, then create it. The Label.__init__ method
            # will ensure the new Label goes in the dict.
            return Label(
                self,
                classname,
                self.operators[classname] if classname in self.operators else self.operators[&#34;&#34;]
            )

    @property
    def default_label(self):
        &#34;&#34;&#34;Class attribute used where unlabelled nodes are needed - i.e. all
        nodes belong to the same category. Since the Label class is used to
        manage node substitution, a single default Label object is still
        needed for this.&#34;&#34;&#34;
        return self._default_label

    @default_label.setter
    def default_label(self, deflab):
        &#34;&#34;&#34;Setter for _default_label. Checks that the `Label` is indeed a
        `Label`.

        Parameters
        ----------
            deflab (Label): the default label.

        Raises:
            TypeError: If the `deflab` isn&#39;t a Label
        &#34;&#34;&#34;
        if type(deflab) is Label:
            if self._default_label:
                self._default_label.is_default = False
            deflab.is_default = True
            self._default_label = deflab
        else:
            raise TypeError(
                f&#34;The default Label needs to be a {Label}, not a {type(deflab)}&#34;
            )

    def add_label(self, label):
        &#34;&#34;&#34;Adds a new Label to the Treebank.

        Parameters
        ----------
            label (Label): the new Label.

        Raises:
            AttributeError: If `label` isn&#39;t a Label.
        &#34;&#34;&#34;
        if label.classname in self.classnames:
            raise AttributeError(
                f&#34;The Treebank already contains a label named {label.classname}&#34;
            )
        else:
            self.classnames[label.classname] = label

    def make_class_name(self): #
        &#34;&#34;&#34;Makes up a classname if one is needed but none is supplied.

        Returns
        -------
            name (str): String of the form &#39;L&#39; + an int equal to the number of
                already existing labels
        &#34;&#34;&#34;
        name = &#34;L&#34; + str(len(self.classnames)) #If there are 5 labels
        #already, this will be L5, for example
        return name

    def print_all_labels(self, is_LaTeX=False):
        &#34;&#34;&#34;A helper class for testing and inspection, mostly. Prints out all
        trees from all `Labels` in the `Treebank`, either using `__str__` or
        `to_LaTeX`.

        Parameters
        ----------
            is_LaTeX (bool): if true, print the trees in LaTeX `qtree` format:
                otherwise just use the standard str format
        &#34;&#34;&#34;
        # make this a variable to ensure consistency
        spacer = &#34;======================&#34;
        print(spacer)
        # Label.classnames is a dict, so the loop can get the names *and* Labels
        for name, label in self.classnames.items():
            print(f&#34;{name}:&#34;)
            label.print_terminal_subtrees(is_LaTeX)
            print(spacer)

    def clear(self):
        &#34;&#34;&#34;Erases the entire treebank. Handle with care.&#34;&#34;&#34;
        self.classnames = {}

    def get_all_root_nodes(self) -&gt; Dict[str, List[Tree]]:
        &#34;&#34;&#34;Generates a dict containing all the Label names as keys, and the list
        of all treenodes in that label which have no parent node. Labels
        containing no root nodes
        &#34;&#34;&#34;
        return {name: val.roots for name, val in self.classnames.items()}

    def tree(self, treestr: str):
        &#34;&#34;&#34;
        Creates a Tree from a string. The string format is for a NonTerminal is:

            `&#39;([$label]{$node_data}($child)*)&#39;`

        ...where `$label` is the name of the `Label` on the node, `{$node_data}`
        an optional `dict` containing metadata for the node, and ($child) is
        the Tree.__str__() representation of each of the node&#39;s children. The
        string format for a Terminal is:

            `&#39;([$label]{$node_data}$leaf)&#39;`

        ... where `$leaf` is the the terminal content of the node â€” for
        instance, a string literal representing a word in a parse of a sentence.
        If `$leaf` cannot be evaluated with `eval`, it is cast to a `str`.

        Parameters
        ----------
            treestr (str): A treestring in the same format that Tree.__str__()
                outputs

        Returns
        -------
            Tree: A Tree, such that treestr == tree(treestr).__str__()

        Raises:
            AttributeError: if `treestr` is malformed.

        &gt;&gt;&gt; tb = Treebank()
        &gt;&gt;&gt; t = tb.tree(&#34;([S]([N]sentence)([VP]([V]parses)([N]parser)))&#34;)
        &gt;&gt;&gt; print(t)
        ([S]([N]&#39;sentence&#39;)([VP]([V]&#39;parses&#39;)([N]&#39;parser&#39;)))
        &gt;&gt;&gt; tt = eval(repr(t))
        &gt;&gt;&gt; print(tt)
        ([S]([N]&#39;sentence&#39;)([VP]([V]&#39;parses&#39;)([N]&#39;parser&#39;)))
        &gt;&gt;&gt; print(tt())
        (&#39;sentence&#39;, (&#39;parses&#39;, &#39;parser&#39;))
        &gt;&gt;&gt; #Label.print_all_labels()
        &#34;&#34;&#34;
        # if the treestr is valid, this regex will have exactly one match
        m = re.match(
            r&#34;\((\[(?P&lt;label&gt;[^\]]*)\])?(?P&lt;node_data&gt;\{.*\})?((?P&lt;children&gt;\(.*\)*?)|(?P&lt;leaf&gt;.*))\)&#34;,
            treestr
        )
        if m:
            # Capture groups from the regex:
            # Node label. Can be empty if default_label is set in Label (TESTME)
            lab = m.group(&#34;label&#34;)
            # Metadata on node. Placeholder, for now.
            node_data = m.group(&#34;node_data&#34;)
            # children are other nodes under the present node; leaf is element
            # of the content the tree ranges over - typically a str for DOP, a
            # float for GP
            children = m.group(&#34;children&#34;)
            leaf = m.group(&#34;leaf&#34;)
        else:
            # Throw an error of treestr not valid
            raise AttributeError(f&#34;Malformed treestring: {treestr}&#34;)
        # gets new Label if no existing label has name `lab`, else gets existing
        # Label: or, if `lab` does not exist, gets the default Label
        the_label = self.get_label(lab) if lab else self.get_label()
        # Empty list for children. If no children or leaf, this is a
        # non-terminal leaf node
        child_list = []
        if leaf:
            # Awkward alias for the relevant Terminal subclass __init__ method
            # to create new Terminal with leaf
            return Terminal(self, the_label, leaf)
        # If there are children, make trees for them
        elif children:
            # Parens demarcate a child: However, a child may also have children,
            # so to distinguish between brackets of the immediate child and
            # further downstream children, we must tack the bracketing level:
            # `level` keeps track of the number of unclosed brackets. If the
            # level drops to zero, the last paren character is the end of the
            # last child substring, and the next paren character, if there is
            # one, is the start of the next
            level = 0
            # Iterate through the chracters in the `children` substring,
            # add them to `current_child`
            current_child = &#34;&#34;
            for char in children:
                current_child += char
                # add parens to the count when `&#39;(&#39;` is found
                if char == &#34;(&#34;:
                    level += 1
                # remove parens from the count when `&#39;)&#39;` is found
                elif char == &#34;)&#34;:
                    level -= 1
                    # and the next paren character, if there is one, is the
                    # start of the next
                    if level == 0:
                        # If the level drops to zero, the last paren character
                        # is the end of the last child substring...
                        child_list.append(self.tree(current_child))
                        # ...and the next paren character, if there is one, is
                        # the start of the next
                        current_child = &#34;&#34;
                    elif level &lt; 0:
                        # raise an exception if parens are unbalanced
                        raise AttributeError(
                            f&#34;Your treestr&#39;s representations of its children \
                            is malformed: {children}&#34;
                        )
                elif level == 0:
                    raise AttributeError(
                        f&#34;Your treestr, contains stray text between the string \
                        representations of its children: {children}&#34;
                    )
            if level != 0:
                raise AttributeError(
                    f&#34;Your treestr&#39;s representations of its children has \
                    unbalanced parentheses: {children}&#34;
                )
        # alias for the constructor of the relevant NonTerminal: creates and
        # returns new NonTerminal with the right label and children
        return NonTerminal(self, the_label, *child_list)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="trees.Treebank.default_label"><code class="name">var <span class="ident">default_label</span></code></dt>
<dd>
<div class="desc"><p>Class attribute used where unlabelled nodes are needed - i.e. all
nodes belong to the same category. Since the Label class is used to
manage node substitution, a single default Label object is still
needed for this.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def default_label(self):
    &#34;&#34;&#34;Class attribute used where unlabelled nodes are needed - i.e. all
    nodes belong to the same category. Since the Label class is used to
    manage node substitution, a single default Label object is still
    needed for this.&#34;&#34;&#34;
    return self._default_label</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="trees.Treebank.add_label"><code class="name flex">
<span>def <span class="ident">add_label</span></span>(<span>self, label)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a new Label to the Treebank.</p>
<h2 id="parameters">Parameters</h2>
<pre><code>label (Label): the new Label.
</code></pre>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>AttributeError</code></dt>
<dd>If <code>label</code> isn't a Label.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_label(self, label):
    &#34;&#34;&#34;Adds a new Label to the Treebank.

    Parameters
    ----------
        label (Label): the new Label.

    Raises:
        AttributeError: If `label` isn&#39;t a Label.
    &#34;&#34;&#34;
    if label.classname in self.classnames:
        raise AttributeError(
            f&#34;The Treebank already contains a label named {label.classname}&#34;
        )
    else:
        self.classnames[label.classname] = label</code></pre>
</details>
</dd>
<dt id="trees.Treebank.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Erases the entire treebank. Handle with care.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear(self):
    &#34;&#34;&#34;Erases the entire treebank. Handle with care.&#34;&#34;&#34;
    self.classnames = {}</code></pre>
</details>
</dd>
<dt id="trees.Treebank.get_all_root_nodes"><code class="name flex">
<span>def <span class="ident">get_all_root_nodes</span></span>(<span>self) â€‘>Â Dict[str,Â List[<a title="trees.Tree" href="#trees.Tree">Tree</a>]]</span>
</code></dt>
<dd>
<div class="desc"><p>Generates a dict containing all the Label names as keys, and the list
of all treenodes in that label which have no parent node. Labels
containing no root nodes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_all_root_nodes(self) -&gt; Dict[str, List[Tree]]:
    &#34;&#34;&#34;Generates a dict containing all the Label names as keys, and the list
    of all treenodes in that label which have no parent node. Labels
    containing no root nodes
    &#34;&#34;&#34;
    return {name: val.roots for name, val in self.classnames.items()}</code></pre>
</details>
</dd>
<dt id="trees.Treebank.get_label"><code class="name flex">
<span>def <span class="ident">get_label</span></span>(<span>self, classname=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the <code><a title="trees.Label" href="#trees.Label">Label</a></code> with the provided <code>classname</code>, retrieving the
existing label if one exists, creating a new one otherwise. If
<code>classname == None</code>, returns the <code>_default_label</code> if one exists, raises
an <code>AttributeError</code> otherwise.</p>
<h2 id="parameters">Parameters</h2>
<pre><code>classname (str): Name for a category of Trees
</code></pre>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>AttributeError</code></dt>
<dd>If <code>classname == None</code> and no <code>_default_label</code> is
set.</dd>
</dl>
<pre><code class="language-python-repl">&gt;&gt;&gt; tb = Treebank()
&gt;&gt;&gt; tb.get_label() # doctest: +IGNORE_EXCEPTION_DETAIL
Traceback (most recent call last):
AttributeError: You cannot create unlabelled trees unless Label._default_label has been set
&gt;&gt;&gt; print(tb.classnames)
{}
&gt;&gt;&gt; x = tb.get_label('X')
&gt;&gt;&gt; print(tb.classnames)
{'X': Label('X')}
&gt;&gt;&gt; x1 = tb.get_label('X')
&gt;&gt;&gt; print(tb.classnames)
{'X': Label('X')}
&gt;&gt;&gt; y = tb.get_label('Y')
&gt;&gt;&gt; print(tb.classnames)
{'X': Label('X'), 'Y': Label('Y')}
&gt;&gt;&gt; id(x) == id(x1)
True
&gt;&gt;&gt; id(x) != id(y)
True
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_label(self, classname = None):
    &#34;&#34;&#34;Returns the `Label` with the provided `classname`, retrieving the
    existing label if one exists, creating a new one otherwise. If
    `classname == None`, returns the `_default_label` if one exists, raises
    an `AttributeError` otherwise.

    Parameters
    ----------
        classname (str): Name for a category of Trees

    Raises:
        AttributeError: If `classname == None` and no `_default_label` is
            set.

    &gt;&gt;&gt; tb = Treebank()
    &gt;&gt;&gt; tb.get_label() # doctest: +IGNORE_EXCEPTION_DETAIL
    Traceback (most recent call last):
    AttributeError: You cannot create unlabelled trees unless Label._default_label has been set
    &gt;&gt;&gt; print(tb.classnames)
    {}
    &gt;&gt;&gt; x = tb.get_label(&#39;X&#39;)
    &gt;&gt;&gt; print(tb.classnames)
    {&#39;X&#39;: Label(&#39;X&#39;)}
    &gt;&gt;&gt; x1 = tb.get_label(&#39;X&#39;)
    &gt;&gt;&gt; print(tb.classnames)
    {&#39;X&#39;: Label(&#39;X&#39;)}
    &gt;&gt;&gt; y = tb.get_label(&#39;Y&#39;)
    &gt;&gt;&gt; print(tb.classnames)
    {&#39;X&#39;: Label(&#39;X&#39;), &#39;Y&#39;: Label(&#39;Y&#39;)}
    &gt;&gt;&gt; id(x) == id(x1)
    True
    &gt;&gt;&gt; id(x) != id(y)
    True
    &#34;&#34;&#34;
    # If classname is None...
    if not classname:
        # ... return the default label, if it exists...
        if isinstance(self.default_label, Label):
            return self.default_label
        else:
            # ... if it doesn&#39;t, that&#39;s bad.
            raise AttributeError(
                &#34;You cannot create unlabelled trees unless &#34; +
                &#34;a default_label has been set&#34;
            )
    # If classname is *not* None, &amp; a label with that name already exists...
    elif classname in self.classnames:
        # ...get that label from the dict and return it...
        return self.classnames[classname]
    else:
        #...or, if it doesn&#39;t, then create it. The Label.__init__ method
        # will ensure the new Label goes in the dict.
        return Label(
            self,
            classname,
            self.operators[classname] if classname in self.operators else self.operators[&#34;&#34;]
        )</code></pre>
</details>
</dd>
<dt id="trees.Treebank.make_class_name"><code class="name flex">
<span>def <span class="ident">make_class_name</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Makes up a classname if one is needed but none is supplied.</p>
<h2 id="returns">Returns</h2>
<pre><code>name (str): String of the form 'L' + an int equal to the number of
    already existing labels
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_class_name(self): #
    &#34;&#34;&#34;Makes up a classname if one is needed but none is supplied.

    Returns
    -------
        name (str): String of the form &#39;L&#39; + an int equal to the number of
            already existing labels
    &#34;&#34;&#34;
    name = &#34;L&#34; + str(len(self.classnames)) #If there are 5 labels
    #already, this will be L5, for example
    return name</code></pre>
</details>
</dd>
<dt id="trees.Treebank.print_all_labels"><code class="name flex">
<span>def <span class="ident">print_all_labels</span></span>(<span>self, is_LaTeX=False)</span>
</code></dt>
<dd>
<div class="desc"><p>A helper class for testing and inspection, mostly. Prints out all
trees from all <code>Labels</code> in the <code><a title="trees.Treebank" href="#trees.Treebank">Treebank</a></code>, either using <code>__str__</code> or
<code>to_LaTeX</code>.</p>
<h2 id="parameters">Parameters</h2>
<pre><code>is_LaTeX (bool): if true, print the trees in LaTeX &lt;code&gt;qtree&lt;/code&gt; format:
    otherwise just use the standard str format
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_all_labels(self, is_LaTeX=False):
    &#34;&#34;&#34;A helper class for testing and inspection, mostly. Prints out all
    trees from all `Labels` in the `Treebank`, either using `__str__` or
    `to_LaTeX`.

    Parameters
    ----------
        is_LaTeX (bool): if true, print the trees in LaTeX `qtree` format:
            otherwise just use the standard str format
    &#34;&#34;&#34;
    # make this a variable to ensure consistency
    spacer = &#34;======================&#34;
    print(spacer)
    # Label.classnames is a dict, so the loop can get the names *and* Labels
    for name, label in self.classnames.items():
        print(f&#34;{name}:&#34;)
        label.print_terminal_subtrees(is_LaTeX)
        print(spacer)</code></pre>
</details>
</dd>
<dt id="trees.Treebank.tree"><code class="name flex">
<span>def <span class="ident">tree</span></span>(<span>self, treestr:Â str)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a Tree from a string. The string format is for a NonTerminal is:</p>
<pre><code>`'([$label]{$node_data}($child)*)'`
</code></pre>
<p>&hellip;where <code>$label</code> is the name of the <code><a title="trees.Label" href="#trees.Label">Label</a></code> on the node, <code>{$node_data}</code>
an optional <code>dict</code> containing metadata for the node, and ($child) is
the Tree.<strong>str</strong>() representation of each of the node's children. The
string format for a Terminal is:</p>
<pre><code>`'([$label]{$node_data}$leaf)'`
</code></pre>
<p>&hellip; where <code>$leaf</code> is the the terminal content of the node â€” for
instance, a string literal representing a word in a parse of a sentence.
If <code>$leaf</code> cannot be evaluated with <code>eval</code>, it is cast to a <code>str</code>.</p>
<h2 id="parameters">Parameters</h2>
<pre><code>treestr (str): A treestring in the same format that Tree.__str__()
    outputs
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>Tree: A Tree, such that treestr == tree(treestr).__str__()
</code></pre>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>AttributeError</code></dt>
<dd>if <code>treestr</code> is malformed.</dd>
</dl>
<pre><code class="language-python-repl">&gt;&gt;&gt; tb = Treebank()
&gt;&gt;&gt; t = tb.tree(&quot;([S]([N]sentence)([VP]([V]parses)([N]parser)))&quot;)
&gt;&gt;&gt; print(t)
([S]([N]'sentence')([VP]([V]'parses')([N]'parser')))
&gt;&gt;&gt; tt = eval(repr(t))
&gt;&gt;&gt; print(tt)
([S]([N]'sentence')([VP]([V]'parses')([N]'parser')))
&gt;&gt;&gt; print(tt())
('sentence', ('parses', 'parser'))
&gt;&gt;&gt; #Label.print_all_labels()
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tree(self, treestr: str):
    &#34;&#34;&#34;
    Creates a Tree from a string. The string format is for a NonTerminal is:

        `&#39;([$label]{$node_data}($child)*)&#39;`

    ...where `$label` is the name of the `Label` on the node, `{$node_data}`
    an optional `dict` containing metadata for the node, and ($child) is
    the Tree.__str__() representation of each of the node&#39;s children. The
    string format for a Terminal is:

        `&#39;([$label]{$node_data}$leaf)&#39;`

    ... where `$leaf` is the the terminal content of the node â€” for
    instance, a string literal representing a word in a parse of a sentence.
    If `$leaf` cannot be evaluated with `eval`, it is cast to a `str`.

    Parameters
    ----------
        treestr (str): A treestring in the same format that Tree.__str__()
            outputs

    Returns
    -------
        Tree: A Tree, such that treestr == tree(treestr).__str__()

    Raises:
        AttributeError: if `treestr` is malformed.

    &gt;&gt;&gt; tb = Treebank()
    &gt;&gt;&gt; t = tb.tree(&#34;([S]([N]sentence)([VP]([V]parses)([N]parser)))&#34;)
    &gt;&gt;&gt; print(t)
    ([S]([N]&#39;sentence&#39;)([VP]([V]&#39;parses&#39;)([N]&#39;parser&#39;)))
    &gt;&gt;&gt; tt = eval(repr(t))
    &gt;&gt;&gt; print(tt)
    ([S]([N]&#39;sentence&#39;)([VP]([V]&#39;parses&#39;)([N]&#39;parser&#39;)))
    &gt;&gt;&gt; print(tt())
    (&#39;sentence&#39;, (&#39;parses&#39;, &#39;parser&#39;))
    &gt;&gt;&gt; #Label.print_all_labels()
    &#34;&#34;&#34;
    # if the treestr is valid, this regex will have exactly one match
    m = re.match(
        r&#34;\((\[(?P&lt;label&gt;[^\]]*)\])?(?P&lt;node_data&gt;\{.*\})?((?P&lt;children&gt;\(.*\)*?)|(?P&lt;leaf&gt;.*))\)&#34;,
        treestr
    )
    if m:
        # Capture groups from the regex:
        # Node label. Can be empty if default_label is set in Label (TESTME)
        lab = m.group(&#34;label&#34;)
        # Metadata on node. Placeholder, for now.
        node_data = m.group(&#34;node_data&#34;)
        # children are other nodes under the present node; leaf is element
        # of the content the tree ranges over - typically a str for DOP, a
        # float for GP
        children = m.group(&#34;children&#34;)
        leaf = m.group(&#34;leaf&#34;)
    else:
        # Throw an error of treestr not valid
        raise AttributeError(f&#34;Malformed treestring: {treestr}&#34;)
    # gets new Label if no existing label has name `lab`, else gets existing
    # Label: or, if `lab` does not exist, gets the default Label
    the_label = self.get_label(lab) if lab else self.get_label()
    # Empty list for children. If no children or leaf, this is a
    # non-terminal leaf node
    child_list = []
    if leaf:
        # Awkward alias for the relevant Terminal subclass __init__ method
        # to create new Terminal with leaf
        return Terminal(self, the_label, leaf)
    # If there are children, make trees for them
    elif children:
        # Parens demarcate a child: However, a child may also have children,
        # so to distinguish between brackets of the immediate child and
        # further downstream children, we must tack the bracketing level:
        # `level` keeps track of the number of unclosed brackets. If the
        # level drops to zero, the last paren character is the end of the
        # last child substring, and the next paren character, if there is
        # one, is the start of the next
        level = 0
        # Iterate through the chracters in the `children` substring,
        # add them to `current_child`
        current_child = &#34;&#34;
        for char in children:
            current_child += char
            # add parens to the count when `&#39;(&#39;` is found
            if char == &#34;(&#34;:
                level += 1
            # remove parens from the count when `&#39;)&#39;` is found
            elif char == &#34;)&#34;:
                level -= 1
                # and the next paren character, if there is one, is the
                # start of the next
                if level == 0:
                    # If the level drops to zero, the last paren character
                    # is the end of the last child substring...
                    child_list.append(self.tree(current_child))
                    # ...and the next paren character, if there is one, is
                    # the start of the next
                    current_child = &#34;&#34;
                elif level &lt; 0:
                    # raise an exception if parens are unbalanced
                    raise AttributeError(
                        f&#34;Your treestr&#39;s representations of its children \
                        is malformed: {children}&#34;
                    )
            elif level == 0:
                raise AttributeError(
                    f&#34;Your treestr, contains stray text between the string \
                    representations of its children: {children}&#34;
                )
        if level != 0:
            raise AttributeError(
                f&#34;Your treestr&#39;s representations of its children has \
                unbalanced parentheses: {children}&#34;
            )
    # alias for the constructor of the relevant NonTerminal: creates and
    # returns new NonTerminal with the right label and children
    return NonTerminal(self, the_label, *child_list)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="trees.TreebankIO"><code class="flex name class">
<span>class <span class="ident">TreebankIO</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for protocol classes.</p>
<p>Protocol classes are defined as::</p>
<pre><code>class Proto(Protocol):
    def meth(self) -&gt; int:
        ...
</code></pre>
<p>Such classes are primarily used with static type checkers that recognize
structural subtyping (static duck-typing), for example::</p>
<pre><code>class C:
    def meth(self) -&gt; int:
        return 0

def func(x: Proto) -&gt; int:
    return x.meth()

func(C())  # Passes static type check
</code></pre>
<p>See PEP 544 for details. Protocol classes decorated with
@typing.runtime_checkable act as simple-minded runtime protocols that check
only the presence of given attributes, ignoring their type signatures.
Protocol classes can be generic, they are defined as::</p>
<pre><code>class GenProto(Protocol[T]):
    def meth(self) -&gt; T:
        ...
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@runtime_checkable
class TreebankIO(Protocol):
    # def __init__(self, tree_type: type):
    #     ...

    def load(cls, filename: str, clear: bool):
        ...

    def save(cls, filename: str):
        ...</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="trees.TreebankIO.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>cls, filename:Â str, clear:Â bool)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load(cls, filename: str, clear: bool):
    ...</code></pre>
</details>
</dd>
<dt id="trees.TreebankIO.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>cls, filename:Â str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(cls, filename: str):
    ...</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="trees.main" href="#trees.main">main</a></code></li>
<li><code><a title="trees.test_fragments" href="#trees.test_fragments">test_fragments</a></code></li>
<li><code><a title="trees.test_trees" href="#trees.test_trees">test_trees</a></code></li>
<li><code><a title="trees.tree" href="#trees.tree">tree</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="trees.JSONIO" href="#trees.JSONIO">JSONIO</a></code></h4>
<ul class="">
<li><code><a title="trees.JSONIO.from_json" href="#trees.JSONIO.from_json">from_json</a></code></li>
<li><code><a title="trees.JSONIO.load" href="#trees.JSONIO.load">load</a></code></li>
<li><code><a title="trees.JSONIO.save" href="#trees.JSONIO.save">save</a></code></li>
<li><code><a title="trees.JSONIO.to_json" href="#trees.JSONIO.to_json">to_json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="trees.JSONiser" href="#trees.JSONiser">JSONiser</a></code></h4>
<ul class="">
<li><code><a title="trees.JSONiser.from_json" href="#trees.JSONiser.from_json">from_json</a></code></li>
<li><code><a title="trees.JSONiser.load" href="#trees.JSONiser.load">load</a></code></li>
<li><code><a title="trees.JSONiser.save" href="#trees.JSONiser.save">save</a></code></li>
<li><code><a title="trees.JSONiser.to_json" href="#trees.JSONiser.to_json">to_json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="trees.Label" href="#trees.Label">Label</a></code></h4>
<ul class="">
<li><code><a title="trees.Label.add_node" href="#trees.Label.add_node">add_node</a></code></li>
<li><code><a title="trees.Label.classname" href="#trees.Label.classname">classname</a></code></li>
<li><code><a title="trees.Label.print_terminal_subtrees" href="#trees.Label.print_terminal_subtrees">print_terminal_subtrees</a></code></li>
<li><code><a title="trees.Label.remove_node" href="#trees.Label.remove_node">remove_node</a></code></li>
<li><code><a title="trees.Label.roots" href="#trees.Label.roots">roots</a></code></li>
<li><code><a title="trees.Label.to_LaTeX" href="#trees.Label.to_LaTeX">to_LaTeX</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="trees.NonTerminal" href="#trees.NonTerminal">NonTerminal</a></code></h4>
<ul class="">
<li><code><a title="trees.NonTerminal.STRICT_ADDITION" href="#trees.NonTerminal.STRICT_ADDITION">STRICT_ADDITION</a></code></li>
<li><code><a title="trees.NonTerminal.add_permissive" href="#trees.NonTerminal.add_permissive">add_permissive</a></code></li>
<li><code><a title="trees.NonTerminal.add_strict" href="#trees.NonTerminal.add_strict">add_strict</a></code></li>
<li><code><a title="trees.NonTerminal.children" href="#trees.NonTerminal.children">children</a></code></li>
<li><code><a title="trees.NonTerminal.copy_out" href="#trees.NonTerminal.copy_out">copy_out</a></code></li>
<li><code><a title="trees.NonTerminal.delete" href="#trees.NonTerminal.delete">delete</a></code></li>
<li><code><a title="trees.NonTerminal.depth" href="#trees.NonTerminal.depth">depth</a></code></li>
<li><code><a title="trees.NonTerminal.get_all_substitition_sites" href="#trees.NonTerminal.get_all_substitition_sites">get_all_substitition_sites</a></code></li>
<li><code><a title="trees.NonTerminal.get_leftmost_substition_site" href="#trees.NonTerminal.get_leftmost_substition_site">get_leftmost_substition_site</a></code></li>
<li><code><a title="trees.NonTerminal.index_of" href="#trees.NonTerminal.index_of">index_of</a></code></li>
<li><code><a title="trees.NonTerminal.size" href="#trees.NonTerminal.size">size</a></code></li>
<li><code><a title="trees.NonTerminal.to_LaTeX" href="#trees.NonTerminal.to_LaTeX">to_LaTeX</a></code></li>
<li><code><a title="trees.NonTerminal.width" href="#trees.NonTerminal.width">width</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="trees.Operators" href="#trees.Operators">Operators</a></code></h4>
<ul class="">
<li><code><a title="trees.Operators.CONCAT" href="#trees.Operators.CONCAT">CONCAT</a></code></li>
<li><code><a title="trees.Operators.ID" href="#trees.Operators.ID">ID</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="trees.SubstitutionSite" href="#trees.SubstitutionSite">SubstitutionSite</a></code></h4>
<ul class="">
<li><code><a title="trees.SubstitutionSite.index" href="#trees.SubstitutionSite.index">index</a></code></li>
<li><code><a title="trees.SubstitutionSite.label" href="#trees.SubstitutionSite.label">label</a></code></li>
<li><code><a title="trees.SubstitutionSite.parent" href="#trees.SubstitutionSite.parent">parent</a></code></li>
<li><code><a title="trees.SubstitutionSite.perform_substitution" href="#trees.SubstitutionSite.perform_substitution">perform_substitution</a></code></li>
<li><code><a title="trees.SubstitutionSite.site" href="#trees.SubstitutionSite.site">site</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="trees.Terminal" href="#trees.Terminal">Terminal</a></code></h4>
<ul class="">
<li><code><a title="trees.Terminal.copy_out" href="#trees.Terminal.copy_out">copy_out</a></code></li>
<li><code><a title="trees.Terminal.depth" href="#trees.Terminal.depth">depth</a></code></li>
<li><code><a title="trees.Terminal.size" href="#trees.Terminal.size">size</a></code></li>
<li><code><a title="trees.Terminal.to_LaTeX" href="#trees.Terminal.to_LaTeX">to_LaTeX</a></code></li>
<li><code><a title="trees.Terminal.width" href="#trees.Terminal.width">width</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="trees.Tree" href="#trees.Tree">Tree</a></code></h4>
<ul class="two-column">
<li><code><a title="trees.Tree.copy_out" href="#trees.Tree.copy_out">copy_out</a></code></li>
<li><code><a title="trees.Tree.delete" href="#trees.Tree.delete">delete</a></code></li>
<li><code><a title="trees.Tree.depth" href="#trees.Tree.depth">depth</a></code></li>
<li><code><a title="trees.Tree.label" href="#trees.Tree.label">label</a></code></li>
<li><code><a title="trees.Tree.size" href="#trees.Tree.size">size</a></code></li>
<li><code><a title="trees.Tree.to_LaTeX" href="#trees.Tree.to_LaTeX">to_LaTeX</a></code></li>
<li><code><a title="trees.Tree.width" href="#trees.Tree.width">width</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="trees.TreeIter" href="#trees.TreeIter">TreeIter</a></code></h4>
</li>
<li>
<h4><code><a title="trees.Treebank" href="#trees.Treebank">Treebank</a></code></h4>
<ul class="two-column">
<li><code><a title="trees.Treebank.add_label" href="#trees.Treebank.add_label">add_label</a></code></li>
<li><code><a title="trees.Treebank.clear" href="#trees.Treebank.clear">clear</a></code></li>
<li><code><a title="trees.Treebank.default_label" href="#trees.Treebank.default_label">default_label</a></code></li>
<li><code><a title="trees.Treebank.get_all_root_nodes" href="#trees.Treebank.get_all_root_nodes">get_all_root_nodes</a></code></li>
<li><code><a title="trees.Treebank.get_label" href="#trees.Treebank.get_label">get_label</a></code></li>
<li><code><a title="trees.Treebank.make_class_name" href="#trees.Treebank.make_class_name">make_class_name</a></code></li>
<li><code><a title="trees.Treebank.print_all_labels" href="#trees.Treebank.print_all_labels">print_all_labels</a></code></li>
<li><code><a title="trees.Treebank.tree" href="#trees.Treebank.tree">tree</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="trees.TreebankIO" href="#trees.TreebankIO">TreebankIO</a></code></h4>
<ul class="">
<li><code><a title="trees.TreebankIO.load" href="#trees.TreebankIO.load">load</a></code></li>
<li><code><a title="trees.TreebankIO.save" href="#trees.TreebankIO.save">save</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>