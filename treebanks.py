import re
# from copy import copy
import pandas as pd
from typing import Dict, List#, Type, Union, Tuple
from tree_errors import OperatorError
from operators import ID
import trees as tr
from type_ify import TypeNativiser
#Terminal, NonTerminal, Label, TypeLabel, Tree

class Treebank:
    """
    A `Treebank` represents a collection of trees as a collection of
    node-labels (class `Label`), each of which defines a substitutability class
    within the set of `Terminals` and `NonTerminals` in the collection of trees,
    such that all `Terminals` and `NonTerminals` belong to exactly one `Label`
    of the `Treebank`. Implementing an algorithm such as DOP or GP takes only
    one `Treebank`, but using DOP or GP to define agents within a multi-agent
    algorithm, multiple `Treebanks` will be needed - one for each agent. In this
    case, each `Treebank` will be complete and self-contained, with no
    `Treebank` having access to any other `Treebank`'s `Labels` or trees.

    Attributes:
        labels (dict): `dict` mapping from each label name to the unique
            `Label` with that name.
        operators (dict of Operators): A dictionary of functions which define
            how the content of a node is generated by combining the contents of
            its children. For DOP and other NLP uses, a single default operator
            is recommended: `ops.CONCAT`, which concatenates child strings
            with spaces as separators - with the result that the content of a
            tree that parses a sentence is the original sentence. However, it is
            possible to have a variety of Operators accessed with string keys -
            useful for Genetic Programming.
        _default_op (Operator) = if `operators` contains a value mapped to "",
            that operator is the default, which is given to NonTerminal if they
            are initialised without an operator specified.
        _default_label (Label): Default label to be supplied if a request for a
            label is made without specifying which Label is needed.
    """

    STRICT_ADDITION = True

    def __init__(self, default_op = None, operators = None, leaf_def_op = None, T=None, N=None, SS=None):
        self.T = T if T else tr.Terminal
        self.N = N if N else tr.NonTerminal
        self.SS = SS if SS else tr.SubstitutionSite
        if operators is None:
            operators = []
        self.labels = {}
        self._default_label = None
        self.operators = {}
        self.leaf_def_op = leaf_def_op
        if not default_op and not operators:
            default_op = ID
        if default_op:
            if type(default_op) != list:
                default_op.name = ""
                operators.append(default_op)
            else:
                operators += default_op
        for op in operators:
            self.operators[op.name] = op

    @property
    def default_op(self):
        return self.operators.get("", None)

    def get_label(self, class_id = None):
        """Returns the `Label` with the provided `class_id`, retrieving the
        existing label if one exists, creating a new one otherwise. If
        `class_id == None`, returns the `_default_label` if one exists, raises
        an `AttributeError` otherwise.

        Parameters
        ----------
            class_id (str): Name for a category of Trees

        Raises:
            AttributeError: If `class_id == None` and no `_default_label` is
                set.

        >>> tb = Treebank()
        >>> tb.get_label()
        Traceback (most recent call last):
            ....
        AttributeError: You cannot create unlabelled trees unless a default_label has been set
        >>> print(tb.labels)
        {}
        >>> x = tb.get_label('X')
        >>> print(tb.labels)
        {'X': Label('X')}
        >>> x1 = tb.get_label('X')
        >>> print(tb.labels)
        {'X': Label('X')}
        >>> y = tb.get_label('Y')
        >>> print(tb.labels)
        {'X': Label('X'), 'Y': Label('Y')}
        >>> id(x) == id(x1)
        True
        >>> id(x) != id(y)
        True
        """
        # If class_id is None...
        if not class_id: ##- RAW, OK
            # ... return the default label, if it exists...
            if isinstance(self.default_label, tr.Label):
                return self.default_label
            else:
                # ... if it doesn't, that's bad.
                raise AttributeError(
                    "You cannot create unlabelled trees unless " +
                    "a default_label has been set"
                )
        # If class_id is *not* None, & a label with that name already exists...
        elif class_id in self.labels: ##- RAW, OK
            # ...get that label from the dict and return it...
            return self.labels[class_id] ##- RAW, OK
        else:
            #...or, if it doesn't, then create it. The Label.__init__ method
            # will ensure the new Label goes in the dict.
            return tr.Label(self, class_id) ### RAW, OK

    @property
    def default_label(self):
        """Class attribute used where unlabelled nodes are needed - i.e. all
        nodes belong to the same category. Since the Label class is used to
        manage node substitution, a single default Label object is still
        needed for this."""
        return self._default_label

    @default_label.setter
    def default_label(self, deflab):
        """Setter for _default_label. Checks that the `Label` is indeed a
        `Label`.

        Parameters
        ----------
            deflab (Label): the default label.

        Raises:
            TypeError: If the `deflab` isn't a Label
        """
        if isinstance(deflab, tr.Label):
            if self._default_label:
                self._default_label.is_default = False
            deflab.is_default = True
            self._default_label = deflab
        else:
            raise TypeError(
                f"The default Label needs to be a {tr.Label}, not a {type(deflab)}"
            )

    def add_label(self, label):
        """Adds a new Label to the Treebank.

        Parameters
        ----------
            label (Label): the new Label.

        Raises:
            AttributeError: If `label` isn't a Label.
        """
        if label.class_id in self.labels: ### BOTH, RAW
            raise AttributeError(
                f"The Treebank already contains a label {label!s}"
            )
        else:
            self.labels[label.class_id] = label  ### BOTH, RAW

    def make_class_name(self): #
        """Makes up a classname if one is needed but none is supplied.

        Returns
        -------
            name (str): String of the form 'L' + an int equal to the number of
                already existing labels
        """
        #If there are 5 labels already, this will be L5, for example
        return f"L{len(self.labels)}"

    def print_all_labels(self, is_LaTeX=False):
        """A helper class for testing and inspection, mostly. Prints out all
        trees from all `Labels` in the `Treebank`, either using `__str__` or
        `to_LaTeX`.

        Parameters
        ----------
            is_LaTeX (bool): if true, print the trees in LaTeX `qtree` format:
                otherwise just use the standard str format
        """
        # make this a variable to ensure consistency
        spacer = "======================"
        print(spacer)
        # Treebank.labels is a dict, so the loop can get the names *and* Labels
        for name, label in self.labels.items():
            print(f"{name}:")
            label.print_terminal_subtrees(is_LaTeX)
            print(spacer)

    def clear(self):
        """Erases the entire treebank. Handle with care."""
        self.labels = {}

    def get_all_root_nodes(self):
        """Generates a dict containing all the Label names as keys, and the list
        of all treenodes in that label which have no parent node. Labels
        containing no root nodes
        """
        return {name: val.roots for name, val in self.labels.items()}

    def tree(self, treestr: str, **kwargs):
        """
        Creates a Tree from a string. The string format is for a NonTerminal is:

            `'([$label]<$operator>{$node_data}($child)*)'`

        ...where `$label` is the name of the `Label` on the node, `{$node_data}`
        an optional `dict` containing metadata for the node, and ($child) is
        the Tree.__str__() representation of each of the node's children. The
        string format for a Terminal is:

            `'([$label]{$node_data}$leaf)'`

        ... where `$leaf` is the the terminal content of the node â€” for
        instance, a string literal representing a word in a parse of a sentence.
        If `$leaf` cannot be evaluated with `eval`, it is cast to a `str`.

        Parameters
        ----------
            treestr (str): A treestring in the same format that Tree.__str__()
                outputs

        Returns
        -------
            Tree: A Tree, such that treestr == tree(treestr).__str__()

        Raises:
            AttributeError: if `treestr` is malformed.

        >>> import operators as ops
        >>> tb = Treebank()
        >>> t = tb.tree("([S]([N]sentence)([VP]([V]parses)([N]parser)))")
        >>> print(t)
        ([S]([N]'sentence')([VP]([V]'parses')([N]'parser')))
        >>> tt = eval(repr(t))
        >>> print(tt)
        ([S]([N]'sentence')([VP]([V]'parses')([N]'parser')))
        >>> print(tt())
        ('sentence', ('parses', 'parser'))
        >>> op = [ops.SUM, ops.PROD, ops.SQ, ops.EQ, ops.NOT, ops.OR, ops.AND]
        >>> gp = Treebank(op)
        >>> gpt = gp.tree("([float]<PROD>([int]6)([float]3.5))")
        >>> print(gpt)
        ([float]<PROD>([int]6)([float]3.5))
        """
        # if the treestr is valid, this regex will have exactly one match
        m = re.match(
            r"\((\[(?P<label>[^\]]*)\])?(\<(?P<operator>[A-Z_]+)\>)?" +
            r"(?P<node_data>\{.*\})?((?P<children>\(.*\)*?)|(?P<leaf>[^\)]*))\)",
            treestr
        )
        if m:
            # Capture groups from the regex:
            # Node label. Can be empty if default_label is set in Treebank
            lab = m.group("label")
            # Operator. Can be empty if default_op is set in Treebank
            oper80r = m.group("operator")
            # Metadata on node. Placeholder, for now.
            node_data = m.group("node_data")
            # children are other nodes under the present node; leaf is element
            # of the content the tree ranges over - typically a str for DOP, a
            # float for GP
            children = m.group("children")
            leaf = m.group("leaf")
        else:
            # Throw an error of treestr not valid
            raise AttributeError(f"Malformed treestring: {treestr}")
        # gets new Label if no existing label has name `lab`, else gets existing
        # Label: or, if `lab` does not exist, gets the default Label
        the_label = self.get_label(lab) if lab else self.get_label() ## XXX handle this in get_label
        # Empty list for children. If no children or leaf, this is a
        # non-terminal leaf node
        child_list = []
        if oper80r:
            operator = self.operators.get(oper80r, None)
            if not operator:
                raise AttributeError(f"Invalid operator {oper80r} in {treestr}, only {self.operators}")
        elif self.default_op and not leaf:
            operator = self.default_op
        else:
            operator = None
        if leaf:
            # create new Terminal with leaf
            if self.leaf_def_op and not operator:
                operator = self.leaf_def_op
            # the leaf string is taken as a literal - though in the case of 
            # Variable Terminals, this is used as a key to identify values 
            # of the variable passed down from the call to the root
            return self.T(self, the_label, leaf, operator=operator)
        # If there are children, make trees for them
        elif children:
            # Parens demarcate a child: However, a child may also have children,
            # so to distinguish between brackets of the immediate child and
            # further downstream children, we must track the bracketing level:
            # `level` keeps track of the number of unclosed brackets. If the
            # level drops to zero, the last paren character is the end of the
            # last child substring, and the next paren character, if there is
            # one, is the start of the next
            level = 0
            # Iterate through the chracters in the `children` substring,
            # add them to `current_child`
            current_child = ""
            for char in children:
                current_child += char
                # add parens to the count when `'('` is found
                if char == "(":
                    level += 1
                # remove parens from the count when `')'` is found
                elif char == ")":
                    level -= 1
                    # and the next paren character, if there is one, is the
                    # start of the next
                    if level == 0:
                        # If the level drops to zero, the last paren character
                        # is the end of the last child substring...
                        child_list.append(self.tree(current_child, **kwargs))
                        # ...and the next paren character, if there is one, is
                        # the start of the next
                        current_child = ""
                    elif level < 0:
                        # raise an exception if parens are unbalanced
                        raise AttributeError(
                            f"Your treestr's representations of its children \
                            is malformed: {children}"
                        )
                elif level == 0:
                    raise AttributeError(
                        f"Your treestr, contains stray text between the string \
                        representations of its children: {children}"
                    )
            if level != 0:
                raise AttributeError(
                    f"Your treestr's representations of its children has \
                    unbalanced parentheses: {children}"
                )
        # Creates and returns new NonTerminal with the right label, operator,
        # and children
        if child_list:
            return self.N(self, the_label, *child_list, operator=operator)
        return self.SS(self, the_label, 999)


class TypeLabelledTreebank(Treebank):
    """An extension to `Treebank` that uses `TypeLabels` instead of `Labels` to
    label `Trees`, which in turn use Python types instead of strings for label
    names.

    >>> import operators as ops
    >>> op = [ops.SUM, ops.PROD, ops.SQ, ops.EQ, ops.NOT, ops.OR, ops.AND]
    >>> tlt = TypeLabelledTreebank(op)
    >>> gpt = tlt.tree("([bool]<AND>([bool]<EQ>([float]<SQ>([int]6))([float]<PROD>([int]9)([float]<SUM>([float]2.5)([float]1.5))))([bool]<OR>([bool]<NOT>([bool]<EQ>([int]0)([int]1)))([bool]False)))")
    >>> print(gpt)
    ([bool]<AND>([bool]<EQ>([float]<SQ>([int]6))([float]<PROD>([int]9)([float]<SUM>([float]2.5)([float]1.5))))([bool]<OR>([bool]<NOT>([bool]<EQ>([int]0)([int]1)))([bool]False)))
    >>> gpt()
    True
    >>> from numpy import prod
    >>> from tree_iter import DepthFirstBottomUp
    >>> # Is `gpt` labelled entirely with types?
    >>> bool(prod(list(not isinstance(tree, tr.Tree) or type(tree.label.class_id) == type for tree in DepthFirstBottomUp(gpt))))
    True
    >>> list(subtree() for subtree in filter(lambda x: isinstance(x, tr.Tree), DepthFirstBottomUp(gpt)))
    [6, 36.0, 9, 2.5, 1.5, 4.0, 36.0, True, 0, 1, False, True, False, True, True]
    """

    tn = TypeNativiser()

    def get_label(self, classtype):
        if isinstance(classtype, str):
            try:
                ct = eval(classtype)
            except Exception:
                ct = str
            if not isinstance(ct, type):
                raise AttributeError(
                    f"TypeLabel name {classtype} does not evaluate to a type"
                )
        elif isinstance(classtype, type):
            ct = classtype
        if ct in self.labels:
            # ...get that label from the dict and return it...
            return self.labels[ct]
        else:
            #...or, if it doesn't, then create it. The Label.__init__ method
            # will ensure the new Label goes in the dict.
            return tr.TypeLabel(self, ct)

    def add_label(self, label):
        """Adds a label to the Treebank, like Treebank.add_label(label), except
        this verifies that the label is a TypeLabel
        """
        if isinstance(label, tr.TypeLabel):
            super().add_label(label)
        else:
            raise TypeError("TypeLabelledTreebanks only use TypeLabels")

    def make_class_name(self):
        """The superclass has this, but since labels in TypeLabelledTreebank
        are just types, and we're not making new types, here make_class_name is
        just going to throw the same error you'd get if it didn't exist. Sneaky,
        huh?
        """
        raise AttributeError(
            "class 'TypeLabelledTreebank' has no attribute 'make_class_name'"
        )

    # def verify_tree(self, t):
    #     """Checks `Tree t` to ensure that for all subtrees of `t`, the return
    #     type of `subtree.operator` matches the label, and the labels of
    #     `subtree.children` correspond to a type-valid inputs to
    #     `subtree.operator`.
    #     """
    #     t_type = type(t)
    #     if issubclass(t_type, self.T):
    #         self.verify_terminal(t)
    #     elif issubclass(t_type, self.N):
    #         self.verify_nonterminal(t)
    #     else:
    #         raise OperatorError(
    #             f"{t} is of an unknown subclass, {t_type}"
    #         )
    #     return True

    # def verify_terminal(self, term):
    #     if isinstance(term[0], term.label.class_id): ##-OK TL RAW
    #         return True
    #     elif issubclass(TypeLabelledTreebank.tn.type_ify(term[0]), term.label.class_id):
    #         return True
    #         #return term[0].apply(lambda _: type(_) == term.label.class_id).all() ##-OK TL RAW
    #     else:
    #         raise OperatorError(
    #             f"{term} has a mismatch of label-type " +
    #             f"({term.label.classname}) and leaf-type " + ##-OK TL NAME
    #             f"({type(term[0]).__name__})"
    #         )

    # def verify_nonterminal(self, nonterm):
    #     if not issubclass(nonterm.label.class_id, nonterm._operator.return_type): ##-OK TL RAW
    #         raise OperatorError(
    #             f"{nonterm} has a mismatch of label-type " +
    #             f"({nonterm.label.classname}) and operator " +  ##-OK TL NAME
    #             f"return-type ({nonterm._operator.return_type.__name__})"
    #         )
    #     if not nonterm._operator._type_seq_legal(*[ch.label.class_id for ch in nonterm]): ##-OK TL RAW
    #         raise OperatorError(
    #             f"the children of {nonterm} are not a legal argument-sequence " +
    #             f"for its operator {nonterm._operator.name}"
    #         )
    #     return True

    def tree(self, treestr: str, **kwargs):
        """Overrides the standard Treebank.tree function, calls it, but then
        verifies that the resulting tree is typesafe. If it is not, deletes the
        tree and all its subtrees from the treebank, and if it is it returns the
        tree.

        >>> import operators as ops
        >>> op = [ops.SUM, ops.PROD, ops.SQ, ops.EQ, ops.NOT, ops.OR, ops.AND]
        >>> tlt = TypeLabelledTreebank(op)
        >>> gpt0 = tlt.tree("([bool]<AND>([bool]<EQ>([float]<SQ>([int]6))([float]<PROD>([int]9)([float]<SUM>([float]2.5)([float]1.5))))([bool]<OR>([bool]<NOT>([bool]<EQ>([int]0)([int]1)))([bool]False)))")
        >>> gpt_err0 = tlt.tree("([bool]<AND>([bool]<EQ>([float]<SQ>([int]6.0))([float]<PROD>([int]9)([float]<SUM>([float]2.5)([float]1.5))))([bool]<OR>([bool]<NOT>([bool]<EQ>([int]0)([int]1)))([bool]False)))")
        Traceback (most recent call last):
            ....
        tree_errors.OperatorError: Error in ([bool]<AND>([bool]<EQ>([float]<SQ>([int]6.0))([float]<PROD>([int]9)([float]<SUM>([float]2.5)([float]1.5))))([bool]<OR>([bool]<NOT>([bool]<EQ>([int]0)([int]1)))([bool]False))): ([int]6.0) has a mismatch of label-type (int) and leaf-type (float)
        >>> gpt_err1 = tlt.tree("([bool]<AND>([int]<EQ>([float]<SQ>([int]6))([float]<PROD>([int]9)([float]<SUM>([float]2.5)([float]1.5))))([bool]<OR>([bool]<NOT>([bool]<EQ>([int]0)([int]1)))([bool]False)))")
        Traceback (most recent call last):
            ....
        tree_errors.OperatorError: Error in ([bool]<AND>([int]<EQ>([float]<SQ>([int]6))([float]<PROD>([int]9)([float]<SUM>([float]2.5)([float]1.5))))([bool]<OR>([bool]<NOT>([bool]<EQ>([int]0)([int]1)))([bool]False))): ([int]<EQ>([float]<SQ>([int]6))([float]<PROD>([int]9)([float]<SUM>([float]2.5)([float]1.5)))) has a mismatch of label-type (int) and operator return-type (bool)
        >>> gpt_err2 = tlt.tree("([bool]<AND>([bool]<EQ>([float]<SQ>([bool]True))([float]<PROD>([int]9)([float]<SUM>([float]2.5)([float]1.5))))([bool]<OR>([bool]<NOT>([bool]<EQ>([int]0)([int]1)))([bool]False)))")
        Traceback (most recent call last):
            ....
        tree_errors.OperatorError: Error in ([bool]<AND>([bool]<EQ>([float]<SQ>([bool]True))([float]<PROD>([int]9)([float]<SUM>([float]2.5)([float]1.5))))([bool]<OR>([bool]<NOT>([bool]<EQ>([int]0)([int]1)))([bool]False))): the children of ([float]<SQ>([bool]True)) are not a legal argument-sequence for its operator SQ
        >>> tlt.print_all_labels()
        ======================
        <class 'bool'>:
        ([bool]<EQ>([float]<SQ>([int]6))([float]<PROD>([int]9)([float]<SUM>([float]2.5)([float]1.5))))
        ([bool]<EQ>([int]0)([int]1))
        ([bool]<NOT>([bool]<EQ>([int]0)([int]1)))
        ([bool]False)
        ([bool]<OR>([bool]<NOT>([bool]<EQ>([int]0)([int]1)))([bool]False))
        ([bool]<AND>([bool]<EQ>([float]<SQ>([int]6))([float]<PROD>([int]9)([float]<SUM>([float]2.5)([float]1.5))))([bool]<OR>([bool]<NOT>([bool]<EQ>([int]0)([int]1)))([bool]False)))
        ======================
        <class 'float'>:
        ([float]<SQ>([int]6))
        ([float]2.5)
        ([float]1.5)
        ([float]<SUM>([float]2.5)([float]1.5))
        ([float]<PROD>([int]9)([float]<SUM>([float]2.5)([float]1.5)))
        ======================
        <class 'int'>:
        ([int]6)
        ([int]9)
        ([int]0)
        ([int]1)
        ======================
        """
        tr = None
        try:
            tr = super().tree(treestr, **kwargs)
            tr.is_valid
        except OperatorError as e:
            if tr:
                tr.delete()
            e.treestr = treestr
            raise e
        return tr


def tree(treestr: str, treebank = None, **kwargs):
    if not treebank:
        treebank = Treebank()
    return treebank.tree(treestr, **kwargs)

def main():
    #import doctest
    #doctest.testmod()
    from gp import GPTreebank
    import operators as ops
    op = [ops.SUM, ops.PROD, ops.SQ, ops.CUBE, ops.POW]
    gp = GPTreebank(operators=op)
    mewtwo = gp.tree("([float]<SUM>([float]<SQ>([int]$mu))([float]<SUM>([float]<PROD>([int]3)([int]$mu))([int]2)))")


if __name__ == '__main__':
    main()
